{
  "services": {
    "abilities.types": {
      "kind": "model",
      "path": "worldcore/abilities/AbilityTypes.ts",
      "functions": [
        "findAbilityByNameOrId"
      ],
      "dependsOn": [
        "actions.types",
        "combat.engine",
        "mud.resources"
      ],
      "notes": [
        "Defines AbilityKind and AbilityDefinition plus ABILITIES map (e.g. warrior_power_strike, warrior_cleave) with channel, weaponSkill, resourceType, damage multipliers, and cooldownMs.",
        "findAbilityByNameOrId resolves abilities by id or case-insensitive name."
      ]
    },
    "actions.types": {
      "kind": "model",
      "path": "worldcore/actions/ActionTypes.ts",
      "notes": [
        "Defines AttackChannel ('weapon'|'spell'|'ability') and ActionRequest union over AttackActionRequest and HarvestActionRequest.",
        "Used as the transport-neutral action envelope for MUD and future 2.5D clients."
      ]
    },
    "actions.worldService": {
      "kind": "service",
      "path": "worldcore/actions/WorldActionService.ts",
      "functions": [
        "performAction"
      ],
      "dependsOn": [
        "actions.types",
        "mud.actions"
      ],
      "notes": [
        "Shared entry point for generic world actions (v1: attack + harvest) across MUD and future clients.",
        "Currently delegates to MudActions.handleAttackAction and handleGatherAction and returns ActionResult with message lines."
      ]
    },
    "ai.behaviorContext": {
      "kind": "model",
      "path": "worldcore/ai/brains/BehaviorContext.ts",
      "notes": [
        "Defines BehaviorContext (perception, players, cooldownMs, attackCooldownMs, setCooldownMs, optional guardMemory) and GuardMemory helpers.",
        "BehaviorHandler type is a pure function BehaviorContext -> NpcDecision|null."
      ]
    },
    "ai.brainTypes": {
      "kind": "model",
      "path": "worldcore/ai/NpcBrainTypes.ts",
      "notes": [
        "Defines NpcPerception, PerceivedPlayer, and NpcDecision variants (idle, attack_entity, move_to_room, say, flee) plus NpcBrain interface.",
        "Engine-agnostic AI contract usable in-process or over-the-wire to a remote AI service."
      ]
    },
    "ai.brains.aggressive": {
      "kind": "service",
      "path": "worldcore/ai/brains/AggressiveBrain.ts",
      "functions": [
        "decideAggressiveBehavior"
      ],
      "dependsOn": [
        "ai.brainTypes",
        "ai.behaviorContext"
      ],
      "notes": [
        "Aggressive brain: if no cooldown and at least one player, attacks the first player and resets cooldown; otherwise returns null.",
        "Always uses melee attack_style for now."
      ]
    },
    "ai.brains.coward": {
      "kind": "service",
      "path": "worldcore/ai/brains/CowardBrain.ts",
      "functions": [
        "decideCowardBehavior"
      ],
      "dependsOn": [
        "ai.brainTypes",
        "ai.behaviorContext",
        "ai.brains.aggressive"
      ],
      "notes": [
        "Coward brain: if HP < maxHp, emits a flee decision away from the first perceived player; otherwise defers to aggressive behavior."
      ]
    },
    "ai.brains.guard": {
      "kind": "service",
      "path": "worldcore/ai/brains/GuardBrain.ts",
      "functions": [
        "pickGuardTarget",
        "decideGuardBehavior"
      ],
      "dependsOn": [
        "ai.brainTypes",
        "ai.behaviorContext"
      ],
      "notes": [
        "Guard brain: targets players with recent crime, preferring healer > dps > tank and lower HP, and can warn or call for help based on severity and safe-hub status.",
        "Uses guardMemory to avoid spamming warnings and to track help calls."
      ]
    },
    "ai.brains.neutral": {
      "kind": "service",
      "path": "worldcore/ai/brains/NeutralBrain.ts",
      "functions": [
        "decideNeutralBehavior"
      ],
      "dependsOn": [
        "ai.behaviorContext",
        "ai.brainTypes"
      ],
      "notes": [
        "Neutral brain: always returns null; used for non-hostile NPCs that currently do nothing."
      ]
    },
    "ai.localSimpleBrain": {
      "kind": "service",
      "path": "worldcore/ai/LocalSimpleNpcBrain.ts",
      "class": "LocalSimpleAggroBrain",
      "functions": [
        "decide"
      ],
      "dependsOn": [
        "ai.brainTypes"
      ],
      "notes": [
        "Simple in-process NPC brain that attacks the first player in room on a cooldown and makes cowards flee once injured.",
        "Tracks per-NPC cooldown in memory keyed by npcId."
      ]
    },
    "auction.auditLog": {
      "kind": "service",
      "path": "worldcore/auction/AuctionAuditLog.ts",
      "functions": [
        "logAuctionEvent"
      ],
      "dependsOn": [
        "db.main",
        "utils.logger",
        "auction.types"
      ],
      "notes": [
        "Writes auction_log rows with shard, listing id, actor info, action, and JSON details for create/buy/cancel/expire/claim/reclaim events.",
        "Failures are logged via Logger.scope('AUCTION_AUDIT') but never thrown back to callers."
      ]
    },
    "auction.format": {
      "kind": "service",
      "path": "worldcore/auction/AuctionFormat.ts",
      "functions": [
        "formatAuctionListing"
      ],
      "dependsOn": [
        "auction.types",
        "mud.context"
      ],
      "notes": [
        "Builds a one-line MUD description for a listing like '#12 Hematite Iron Ore [common] x20 – 3g each (total 60g) by Testing [active]'.",
        "Looks up item definitions via ctx.items?.get to resolve item name and rarity."
      ]
    },
    "auction.postgres": {
      "kind": "service",
      "path": "worldcore/auction/PostgresAuctionService.ts",
      "class": "PostgresAuctionService",
      "functions": [
        "browse",
        "get",
        "createListing",
        "buyout",
        "cancelListing",
        "listBySeller",
        "claimProceeds",
        "expireOld",
        "reclaimExpiredForSeller"
      ],
      "dependsOn": [
        "db.main",
        "utils.logger",
        "auction.types",
        "auction.service",
        "auction.auditLog"
      ],
      "notes": [
        "Postgres-backed AuctionService using auctions table; maps AuctionRow to AuctionListing via rowToListing.",
        "Implements search + pagination, creates active listings with expires_at TTL, marks rows sold/cancelled/expired, tracks proceeds, and supports reclaiming expired items for sellers."
      ]
    },
    "auction.service": {
      "kind": "service_contract",
      "path": "worldcore/auction/AuctionService.ts",
      "functions": [
        "browse",
        "get",
        "createListing",
        "buyout",
        "cancelListing",
        "listBySeller",
        "claimProceeds",
        "expireOld",
        "reclaimExpiredForSeller"
      ],
      "dependsOn": [
        "auction.types"
      ],
      "notes": [
        "AuctionService interface for browsing, creating, buying out, cancelling, expiring, and reclaiming auctions plus claiming proceeds.",
        "Used by PostgresAuctionService and MUD commands."
      ]
    },
    "auction.types": {
      "kind": "model",
      "path": "worldcore/auction/AuctionTypes.ts",
      "notes": [
        "Defines AuctionStatus ('active'|'sold'|'cancelled'|'expired') and AuctionListing with shard, seller, buyer, item, pricing, and proceeds fields.",
        "Used across auction services, formatting, and audit logging."
      ]
    },
    "auth.debugGate": {
      "kind": "service",
      "path": "worldcore/auth/debugGate.ts",
      "functions": [
        "getShardMode",
        "canUseDebugCommands",
        "requireDebug"
      ],
      "dependsOn": [
        "auth.types"
      ],
      "notes": [
        "Gatekeeper for debug commands based on identity flags and shard mode.",
        "Disallows debug commands on live shards and enforces minimum StaffRole threshold."
      ]
    },
    "auth.postgres": {
      "kind": "service",
      "path": "worldcore/auth/PostgresAuthService.ts",
      "class": "PostgresAuthService",
      "functions": [
        "registerAccount",
        "loginWithPassword",
        "verifyToken",
        "getAccountById"
      ],
      "dependsOn": [
        "db.main",
        "utils.logger",
        "auth.service",
        "auth.types"
      ],
      "notes": [
        "Postgres + JWT implementation of AuthService with PBKDF2 password hashing and signed tokens.",
        "Persists flags JSONB on accounts, logs auth events, and returns AuthResult with expiry timestamp."
      ]
    },
    "auth.service": {
      "kind": "service_contract",
      "path": "worldcore/auth/AuthService.ts",
      "functions": [
        "registerAccount",
        "loginWithPassword",
        "verifyToken",
        "getAccountById"
      ],
      "dependsOn": [
        "auth.types"
      ],
      "notes": [
        "Abstract auth API over accounts: register, login, token verification, and profile lookup.",
        "AccountFlags include staff/debug knobs such as isGM, isDev, isOwner, isTester, isShardBuilder."
      ]
    },
    "auth.staffAudit": {
      "kind": "service",
      "path": "worldcore/auth/StaffAuditLog.ts",
      "functions": [
        "logStaffAction"
      ],
      "dependsOn": [
        "db.main",
        "utils.logger",
        "auth.types"
      ],
      "notes": [
        "Writes rows into staff_action_log with actor id/name, actionName, and JSON details.",
        "Errors are logged but never allowed to break the calling staff command."
      ]
    },
    "auth.staffRoles": {
      "kind": "model",
      "path": "worldcore/auth/StaffRoles.ts",
      "notes": [
        "Defines StaffRole ('player'|'guide'|'gm'|'dev'|'owner') and StaffRoleLevel numeric mapping.",
        "Used for permission checks and debug/staff tools."
      ]
    },
    "auth.types": {
      "kind": "model",
      "path": "worldcore/shared/AuthTypes.ts",
      "functions": [
        "getStaffRole",
        "getStaffTier",
        "isGuide",
        "isGMOrHigher",
        "isDevOrHigher",
        "isOwner"
      ],
      "notes": [
        "Shared auth/identity model: UserId, CharacterId, ShardId, AccountFlags, AccountProfile, CharacterSummary, AuthTokenPayload, AuthResult, AttachedIdentity.",
        "Also provides staff role helpers and StaffRole/StaffRoleLevel for permission checks."
      ]
    },
    "bank.economyHelpers": {
      "kind": "utility",
      "path": "worldcore/bank/BankEconomyHelpers.ts",
      "functions": [
        "getBankGold",
        "setBankGold",
        "addBankGold"
      ],
      "dependsOn": [
        "bank.service"
      ],
      "notes": [
        "Small helpers to read, clamp, and mutate bank.gold balance on BankState.",
        "Used by higher-level bank operations and services."
      ]
    },
    "bank.ops": {
      "kind": "service",
      "path": "worldcore/bank/bankOps.ts",
      "functions": [
        "addToBankSlots",
        "formatBankView",
        "takeFromInventoryExactSlot",
        "bankDepositFromInventorySlot"
      ],
      "dependsOn": [
        "bank.service",
        "items.service",
        "items.catalog",
        "characters.types",
        "bank.types",
        "economy.helpers",
        "bank.economyHelpers"
      ],
      "notes": [
        "High-level bank operations: stack-aware deposits, formatted bank views, and inventory-slot transfers.",
        "Handles unknown items by rolling back via giveItemsToCharacter and returns leftovers when the bank is full."
      ]
    },
    "bank.postgres": {
      "kind": "service",
      "path": "worldcore/bank/PostgresBankService.ts",
      "class": "PostgresBankService",
      "functions": [
        "getBank",
        "saveBank"
      ],
      "dependsOn": [
        "db.main",
        "utils.logger",
        "bank.service",
        "bank.types"
      ],
      "notes": [
        "Postgres-backed implementation using bank_slots and bank_accounts tables.",
        "Maintains a fixed BANK_SLOT_COUNT, loads slots ordered by index, and persists both gold and per-slot item stacks in a transaction."
      ]
    },
    "bank.service": {
      "kind": "service_contract",
      "path": "worldcore/bank/BankService.ts",
      "functions": [
        "getBank",
        "saveBank"
      ],
      "dependsOn": [
        "bank.types",
        "characters.types"
      ],
      "notes": [
        "BankService interface over BankState with typed ownerKind.",
        "Supports loading/creating a bank and saving the full slot + gold state."
      ]
    },
    "bank.types": {
      "kind": "model",
      "path": "worldcore/bank/BankTypes.ts",
      "notes": [
        "Defines BankOwnerKind ('account'|'character'|'guild'|'city') and BankOwnerRef.",
        "Used across all bank operations and commands to address the correct bank entity."
      ]
    },
    "characters.db": {
      "kind": "service",
      "path": "worldcore/characters/PostgresCharacterService.ts",
      "class": "PostgresCharacterService",
      "functions": [
        "listCharactersForUser",
        "loadCharacter",
        "loadCharacterForUser",
        "createCharacter",
        "saveCharacter",
        "patchCharacter",
        "grantXp",
        "learnSpell",
        "equipItem"
      ],
      "dependsOn": [
        "db.main",
        "utils.logger",
        "characters.types",
        "characters.leveling",
        "classes.definitions"
      ],
      "notes": [
        "Postgres-backed character service using the characters table and CharacterRow → CharacterState mapping.",
        "Supports partial JSONB patching, XP/level gains with per-class attribute growth, and spell/equipment updates."
      ]
    },
    "characters.leveling": {
      "kind": "service",
      "path": "worldcore/characters/Leveling.ts",
      "functions": [
        "xpForNextLevel",
        "applyXp"
      ],
      "notes": [
        "Simple linear XP curve (100 * level) used by PostgresCharacterService.",
        "applyXp applies a delta, loops level-ups, and returns a LevelingResult with old/new levels and XP plus leveledUp flag."
      ]
    },
    "characters.persist": {
      "kind": "service",
      "path": "worldcore/characters/characterPersist.ts",
      "functions": [
        "persistCharacterSnapshot"
      ],
      "dependsOn": [
        "characters.db",
        "shared.session"
      ],
      "notes": [
        "Utility that snapshots the current CharacterState from a MUD context into Postgres via ctx.characters.patchCharacter.",
        "Persists position, region, attributes, inventory, equipment, spellbook, abilities, and progression."
      ]
    },
    "characters.service": {
      "kind": "service_contract",
      "path": "worldcore/characters/CharacterService.ts",
      "functions": [
        "listCharactersForUser",
        "createCharacter",
        "loadCharacter",
        "saveCharacter"
      ],
      "dependsOn": [
        "auth.types",
        "characters.types"
      ],
      "notes": [
        "Backend-agnostic character API shared by MMO shard, webend, and tools.",
        "Uses UserId/CharacterId/ShardId and CharacterState/Summary types."
      ]
    },
    "characters.sheet": {
      "kind": "service",
      "path": "worldcore/characters/characterSheet.ts",
      "functions": [
        "buildCharacterSheetLine"
      ],
      "dependsOn": [
        "combat.entityCombat",
        "world.regionText",
        "characters.stats"
      ],
      "notes": [
        "Builds a single-line textual character sheet including name, class, level, XP, HP, status, shard, region, base and effective attributes, and active title name.",
        "Uses computeEffectiveAttributes plus entity HP/in-combat flags for status labeling."
      ]
    },
    "characters.stateGuard": {
      "kind": "service",
      "path": "worldcore/characters/CharacterStateGuard.ts",
      "functions": [
        "hydrateCharacterRegion"
      ],
      "dependsOn": [
        "characters.types",
        "world.manager",
        "utils.logger"
      ],
      "notes": [
        "Ensures CharacterState.lastRegionId matches the region resolved by ServerWorldManager at posX/posZ.",
        "Logs region changes for debugging and returns either original or updated CharacterState."
      ]
    },
    "characters.stats": {
      "kind": "service",
      "path": "worldcore/characters/Stats.ts",
      "functions": [
        "computeEffectiveAttributes"
      ],
      "dependsOn": [
        "characters.types",
        "items.catalog",
        "items.service",
        "characters.titles"
      ],
      "notes": [
        "Computes effective attributes by cloning base attributes, then applying item stat bonuses from ItemService or ItemCatalog and active title bonuses from TITLES.",
        "Used by characterSheet and any system that needs gear-adjusted attributes."
      ]
    },
    "characters.titles": {
      "kind": "model",
      "path": "worldcore/characters/TitleTypes.ts",
      "functions": [
        "getTitleDefinition",
        "listAllTitles"
      ],
      "notes": [
        "Defines TitleDefinition and TITLES map including rat_slayer and ore_breaker unlocks and attribute bonuses.",
        "Used both by progression.titles.* and characterStats for bonus application."
      ]
    },
    "characters.types": {
      "kind": "model",
      "path": "worldcore/characters/CharacterTypes.ts",
      "functions": [
        "defaultAttributes",
        "defaultInventory",
        "defaultEquipment",
        "defaultSpellbook",
        "defaultAbilities",
        "defaultProgression",
        "rowToCharacterState",
        "toCharacterSummary"
      ],
      "notes": [
        "Canonical CharacterRow and CharacterState model plus typed v1.5 JSONB blobs for attributes, inventory, equipment, spellbook, abilities, and progression.",
        "Includes SimpleTask/QuestState integration in ProgressionState and helpers to transform DB rows into in-memory state and UI CharacterSummary DTOs."
      ]
    },
    "classes.definitions": {
      "kind": "model",
      "path": "worldcore/classes/ClassDefinitions.ts",
      "functions": [
        "getClassDefinition",
        "getCombatRoleForClass",
        "getPerLevelAttributesForClass",
        "getPrimaryResourceForClass",
        "getPowerResourcesForClass",
        "getAllClassDefinitions"
      ],
      "notes": [
        "Defines ClassId, ClassDefinition, CombatRole, archetypes, and class power resources plus full CLASS_DEFINITIONS and CLASS_PER_LEVEL tables for Virtuoso, Illusionist, Adventurer, legacy Warrior/Mage/Rogue/Priest, and others.",
        "Provides helpers for per-level attribute gains, primary/secondary resources, favored schools/weapon skills, and armor/weapon access."
      ]
    },
    "combat.castingGates": {
      "kind": "service",
      "path": "worldcore/combat/CastingGates.ts",
      "functions": [
        "applyActionCostAndCooldownGates"
      ],
      "dependsOn": [
        "combat.cooldowns",
        "resources.power",
        "characters.types"
      ],
      "notes": [
        "Centralized gates for action resource costs + cooldowns (spells/songs/abilities).",
        "Guarantees: cooldowns do not start and resources are not consumed if the action fails.",
        "Order: check cooldown remaining → spend resource → start cooldown."
      ]
    },
    "combat.cooldowns": {
      "kind": "service",
      "path": "worldcore/combat/Cooldowns.ts",
      "functions": [
        "ensureCooldownBucket",
        "getCooldownRemaining",
        "startCooldown",
        "checkAndStartCooldown"
      ],
      "dependsOn": [
        "characters.types"
      ],
      "notes": [
        "Stores cooldowns under char.progression.cooldowns[bucket][key].",
        "Provides helpers to query remaining time and atomically check+start cooldowns with user-facing error strings."
      ]
    },
    "combat.cowardice": {
      "kind": "utility",
      "path": "worldcore/combat/Cowardice.ts",
      "functions": [
        "resolveCowardiceTier",
        "computeCowardiceDamageTakenMultiplier",
        "getCowardiceInfo",
        "formatCowardiceStatus"
      ],
      "dependsOn": [
        "characters.types",
        "world.regionDanger"
      ],
      "notes": [
        "Cowardice/risk-mode incoming damage logic. Returns scalar multiplier applied to incoming damage.",
        "Uses RegionDanger tier to scale cowardice impact."
      ]
    },
    "combat.damagePolicy": {
      "kind": "utility",
      "path": "worldcore/combat/DamagePolicy.ts",
      "functions": [
        "serviceProtectionGate",
        "resolvePlayerVsPlayerPolicy",
        "canDamage",
        "canDamageFast"
      ],
      "dependsOn": [
        "combat.serviceProtection",
        "pvp.rules",
        "world.regionFlags"
      ],
      "notes": [
        "Centralized 'can I damage this target?' policy layer.",
        "v1: blocks damage to protected service NPCs; applies fail-closed PvP gating using RegionFlags + PvpRules; defaults to PvE allow otherwise."
      ]
    },
    "combat.engine": {
      "kind": "service",
      "path": "worldcore/combat/CombatEngine.ts",
      "functions": [
        "computeDamage"
      ],
      "dependsOn": [
        "actions.types",
        "characters.types",
        "combat.mitigation",
        "combat.resists",
        "combat.scaling",
        "combat.statusEffects",
        "shared.entities",
        "skills.progression",
        "utils.logger"
      ],
      "notes": [
        "Core damage math for weapon, ability, spell, and song channels.",
        "Scales off STR/INT, level, weapon skill, spell school, or song instrument skill, with crit/glancing and rough armor/resist mitigation."
      ]
    },
    "combat.entityCombat": {
      "kind": "utility",
      "path": "worldcore/combat/entityCombat.ts",
      "functions": [
        "markInCombat",
        "killEntity",
        "isDeadEntity",
        "resurrectEntity",
        "applySimpleDamageToPlayer",
        "computeNpcMeleeDamage",
        "applyCombatResultToPlayer"
      ],
      "dependsOn": [
        "characters.types",
        "combat.cowardice",
        "combat.statusEffects",
        "shared.entities",
        "world.regionDanger"
      ],
      "notes": [
        "Shared entity HP helpers and NPC melee damage formula.",
        "Tags entities in combat, handles simple kill/resurrect, applies simple damage with cowardice & status effect multipliers.",
        "On player death, bumps RegionDanger for the character's region to make that area temporarily more dangerous.",
        "Min-damage rule v1: positive fractional incoming damage becomes at least 1.",
        "Note that DamageContext.incomingModsAlreadyApplied exists and why (prevents double-dip when CombatEngine bakes defender taken mods)"
      ]
    },
    "combat.mitigation": {
      "kind": "service",
      "path": "worldcore/combat/Mitigation.ts",
      "functions": [
        "applyArmorMitigation",
        "armorMultiplier"
      ],
      "dependsOn": [],
      "notes": [
        "v1 armor mitigation helper for physical damage.",
        "Pure functions: no world state. Used by CombatEngine computeDamage/applyDamage pipeline."
      ]
    },
    "combat.npc": {
      "kind": "service",
      "path": "worldcore/combat/NpcCombat.ts",
      "functions": [
        "performNpcAttack",
        "applySimpleNpcCounterAttack",
        "announceSpawnToRoom",
        "scheduleNpcCorpseAndRespawn"
      ],
      "dependsOn": [
        "actions.types",
        "characters.service",
        "characters.types",
        "combat.engine",
        "combat.entityCombat",
        "combat.serviceProtection",
        "core.rooms",
        "items.catalog",
        "items.inventoryHelpers",
        "loot.text",
        "mail.service",
        "npc.manager",
        "npc.types",
        "resources.power",
        "shared.entities",
        "skills.progression",
        "utils.logger",
        "utils.random",
        "combat.damagePolicy"
      ],
      "notes": [
        "High-level NPC attack executor and death handling used by v1 brains.",
        "Uses CombatEngine for damage, updates skill and fury progression, applies counter-attacks, grants XP, and schedules corpse/respawn with resource-node special-casing.",
        "Now delegate overflow behavior to the helper",
        "Corpse/despawn/respawn flow assumes combat status effects are cleared on death and do not tick on corpses."
      ]
    },
    "combat.regionDangerAuras": {
      "kind": "utility",
      "path": "worldcore/combat/RegionDangerAuras.ts",
      "functions": [
        "getRegionDangerAuraStrengthForTier(tier, config?)",
        "updateRegionDangerAuraForCharacter(char, nowMs?, config?)"
      ],
      "dependsOn": [
        "world.regionDanger",
        "world.RegionFlags",
        "characters.types",
        "combat.statusEffects"
      ],
      "notes": [
        "Converts RegionDanger tier into an ambient debuff aura ('Region Peril').",
        "Default config applies +5% damageTakenPct when region danger tier >= 3.",
        "TickEngine calls updateRegionDangerAuraForCharacter per character tick to keep aura in sync with current region."
      ]
    },
    "combat.resists": {
      "kind": "utility",
      "path": "worldcore/combat/Resists.ts",
      "functions": [
        "resistMultiplier",
        "applyResistMitigation"
      ],
      "dependsOn": [],
      "notes": [
        "Resists v1 helper. Pure functions for non-physical damage mitigation.",
        "Default curve: mitigation = min(0.75, resist/200). Resist values are 'rating-like' not percent."
      ]
    },
    "combat.scaling": {
      "kind": "utility",
      "path": "worldcore/combat/CombatScaling.ts",
      "functions": [
        "getWeaponSkillLevel",
        "getSpellSchoolLevel"
      ],
      "dependsOn": [
        "skills.progression",
        "characters.types"
      ],
      "notes": [
        "Maps raw weapon/spell school skill into effective combat level.",
        "If no skill is recorded, falls back to character level; otherwise uses skill/5 with a minimum of 1."
      ]
    },
    "combat.serviceProtection": {
      "kind": "utility",
      "path": "worldcore/combat/ServiceProtection.ts",
      "functions": [
        "isServiceProtectedNpcProto",
        "isServiceProtectedEntity",
        "serviceProtectedCombatLine"
      ],
      "dependsOn": [],
      "notes": [
        "Protects critical service NPCs (bank/mail/auction/etc.) from being killed/griefed.",
        "Pure helpers; detection based on proto id/tags and optional runtime flags."
      ]
    },
    "combat.skinLootService": {
      "kind": "service",
      "service": "combat",
      "path": "worldcore/combat/SkinLootService.ts",
      "class": "SkinLootService",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [
        "db.database",
        "utils.logger"
      ],
      "provides": [
        "getSkinLootService(): singleton accessor",
        "SkinLootService.getEntries(protoId, tags): proto-first + tag fallback, deterministic ordering"
      ],
      "owns": []
    },
    "combat.statusEffects": {
      "kind": "service",
      "path": "worldcore/combat/StatusEffects.ts",
      "functions": [
        "applyStatusEffect(char,input)",
        "applyStatusEffectToEntity(entity,input)",
        "clearAllStatusEffects(char)",
        "clearAllStatusEffectsFromEntity(entity)",
        "clearStatusEffect(char,id)",
        "clearStatusEffectFromEntity(entity,id)",
        "getActiveStatusEffects(char, nowMs?)",
        "getActiveStatusEffectsForEntity(entity, nowMs?)",
        "computeCombatStatusSnapshot(char, nowMs?)",
        "computeEntityCombatStatusSnapshot(entity, nowMs?)",
        "computeCombatStatusSnapshotForEntity (alias of computeEntityCombatStatusSnapshot)",
        "tickStatusEffects(char, nowMs?)",
        "tickEntityStatusEffects(entity, nowMs?)",
        "tickEntityStatusEffectsAndApplyDots(entity, nowMs?)"
      ],
      "dependsOn": [
        "characters.types",
        "combat.statusStackingPolicy",
        "shared.entities"
      ],
      "provides": [
        "CombatStatusSnapshot aggregation (attributes, damageDealtPct, damageTakenPct, damageDealtPctBySchool, damageTakenPctBySchool, armor/resist bonuses)",
        "DOT ticking helper for entities (applies damage and can trigger death).",
        "Stacking policy resolver support (refresh|unique|stack|refresh_stack|versioned_by_applier).",
        "StatusEffect storage for characters and entities (NPCs).",
        "StatusEffect storage under char.progression.statusEffects.active"
      ],
      "notes": [
        "Status effects are stored under character.progression.statusEffects (JSONB) and are ticked/expired via tickStatusEffects().",
        "Back-compat: NewStatusEffectInput accepts `stacks` as an alias for `initialStacks` (older call-sites/tests).",
        "damageTakenPct and damageDealtPct are FRACTIONS (0.05 = +5%).",
        "damageDealtPctBySchool and damageTakenPctBySchool are FRACTIONS (0.05 = +5%).",
        "Status effect spine used by vulnerability, region peril auras, and outgoing/incoming damage modifiers.",
        "NPC/Entity status-effects carrier + DOT ticking implemented; effects clear on death/despawn and DOT ticking stops immediately on death.",
        "Entity tick helpers can optionally apply DOT damage and must stop immediately if entity dies.",
        "Stacking behavior is governed by StatusStackingPolicy (including versioned_by_applier).",
        "Entity/NPC effects are stored under entity.statusEffects.active (mirrors character progression storage).",
        "Imports DamageSchool as a type from CombatEngine (type-only); no runtime circular dependency."
      ]
    },
    "combat.statusStackingPolicy": {
      "kind": "service",
      "service": "combat",
      "path": "worldcore/combat/StatusStackingPolicy.ts",
      "functions": [
        "isStatusStackingPolicy",
        "resolveStatusStackingPolicy"
      ],
      "class": null,
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Status stacking policy matrix + resolver used by StatusEffects to decide refresh/overwrite/stack behavior.",
        "Policies currently supported: refresh | unique | stack | refresh_stack | versioned_by_applier.",
        "versioned_by_applier: statusEffectVersion stacks only when applied by distinct appliers (per-applier slot), capped by maxStacks; same applier upgrades their slot; same version refreshes/last-write-wins (no extra stack)."
      ]
    },
    "combat.vulnerability": {
      "kind": "utility",
      "path": "worldcore/combat/Vulnerability.ts",
      "functions": [
        "applyVulnerability(target, stacks?, nowMs?, config?)"
      ],
      "dependsOn": [
        "characters.types",
        "combat.statusEffects"
      ],
      "notes": [
        "Defines a generic incoming-damage debuff effect ('Exposed Weakness').",
        "Applies a StatusEffect that increases damageTakenPct per stack, up to a maxStacks cap.",
        "Intended to be used by spells, abilities, and NPC AI for 'take more damage' mechanics."
      ]
    },
    "config.logconfig": {
      "kind": "config",
      "path": "worldcore/config/logconfig.ts",
      "functions": [
        "logEnabled"
      ],
      "notes": [
        "Log-level resolution for scoped loggers with global and per-scope env overrides.",
        "Used by Logger to decide if a given scope+level should emit output."
      ]
    },
    "config.runtime": {
      "kind": "config",
      "path": "worldcore/config/config.ts",
      "notes": [
        "Runtime server config: WS_HOST, WS_PORT, heartbeat interval and timeout.",
        "Values are derived from PW_WS_HOST and PW_WS_PORT env vars with safe defaults."
      ]
    },
    "config.shardConfig": {
      "kind": "config",
      "path": "worldcore/config/ShardConfig.ts",
      "notes": [
        "Shard-wide mode flag: 'dev' or 'live', driven by PW_SHARD_MODE env variable.",
        "Referenced by systems like item grant rules to gate dev-only behavior."
      ]
    },
    "config.worldscale": {
      "kind": "config",
      "path": "worldcore/config/worldscale.ts",
      "functions": [
        "getWorldScale"
      ],
      "notes": [
        "Defines dev_tiny, dev_medium, and live_prime world scales plus WORLD_SCALES registry.",
        "DEFAULT_WORLD_SCALE_ID is driven by PW_WORLD_SCALE; getWorldScale() returns the requested or default shard scale definition for worldgen, movement, and macro war sims."
      ]
    },
    "core.combat": {
      "kind": "engine",
      "path": "worldcore/core/CombatSystem.ts",
      "class": "CombatSystem",
      "lifecycle": "singleton",
      "ctorArgs": [
        "core.entities",
        "core.rooms",
        "core.sessions"
      ],
      "dependsOn": [
        "core.entities",
        "core.rooms",
        "core.sessions"
      ],
      "facade": "CombatFacade",
      "provides": [
        "setTarget(session, targetId?)",
        "handleCast(session, payload)"
      ],
      "eventsEmitted": [
        "target_set",
        "ability_cast"
      ],
      "notes": [
        "v1 safe stub: no real damage or aggro yet.",
        "Stashes targetId on player entity.",
        "Broadcasts 'target_set' and 'ability_cast' events to the room."
      ]
    },
    "core.entities": {
      "kind": "service",
      "path": "worldcore/core/EntityManager.ts",
      "class": "EntityManager",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [],
      "provides": [
        "createPlayerForSession(sessionId, roomId)",
        "createNpcEntity(roomId, model)",
        "get(entityId)",
        "getEntitiesInRoom(roomId)",
        "getEntityByOwner(sessionId)",
        "getAll()",
        "removeEntity(entityId)",
        "setPosition(entityId, x, y, z)"
      ],
      "notes": [
        "Single source of truth for all Entity records.",
        "Enforces one 'player' entity per session.",
        "NPCs are simple entities with type 'npc' and model."
      ]
    },
    "core.heartbeat": {
      "kind": "loop",
      "path": "worldcore/core/Heartbeat.ts",
      "function": "startHeartbeat",
      "lifecycle": "timer",
      "ctorArgs": [
        "core.sessions",
        "core.rooms",
        "config.heartbeat"
      ],
      "dependsOn": [
        "core.sessions",
        "core.rooms"
      ],
      "provides": [
        "startHeartbeat(sessions, rooms, cfg) -> NodeJS.Timeout"
      ],
      "notes": [
        "Periodic coarse idle session cleanup.",
        "Uses sessions.getAllSessions() and lastSeen for idle detection.",
        "Calls rooms.leaveRoom(session) before sessions.removeSession(sessionId)."
      ]
    },
    "core.movement": {
      "kind": "engine",
      "path": "worldcore/core/MovementEngine.ts",
      "class": "MovementEngine",
      "lifecycle": "singleton",
      "ctorArgs": [
        "world.manager"
      ],
      "dependsOn": [
        "world.manager"
      ],
      "facade": "MovementEngineFacade",
      "provides": [
        "applyClientMove(session, payload: ClientMovePayload) -> ResolvedMove|null"
      ],
      "notes": [
        "Validates client x/z/rotY.",
        "Samples heightmap for ground Y, keeps entity slightly above terrain.",
        "Logs when position is outside nominal world radius; world bounds enforcement is not strict yet."
      ]
    },
    "core.objectStream": {
      "kind": "service",
      "path": "worldcore/core/ObjectStream.ts",
      "class": "ObjectStream",
      "lifecycle": "singleton",
      "ctorArgs": [
        "world.manager",
        "core.sessions"
      ],
      "dependsOn": [
        "world.manager",
        "core.sessions"
      ],
      "facade": "ObjectStreamFacade",
      "provides": [
        "handleObjectRequest(session, payload)"
      ],
      "eventsEmitted": [
        "object_chunk"
      ],
      "notes": [
        "Static v1 object stream.",
        "Fetches shard blueprint via world.getShardBlueprint().",
        "Sends a single 'object_chunk' with all objects + spawns for now."
      ]
    },
    "core.rooms": {
      "kind": "service",
      "path": "worldcore/core/RoomManager.ts",
      "class": "RoomManager",
      "lifecycle": "singleton",
      "ctorArgs": [
        "core.sessions",
        "core.entities",
        "world.blueprints?"
      ],
      "dependsOn": [
        "core.sessions",
        "core.entities",
        "world.blueprints?"
      ],
      "provides": [
        "ensureRoom(roomId)",
        "get(roomId)",
        "listRooms()",
        "joinRoom(session, roomId)",
        "leaveRoom(session)"
      ],
      "notes": [
        "Creates Room instances on demand.",
        "Tracks which sessions are in which rooms.",
        "When joining a world room, fetches WorldBlueprint and sends 'world_blueprint' to that session."
      ],
      "eventsEmitted": [
        "world_blueprint",
        "room_joined",
        "room_left"
      ],
      "internalTypes": {
        "Room": {
          "path": "worldcore/core/Room.ts",
          "ctorArgs": [
            "roomId",
            "core.sessions",
            "core.entities"
          ],
          "responsibilities": [
            "Track membership for a room.",
            "Create/ensure player entity when a character joins a world room.",
            "Apply character position/name to entity before sending 'entity_list'.",
            "Broadcast chat and entity updates to members.",
            "Distinguish 'UI rooms' (lobby/auth/select_character) from world rooms."
          ],
          "eventsEmitted": [
            "entity_list",
            "chat",
            "entity_update",
            "ability_cast",
            "target_set"
          ]
        }
      }
    },
    "core.router": {
      "kind": "gateway",
      "path": "worldcore/core/MessageRouter.ts",
      "class": "MessageRouter",
      "lifecycle": "singleton",
      "ctorArgs": [
        "core.sessions",
        "core.rooms",
        "core.entities",
        "core.movement?",
        "core.combat?",
        "core.objectStream?",
        "core.terrainStream?",
        "world.manager?",
        "guilds.service",
        "world.characters?",
        "world.items?",
        "world.npcs?",
        "world.mail?",
        "world.trades?",
        "world.vendors?",
        "world.bank?",
        "world.auctions?"
      ],
      "dependsOn": [
        "core.sessions",
        "core.rooms",
        "core.entities",
        "core.movement?",
        "core.combat?",
        "core.objectStream?",
        "core.terrainStream?",
        "world.manager?",
        "guilds.service",
        "world.characters?",
        "world.items?",
        "world.npcs?",
        "world.mail?",
        "world.trades?",
        "world.vendors?",
        "world.bank?",
        "world.auctions?",
        "world.RegionFlags",
        "db.Database"
      ],
      "handlesClientOps": [
        "ping / hello / heartbeat",
        "join_room / leave_room / list_rooms",
        "object_request",
        "terrain_request / terrain (envelope)",
        "move / walk / go",
        "action (attack, harvest)",
        "set_target / cast",
        "chat",
        "whereami",
        "mud",
        "gchat"
      ],
      "notes": [
        "Main entry point for all client->world traffic.",
        "Delegates movement to MovementEngineFacade, terrain/objects to streams, combat to CombatFacade.",
        "Builds a WorldActionContext bag for performAction and MudCommandHandler.",
        "Also exposes whereami resolution (roomId, pos, regionId, shardId) using both character and entity data."
      ]
    },
    "core.sessions": {
      "kind": "service",
      "path": "worldcore/core/SessionManager.ts",
      "class": "SessionManager",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [],
      "provides": [
        "createSession(socket, displayName)",
        "get(sessionId)",
        "getAllSessions()",
        "touch(sessionId)",
        "send(session, op, payload?)",
        "broadcast(op, payload?)"
      ],
      "notes": [
        "Owns all active sessions in memory.",
        "Tracks lastSeen for heartbeat idle timeout.",
        "Defaults shardId to 'prime_shard' on createSession."
      ]
    },
    "core.terrainStream": {
      "kind": "service",
      "path": "worldcore/core/TerrainStream.ts",
      "class": "TerrainStream",
      "lifecycle": "singleton",
      "ctorArgs": [
        "world.manager",
        "core.sessions"
      ],
      "dependsOn": [
        "world.manager",
        "core.sessions"
      ],
      "facade": "TerrainStreamFacade",
      "provides": [
        "handleChunkRequest(session, payload)",
        "handleTerrainEnvelope(session, payload)"
      ],
      "eventsEmitted": [
        "terrain"
      ],
      "notes": [
        "Samples heightmap around a center (x,z) into a small grid.",
        "Returns 'terrain' messages with kind 'simple_height_patch'.",
        "Envelope handler currently logs only; reserved for future streaming ops."
      ]
    },
    "core.tickEngine": {
      "kind": "engine",
      "path": "worldcore/core/TickEngine.ts",
      "class": "TickEngine",
      "lifecycle": "singleton",
      "ctorArgs": [
        "core.entities",
        "core.rooms",
        "core.sessions",
        "world.manager",
        "config.tick",
        "world.npcs?"
      ],
      "dependsOn": [
        "core.entities",
        "core.rooms",
        "core.sessions",
        "world.manager",
        "world.npcs?"
      ],
      "provides": [
        "start()",
        "stop()"
      ],
      "notes": [
        "Fixed-interval tick loop (min 10ms).",
        "Ticks NPCs via NpcManager.updateAll each tick (if provided).",
        "Calls cfg.onTick(now, tick, deltaMs) hook for systems like SongEngine.",
        "Logs basic stats periodically.",
        "Ticks NPC status effects + DOT damage each tick (best-effort), skipping dead NPCs/corpses."
      ]
    },
    "dev.hotReloadService": {
      "kind": "service",
      "path": "worldcore/dev/HotReloadService.ts",
      "functions": [
        "parseHotReloadTargets(args:string[]):HotReloadTarget[]",
        "runHotReload(targets:HotReloadTarget[], deps:HotReloadDeps):Promise<HotReloadReport>",
        "formatHotReloadReport(r:HotReloadReport):string"
      ],
      "dependsOn": [
        "utils.logger",
        "items.service?",
        "quests.registry?",
        "npc.types?",
        "world.spawnPointCache?",
        "world.spawnHydrator?",
        "world.spawnPoints?"
      ],
      "notes": [
        "Central hot-reload coordinator used by the MUD 'reload' command.",
        "Supports targets: all/items/quests/npcs/spawns.",
        "Items reload prefers ItemService.reload() then falls back to loadAll().",
        "Quests reload pushes definitions into QuestRegistry via setQuestDefinitions().",
        "NPC reload pushes prototypes into NpcTypes via setNpcPrototypes().",
        "Spawns reload clears SpawnPointCache (best-effort dynamic import), optionally clears SpawnPointService caches (duck-typed), and invalidates SpawnHydrator hydration cache when present."
      ]
    },
    "infra.schema.030_trade_recipes": {
      "kind": "service",
      "path": "worldcore/infra/schema/030_trade_recipes.sql",
      "class": "SchemaMigration",
      "lifecycle": "migration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "provides": [
        "trade_recipes table",
        "trade_recipe_inputs table",
        "trade_recipe_outputs table"
      ],
      "owns": [
        "DB schema for DB-backed tradeskill recipes",
        "FK constraints into items(id)",
        "Indexes for recipe category lookups"
      ],
      "notes": [
        "Tradeskills v1: introduces DB-backed recipes as authoritative content source.",
        "Inputs/outputs stored as separate tables for easy extension (stations, skill reqs, tools)."
      ]
    },
    "infra.schema.033_trade_recipes_station_kind": {
      "kind": "service",
      "path": "worldcore/infra/schema/033_trade_recipes_station_kind.sql",
      "class": "SchemaMigration",
      "lifecycle": "migration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.030_trade_recipes"
      ],
      "provides": [
        "trade_recipes.station_kind",
        "idx_trade_recipes_station_kind"
      ],
      "owns": [
        "Crafting station requirement schema for trade recipes"
      ],
      "notes": [
        "Nullable station_kind enables Crafting Stations v0 without breaking existing recipes.",
        "Enforcement is handled in craftCommand behind PW_CRAFT_STATIONS_REQUIRED=1."
      ]
    },
    "infra.schema.035_skin_loot_v1": {
      "kind": "schema",
      "service": "infra",
      "path": "worldcore/infra/schema/035_skin_loot_v1.sql",
      "class": "(sql)",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.007_items"
      ],
      "provides": [
        "skin_loot table for DB-backed skinning loot profiles (proto and/or tag targeting)"
      ],
      "owns": []
    },
    "infra.schema.036_seed_skin_loot_v1": {
      "kind": "schema_seed",
      "service": "infra",
      "path": "worldcore/infra/schema/036_seed_skin_loot_v1.sql",
      "class": "(sql)",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.035_skin_loot_v1"
      ],
      "provides": [
        "minimal beast/critter starter skin loot rows (hide_scraps)"
      ],
      "owns": []
    },
    "infra.seed.031_trade_recipes_v1": {
      "kind": "service",
      "path": "worldcore/infra/schema/031_seed_trade_recipes_v1.sql",
      "class": "SeedMigration",
      "lifecycle": "migration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.030_trade_recipes",
        "infra.schema.007_items",
        "worldcore/db/Database.ts"
      ],
      "provides": [
        "smelt_iron_ingot recipe (DB)",
        "brew_minor_heal recipe (DB)"
      ],
      "owns": [
        "Baseline recipe seeds using UPSERT",
        "Inputs/outputs rows for each seeded recipe"
      ],
      "notes": [
        "Tradeskills v1 baseline DB recipes.",
        "Safe to re-run; uses ON CONFLICT UPSERT patterns."
      ]
    },
    "infra.seed.032_trade_recipes_cooking_v1": {
      "kind": "service",
      "path": "worldcore/infra/schema/032_seed_trade_recipes_cooking_v1.sql",
      "class": "SeedMigration",
      "lifecycle": "migration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.030_trade_recipes",
        "infra.schema.007_items",
        "worldcore/db/Database.ts"
      ],
      "provides": [
        "cook_river_trout (DB recipe seed)",
        "mill_wheat_flour (DB recipe seed)",
        "bake_simple_bread (DB recipe seed)"
      ],
      "owns": [
        "Starter cooking recipe seeds (UPSERT)",
        "Deterministic inputs/outputs replacement per recipe"
      ],
      "notes": [
        "Migrates RecipeCatalog cooking recipes into DB so crafting is DB-authoritative.",
        "Safe to re-run."
      ]
    },
    "infra.seed.034_trade_recipes_station_kinds_v1": {
      "kind": "service",
      "path": "worldcore/infra/schema/034_seed_trade_recipes_station_kinds_v1.sql",
      "class": "SeedMigration",
      "lifecycle": "migration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.033_trade_recipes_station_kind"
      ],
      "provides": [
        "Starter recipe station_kind assignments"
      ],
      "owns": [
        "Station policy for starter recipes: campfire portable; forge/alchemy_table/millstone/oven town-only"
      ]
    },
    "interaction.ops": {
      "kind": "service",
      "path": "worldcore/interaction/interactOps.ts",
      "functions": [
        "interactInRoom"
      ],
      "dependsOn": [
        "targeting.finders"
      ],
      "notes": [
        "Handles 'interact <what>' / 'use <what>' style interactions in the current room.",
        "Resolves NPC target by name and returns flavored text, with optional quest-log-based hints."
      ]
    },
    "items.catalog": {
      "kind": "model",
      "path": "worldcore/items/ItemCatalog.ts",
      "functions": [
        "getItemTemplate",
        "listAllItems"
      ],
      "dependsOn": [
        "items.types"
      ],
      "notes": [
        "Static built-in item templates for starter gear, rat loot, and basic ore (plus a minimal instrument item for Virtuoso testing).",
        "Used as a fallback when DB-backed items are missing (e.g., debug_give and early/dev-only items).",
        "Convention: gear stats may include instrumentPct and instrumentPctBySchool for song scaling."
      ]
    },
    "items.config": {
      "kind": "config",
      "path": "worldcore/items/ItemConfig.ts",
      "notes": [
        "Item-related runtime config; currently defines defaultOverflowPolicy used by ItemService."
      ]
    },
    "items.display": {
      "kind": "service",
      "path": "worldcore/items/ItemDisplay.ts",
      "functions": [
        "formatItemLabel",
        "formatItemDefinition",
        "formatItemTemplate",
        "getItemRarityColorCode",
        "getItemTooltip"
      ],
      "dependsOn": [
        "items.service",
        "items.catalog",
        "items.types",
        "utils.colors"
      ],
      "notes": [
        "Builds human-readable labels and tooltips from DB-backed items or static templates.",
        "Maps item rarity to ANSI color codes for console output."
      ]
    },
    "items.economy": {
      "kind": "service",
      "path": "worldcore/items/ItemEconomy.ts",
      "functions": [
        "getItemSellValue"
      ],
      "dependsOn": [
        "items.catalog"
      ],
      "notes": [
        "Computes base vendor sell value for an item in gold based on template.baseValue.",
        "Returns 0 for unsellable or unknown items."
      ]
    },
    "items.equipmentOps": {
      "kind": "service",
      "path": "worldcore/items/equipmentOps.ts",
      "functions": [
        "equipFirstMatchingFromBags",
        "unequipToBags"
      ],
      "dependsOn": [
        "utils.logger",
        "items.catalog",
        "items.inventoryHelpers",
        "mail.service",
        "characters.service?",
        "loot.OverflowDelivery"
      ],
      "notes": [
        "High-level equipment swap logic operating on character.inventory and equipment.",
        "Handles bag overflow via OverflowDelivery; refuses equip/unequip when it cannot safely deliver displaced gear (bags full and mail unavailable)."
      ]
    },
    "items.grantRules": {
      "kind": "service",
      "path": "worldcore/items/ItemGrantRules.ts",
      "functions": [
        "canGrantItemToPlayer"
      ],
      "dependsOn": [
        "auth.staffRoles",
        "config.shardConfig",
        "items.types"
      ],
      "notes": [
        "Enforces staff role and shard mode rules for granting items to players.",
        "Blocks low-ranked staff or dev-only items on live shards unless actor role is high enough."
      ]
    },
    "items.inventoryConsume": {
      "kind": "utility",
      "path": "worldcore/items/inventoryConsume.ts",
      "functions": [
        "countItemInInventory",
        "consumeItemFromInventory",
        "canConsumeRecipe",
        "consumeRecipe"
      ],
      "dependsOn": [
        "characters.types"
      ],
      "notes": [
        "Counts and consumes items in inventory across all bags.",
        "Provides helpers to check and consume crafting recipe inputs for a given count."
      ]
    },
    "items.inventoryHelpers": {
      "kind": "utility",
      "path": "worldcore/items/InventoryHelpers.ts",
      "functions": [
        "findFreeBagSlot",
        "addItemToInventory",
        "addItemToBags",
        "addCurrency",
        "getCurrency",
        "setCurrency",
        "getGold",
        "setGold"
      ],
      "dependsOn": [
        "characters.types"
      ],
      "notes": [
        "Core bag and currency helpers operating on InventoryState.",
        "addItemToBags performs stack-aware item addition; addItemToInventory is a deprecated simple helper."
      ]
    },
    "items.inventoryRemove": {
      "kind": "utility",
      "path": "worldcore/items/InventoryRemove.ts",
      "functions": [
        "removeItemFromBags"
      ],
      "dependsOn": [
        "characters.types"
      ],
      "notes": [
        "Removes up to a given quantity of an item from all bags in-place.",
        "Returns how many were removed vs leftover."
      ]
    },
    "items.inventoryTest": {
      "kind": "dev_script",
      "path": "worldcore/items/InventoryTest.ts",
      "notes": [
        "Standalone Node script to sanity-check ItemService + inventory add/remove behavior.",
        "Uses defaultInventory(), adds huge stacks, then removes items and logs bag state."
      ]
    },
    "items.inventoryView": {
      "kind": "service",
      "path": "worldcore/items/inventoryView.ts",
      "functions": [
        "buildInventoryLines"
      ],
      "dependsOn": [
        "items.display"
      ],
      "notes": [
        "Builds text lines describing currency and bag contents using formatted item labels.",
        "Used by the 'inventory' command to render a readable inventory view."
      ]
    },
    "items.overflowPolicy": {
      "kind": "types",
      "path": "worldcore/items/OverflowPolicy.ts",
      "notes": [
        "String union type for overflow behavior: 'drop', 'destroy', or 'mail'.",
        "Used by ItemService.addToInventory to decide how to handle leftover quantities."
      ]
    },
    "items.resolve": {
      "kind": "service",
      "path": "worldcore/items/resolveItem.ts",
      "functions": [
        "resolveItem"
      ],
      "dependsOn": [
        "items.service",
        "items.catalog",
        "items.types"
      ],
      "notes": [
        "Resolves an itemId to a runtime template using DB-backed ItemService first, then static ItemCatalog.",
        "Normalizes category/baseValue fields when pulling from DB."
      ]
    },
    "items.resolvedItem": {
      "kind": "model",
      "path": "worldcore/items/ResolvedItem.ts",
      "notes": [
        "Unified runtime item type combining DB-backed definitions and static templates.",
        "Suitable for inventories, loot drops, and gameplay without caring about source."
      ]
    },
    "items.service": {
      "kind": "service",
      "path": "worldcore/items/ItemService.ts",
      "class": "ItemService",
      "functions": [
        "loadAll",
        "ensureLoaded",
        "get",
        "has",
        "findByIdOrName",
        "listAll",
        "listByCategory",
        "addToInventory",
        "removeFromInventory"
      ],
      "dependsOn": [
        "db.main",
        "utils.logger",
        "items.types",
        "characters.types",
        "items.inventoryHelpers",
        "items.inventoryRemove",
        "items.config",
        "items.overflowPolicy"
      ],
      "notes": [
        "Postgres-backed item definition cache and inventory mutation helper.",
        "Adds items with stack logic and handles overflow via destroy/mail/drop policies."
      ]
    },
    "items.types": {
      "kind": "model",
      "path": "worldcore/items/ItemTypes.ts",
      "functions": [
        "rowToItemDefinition"
      ],
      "notes": [
        "Defines ItemTemplate, ItemDefinition, ItemRow, ItemRarity, and EQUIP_SLOTS/EquipSlot.",
        "rowToItemDefinition converts Postgres rows into runtime ItemDefinition objects."
      ]
    },
    "loot.OverflowDelivery": {
      "kind": "helper",
      "path": "worldcore/loot/OverflowDelivery.ts",
      "functions": [
        "deliverItemToBagsOrMail",
        "deliverItemsToBagsOrMail"
      ],
      "notes": [
        "Central overflow delivery policy: bags-first, overflow-to-mail.",
        "Supports attachment meta + undeliveredPolicy ('drop'|'keep')",
        "Accepts a minimal mail sender surface (sendSystemMail) to support lightweight contexts (e.g., EquipContext)."
      ]
    },
    "loot.text": {
      "kind": "service",
      "path": "worldcore/loot/lootText.ts",
      "functions": [
        "describeLootLine"
      ],
      "notes": [
        "Formats a single loot line like '2x Rat Tail' or 'Rat Tail' based on quantity and optional display name.",
        "Clamps qty to >= 0 and falls back to the itemId when itemName is not provided."
      ]
    },
    "mail.postgres": {
      "kind": "service",
      "path": "worldcore/mail/PostgresMailService.ts",
      "class": "PostgresMailService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "mail.types",
        "mail.service",
        "economy.helpers"
      ],
      "notes": [
        "Postgres-backed implementation of MailService using mailboxes, mails, and mail_items tables.",
        "Supports system mail with JSONB metadata and attachment claiming via giveItemsToCharacter."
      ]
    },
    "mail.service": {
      "kind": "service_contract",
      "path": "worldcore/mail/MailService.ts",
      "notes": [
        "MailService interface: getOrCreateMailbox, listMail, getMail, markRead, sendSystemMail, claimAttachments.",
        "claimAttachments uses ItemService.addToInventory; leftover can be handled by caller (or mailed via OverflowDelivery when appropriate)."
      ]
    },
    "mail.types": {
      "kind": "model",
      "path": "worldcore/mail/MailTypes.ts",
      "notes": [
        "Defines MailOwnerKind ('account'|'character'), MailAttachment, MailSummary, and MailDetail.",
        "MailSummary carries read/hasAttachments flags; MailDetail adds body and attachments."
      ]
    },
    "movement.commands": {
      "kind": "service",
      "path": "worldcore/movement/MovementCommands.ts",
      "functions": [
        "parseMoveDir",
        "tryMoveCharacter"
      ],
      "dependsOn": [
        "world.manager"
      ],
      "notes": [
        "Parses movement directions like 'n', 'north', 'sw', 'southwest' into MoveDir.",
        "tryMoveCharacter applies server-authoritative X/Z movement and rejects steps that leave the world/region."
      ]
    },
    "movement.ops": {
      "kind": "service",
      "path": "worldcore/movement/moveOps.ts",
      "functions": [
        "moveCharacterAndSync"
      ],
      "dependsOn": [
        "movement.commands",
        "utils.logger",
        "core.entities",
        "characters.service?"
      ],
      "notes": [
        "High-level movement op that calls tryMoveCharacter, syncs the entity position, and best-effort persists the character position.",
        "Uses a MoveOpsContext with session/entities/characters to avoid hard coupling to full services."
      ]
    },
    "mud.abilities": {
      "kind": "service",
      "path": "worldcore/mud/MudAbilities.ts",
      "lifecycle": "stateless",
      "dependsOn": [
        "mud.context",
        "abilities.table",
        "resources.power",
        "combat.cooldowns",
        "mud.actions.combat"
      ],
      "provides": [
        "handleAbilityCommand(ctx:MudContext, char:CharacterState, abilityName:string, targetName?:string):Promise<string>",
        "listKnownAbilitiesForChar(char:CharacterState):AbilityDefinition[]"
      ],
      "notes": [
        "Implements 'abilities' and 'ability <name> [target]'.",
        "Gates by class/level/cooldown/resource, then delegates actual damage to performNpcAttack."
      ]
    },
    "mud.actions": {
      "kind": "facade",
      "path": "worldcore/mud/MudActions.ts",
      "dependsOn": [
        "mud.actions.combat",
        "mud.actions.recovery",
        "mud.actions.world"
      ],
      "notes": [
        "Re-export hub for MUD actions.",
        "Older imports from '../MudActions' stay valid while we refactor call sites."
      ]
    },
    "mud.actions.combat": {
      "kind": "service",
      "path": "worldcore/mud/actions/MudCombatActions.ts",
      "lifecycle": "stateless",
      "dependsOn": [
        "mud.context",
        "combat.npc",
        "mud.trainingDummy",
        "mud.progressionHooks",
        "progression.core",
        "combat.damagePolicy"
      ],
      "provides": [
        "performNpcAttack(ctx, char, selfEntity, npc, opts?):Promise<string>",
        "scheduleNpcCorpseAndRespawn(ctx, npcEntityId):void",
        "announceSpawnToRoom(ctx, roomId, text):void",
        "handleAttackAction(ctx, char, targetNameRaw):Promise<string>"
      ],
      "notes": [
        "Preferred combat action module for 'attack' and shared action pipeline.",
        "Thin wrapper over shared NpcCombat module plus training dummy integration."
      ]
    },
    "mud.actions.legacy": {
      "kind": "legacy_service",
      "path": "worldcore/mud/MudActions.ts",
      "lifecycle": "stateless",
      "dependsOn": [
        "mud.context",
        "core.entities",
        "core.rooms",
        "world.manager",
        "world.npcs?",
        "items.service?",
        "progression.core",
        "mud.progressionHooks",
        "mud.trainingDummy",
        "resources.power?",
        "skills.progression?",
        "world.respawns?"
      ],
      "provides": [
        "performNpcAttack(ctx, char, selfEntity, npc, opts?)",
        "handleAttackAction(ctx, char, targetNameRaw)",
        "handleGatherAction(ctx, char, targetNameRaw, gatheringKind, resourceTag)",
        "scheduleNpcCorpseAndRespawn(ctx, npcEntityId)",
        "announceSpawnToRoom(ctx, roomId, text)"
      ],
      "notes": [
        "Older monolithic MUD action set; being replaced by mud.actions.combat and mud.actions.world.",
        "Still referenced by some modules; refactor target once new actions are fully wired."
      ]
    },
    "mud.actions.recovery": {
      "kind": "service",
      "path": "worldcore/mud/actions/MudRecoveryActions.ts",
      "lifecycle": "stateless",
      "dependsOn": [],
      "provides": [],
      "notes": [
        "Reserved for future rest/sleep/recovery commands; currently an empty module."
      ]
    },
    "mud.actions.world": {
      "kind": "service",
      "path": "worldcore/mud/actions/MudWorldActions.ts",
      "lifecycle": "stateless",
      "dependsOn": [
        "mud.context",
        "world.npcs",
        "core.entities",
        "world.manager",
        "items.service?",
        "progression.core",
        "mud.progressionHooks"
      ],
      "provides": [
        "handleGatherAction(ctx, char, targetNameRaw, gatheringKind, resourceTag):Promise<string>",
        "applyFallbackSkinLoot(protoId): { itemId, minQty, maxQty } | null"
      ],
      "notes": [
        "Implements 'harvest' actions (mining/herbalism/etc.).",
        "Handles node validation, loot rolls, depletion timestamps, and node/NPC despawn.",
        "Includes skinning fallback helper used by tests; real skinning loot will become DB-driven.",
        "Safety: harvest progression reactions are guarded (applyProgressionForEvent wrapped in try/catch) so gathering never hard-fails."
      ]
    },
    "mud.autoattack": {
      "kind": "service",
      "path": "worldcore/mud/commands/combat/autoattack/trainingDummyAutoAttack.ts",
      "functions": [
        "startTrainingDummyAutoAttack",
        "stopAutoAttack"
      ],
      "dependsOn": [
        "mud.context",
        "core.sessions",
        "core.entities",
        "characters.stats",
        "combat.entityCombat",
        "utils.logger"
      ],
      "notes": [
        "Manages per-session autoattack timers and interactions with the Training Dummy.",
        "Uses character effective attributes and entity health to simulate periodic swings."
      ]
    },
    "mud.combatGates": {
      "kind": "utility",
      "path": "worldcore/mud/MudCombatGates.ts",
      "lifecycle": "stateless",
      "dependsOn": [
        "pvp.duels",
        "pvp.rules",
        "world.regionFlags"
      ],
      "functions": [
        "gatePlayerDamageFromPlayerEntity(ctx:MudContext, attackerChar:CharacterState, roomId:string, playerTargetEntity:any):Promise<PlayerDamageGateResult>"
      ],
      "notes": [
        "Centralized PvP/duel gating for MUD entrypoints (attack, cast, etc.).",
        "Ticks DuelService time, checks region PvP enablement, then delegates final policy to canDamagePlayer."
      ]
    },
    "mud.commands.bank": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/bankCommand.ts",
      "function": "handleBankCommand",
      "dependsOn": [
        "mud.context",
        "bank.ops",
        "items.service",
        "core.sessions?"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Front-end for banking operations (deposit/withdraw/etc.).",
        "Chooses owner as account vs character based on session identity."
      ]
    },
    "mud.commands.combat.ability": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/combat/abilityCommand.ts",
      "function": "handleAbilityMudCommand",
      "dependsOn": [
        "mud.context",
        "mud.abilities",
        "mud.handles.nearbyHandles"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'ability <name> [target]'.",
        "Delegates validation and execution to MudAbilities.handleAbilityCommand."
      ]
    },
    "mud.commands.combat.attack": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/combat/attackCommand.ts",
      "function": "handleAttackCommand",
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.combat"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'attack <target>'.",
        "Parses targetNameRaw and routes to handleAttackAction."
      ]
    },
    "mud.commands.combat.autoattack": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/combat/autoAttackCommand.ts",
      "function": "handleAutoAttackCommand",
      "dependsOn": [
        "mud.context",
        "mud.autoattack",
        "mud.trainingDummy"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'autoattack [on|off]'.",
        "Looks up TrainingDummyDeps from input.services.trainingDummy and toggles autoattack on/off."
      ]
    },
    "mud.commands.combat.cast": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/combat/castCommand.ts",
      "function": "handleCastMudCommand",
      "dependsOn": [
        "mud.context",
        "mud.spells"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'cast <name> [target]'.",
        "Delegates to MudSpells.handleCastCommand for spell gating + effects."
      ]
    },
    "mud.commands.craft": {
      "kind": "mud_command",
      "service": "mud.commands",
      "path": "worldcore/mud/commands/craftCommand.ts",
      "class": null,
      "lifecycle": "pure",
      "ctorArgs": [],
      "dependsOn": [
        "tradeskills.tradeRecipeService",
        "items.inventoryHelpers",
        "items.inventoryConsume",
        "mud.progression",
        "core.entityManager",
        "loot.OverflowDelivery"
      ],
      "provides": [
        "mud.command.craft"
      ],
      "owns": [],
      "notes": [
        "Implements 'craft list' and 'craft <id|name> [count]'.",
        "DB-backed recipes (TradeRecipeService) with fallback to RecipeCatalog.",
        "Optional station enforcement via PW_CRAFT_STATIONS_REQUIRED=1.",
        "Station proximity currently checks entities in the room."
      ]
    },
    "mud.commands.debug.handlers": {
      "kind": "mud_command_group",
      "path": "worldcore/mud/commands/debug/handlers.ts",
      "functions": [
        "handleDebugGive",
        "handleDebugXp",
        "handleDebugSpawnNpc",
        "handleDebugSpawnRat",
        "handleDebugSpawnOre",
        "handleDebugSpawnsHere",
        "handleEventGiveAny",
        "handleEventMailReward",
        "handleDebugGiveMat",
        "handleDebugResetLevel",
        "handleDebugHurt",
        "handleDebugHydrateHere"
      ],
      "dependsOn": [
        "mud.context",
        "utils.logger",
        "auth.staffAudit",
        "auth.staffRole",
        "auth.debugGate?",
        "items.service",
        "characters.service",
        "mail.service",
        "npc.service",
        "npc.types",
        "npc.spawnController",
        "world.spawnPoints",
        "core.entities",
        "combat.entityCombat",
        "ai.npc.localBrain",
        "world.spawns",
        "db.Database",
        "world.RegionFlags",
        "loot.OverflowDelivery"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Collection of staff/debug/event commands (debug_give, debug_xp, debug_spawn_npc, event_give_any, etc.).",
        "Many of these should be wrapped with withDebugGate before being exposed to normal command routing.",
        "Includes debug_hydrate_here to force region hydration from spawn_points for the current room.",
        "Item grant commands (debug_give/event_give_any/debug_give_mat...) route through OverflowDelivery (bags-first, overflow-to-mail).",
        "Item grants resolve DB items first, then fall back to ItemCatalog when an item is not present in the DB (dev convenience).",
        "event_mail_reward sends explicit system mail (mail as feature)."
      ]
    },
    "mud.commands.debug.debugEffectsCommand": {
      "kind": "mud_command_group",
      "path": "worldcore/mud/commands/debug/debugEffectsCommand.ts",
      "functions": [
        "handleDebugEffects"
      ],
      "invokedBy": [
        "mud.commands.debug.debug_effects (via mud/commands/registry.ts)"
      ],
      "dependsOn": [
        "mud.context",
        "combat.statusEffects",
        "mud.handles.nearbyHandles"
      ],
      "notes": [
        "Debug QoL: inspect active effects + (if available) computed combat snapshot for a target (entity id or nearby handle)."
      ]
    },
    "mud.commands.debug.hydrateHere": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/debug/hydrateHere.ts",
      "function": "handleDebugHydrateHere",
      "dependsOn": [
        "auth.debugGate?",
        "mud.commands.debug.withDebugGate",
        "world.spawnPoints",
        "world.spawns",
        "npc.spawnController",
        "core.entities",
        "core.rooms"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.debug.handlers"
      ],
      "notes": [
        "Implements 'debug_hydrate_here' (staff/dev) to force spawn hydration for the current room/region.",
        "Used to re-run spawn_points-based hydration after moving around without requiring reconnect.",
        "Should remain behind withDebugGate in production."
      ]
    },
    "mud.commands.debug.regionDanger": {
      "kind": "mud_command_group",
      "path": "worldcore/mud/commands/debug/regionDangerCommands.ts",
      "functions": [
        "handleDebugRegionDanger",
        "handleDebugBumpRegionDanger"
      ],
      "dependsOn": [
        "mud.context",
        "world.regionDanger",
        "characters.types"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'debug_region_danger [regionId]' for inspecting base tier, current score, sources, and lastUpdated.",
        "Implements 'debug_bump_region_danger <amount> [regionId]' for manually bumping danger score during testing.",
        "Commands are wrapped with withDebugGate in registry.ts and only exposed to dev-level accounts."
      ]
    },
    "mud.commands.debug.reload": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/debug/reloadCommand.ts",
      "function": "handleReloadCommand",
      "dependsOn": [
        "dev.hotReloadService",
        "world.spawnHydrator?",
        "npc.spawnController?",
        "world.spawnPoints?",
        "core.entities?",
        "npc.service?"
      ],
      "invokedBy": [
        "mud.commands.registry",
        "mud.handler"
      ],
      "notes": [
        "Plain reload spawns (no flags) also reconciles personal nodes for the current session + region (despawn stale/moved, respawn from DB).",
        "--here/--region must not touch personal nodes/resources (NPC reconcile only).",
        "Suggested updated note bullets (copy/paste into that entry):",
        "On reload spawns, clears spawn caches and forces SpawnHydrator.rehydrateRoom(force=true) for the current room/region so POIs update immediately.",
        "On plain reload spawns (no flags), also live-reconciles personal nodes/resources for the current session + region (despawn stale/moved spawnPointId entities, respawn from DB) so placement edits apply without reconnect.",
        "--here[=radius] and --region reconcile shared NPC spawn_points only (spawnPointId present, no ownerSessionId); personal nodes/resources remain untouched by these flags."
      ]
    },
    "mud.commands.debug.vulnerability": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/debug/vulnerabilityCommands.ts",
      "function": "handleDebugVulnerability",
      "dependsOn": [
        "mud.context",
        "combat.vulnerability",
        "characters.types"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'debug_vuln [stacks]' for applying Exposed Weakness to the calling character.",
        "Useful for manually testing vulnerability stacking and damageTakenPct behavior via 'effects' and 'debug_hurt'."
      ]
    },
    "mud.commands.debug.withDebugGate": {
      "kind": "utility",
      "path": "worldcore/mud/commands/debug/withDebugGate.ts",
      "function": "withDebugGate",
      "dependsOn": [
        "auth.debugGate"
      ],
      "notes": [
        "Higher-order helper that wraps a debug handler and enforces requireDebug(ctx, minRole).",
        "Defaults to minRole='dev'; returns a handler with the same (ctx,char,input) signature."
      ]
    },
    "mud.commands.economy.auction": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/economy/auctionCommand.ts",
      "function": "handleAuctionCommand",
      "dependsOn": [
        "mud.context",
        "auction.service",
        "items.service",
        "characters.service",
        "mail.service",
        "economy.gold",
        "auction.auditLog",
        "auction.format",
        "loot.OverflowDelivery"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'ah' / auction house commands: browse, sell, buy, my, claim, cancel, expire, reclaim.",
        "Handles bag removal, proceeds claim, and overflow via mail.",
        "Uses system mail for auction lifecycle delivery (preferred); overflow policy is separate (OverflowDelivery) for non-auction sources."
      ]
    },
    "mud.commands.economy.trade": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/economy/tradeCommand.ts",
      "function": "handleTradeCommand",
      "dependsOn": [
        "mud.context",
        "trade.service",
        "economy.gold",
        "core.sessions",
        "mud.sessions.lookup"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'trade' flow: with/start, show/status, additem, addgold, clear, confirm, cancel.",
        "Uses tradeOps.finalizeTrade and sessionLookup helpers to find other player sessions."
      ]
    },
    "mud.commands.economy.vendor": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/economy/vendorCommand.ts",
      "function": "handleVendorCommand",
      "dependsOn": [
        "mud.context",
        "vendor.service",
        "items.service",
        "characters.service",
        "mail.service",
        "economy.gold",
        "loot.OverflowDelivery",
        "mud.commands.world.serviceGates",
        "mud.handles.nearbyHandles"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "DB-backed vendor command layer (v0). DB vendor 'id' is authoritative; names/handles are display-only.",
        "Commands: vendor help | vendors | list [vendorId|handle] | buy [vendorId|handle] <index|rowId> [qty] | sell [vendorId|handle] <itemId|index|rowId> [qty].",
        "Quality-of-life: you can omit vendorId to infer the nearest vendor anchor in the current room; you can also pass an entity handle (e.g. alchemist.1).",
        "Proximity gated via requireTownService(ctx, char, 'vendor', ...) to prevent remote shopping; use walkto vendor to get into range.",
        "Buy/sell delegates to VendorTransactions; handles inventory overflow via system mail / OverflowDelivery policies."
      ]
    },
    "mud.commands.gathering.farming": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/gathering/farmingCommand.ts",
      "function": "handleFarmingCommand",
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'farm <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, farming, resource_grain).",
        "Enforces farming only works on resource_grain nodes (no cross-tool gathering)."
      ]
    },
    "mud.commands.gathering.fishing": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/gathering/fishingCommand.ts",
      "function": "handleFishingCommand",
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'fish <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, fishing, resource_fish).",
        "Enforces fishing only works on resource_fish nodes."
      ]
    },
    "mud.commands.gathering.lumbering": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/gathering/lumberingCommand.ts",
      "function": "handleLumberingCommand",
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'lumber <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, 'lumber', 'resource_wood').",
        "Enforces lumbering only works on resource_wood nodes (no cross-tool gathering)."
      ]
    },
    "mud.commands.gathering.mining": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/gathering/miningCommand.ts",
      "function": "handleMiningCommand",
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'mine <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, 'mining', 'resource_ore').",
        "Enforces mining only works on resource_ore nodes (no cross-tool gathering)."
      ]
    },
    "mud.commands.gathering.picking": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/gathering/pickingCommand.ts",
      "function": "handlePickingCommand",
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'pick <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, 'herbalism', 'resource_herb').",
        "Enforces picking only works on resource_herb nodes (no cross-tool gathering)."
      ]
    },
    "mud.commands.gathering.quarrying": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/gathering/quarryingCommand.ts",
      "function": "handleQuarryingCommand",
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'quarry <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, 'quarry', 'resource_stone').",
        "Enforces quarrying only works on resource_stone nodes (no cross-tool gathering)."
      ]
    },
    "mud.commands.gathering.skinning": {
      "kind": "module",
      "service": "mud",
      "path": "worldcore/mud/commands/gathering/skinningCommand.ts",
      "class": "(function) handleSkinningCommand",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [
        "combat.entityCombat",
        "combat.skinLootService",
        "mud.actions.world",
        "npc.types",
        "items.catalog",
        "items.inventory",
        "loot.OverflowDelivery",
        "mud.handles.nearbyHandles"
      ],
      "provides": [
        "skin <corpse>: validates corpse, resolves skin loot (DB-first, fallback), grants items, marks corpse skinned",
        "progression event emission + overflow-to-mail via OverflowDelivery"
      ],
      "owns": []
    },
    "mud.commands.guildBank": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/guildBankCommand.ts",
      "function": "handleGuildBankCommand",
      "dependsOn": [
        "mud.context",
        "bank.ops",
        "items.service",
        "guilds.service?"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Front-end for guild bank operations.",
        "Uses bankOps.handleBankCommand with ownerKind='guild' based on char.guildId."
      ]
    },
    "mud.commands.meta.help": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/meta/helpCommand.ts",
      "function": "handleHelpCommand",
      "dependsOn": [
        "mud.help",
        "auth.staffRole"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Emits 'Available commands' list using HELP_ENTRIES.",
        "Includes debug-only commands only if staff role is owner/dev/gm."
      ]
    },
    "mud.commands.player.abilities": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/abilitiesCommand.ts",
      "function": "handleAbilitiesCommand",
      "dependsOn": [
        "mud.abilities"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'abilities'.",
        "Lists known abilities for the current character via MudAbilities.listKnownAbilitiesForChar."
      ]
    },
    "mud.commands.player.equipment": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/equipmentCommand.ts",
      "functions": [
        "handleEquipCommand",
        "handleUnequipCommand"
      ],
      "dependsOn": [
        "items.equipmentOps",
        "mud.context"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'equip <slot>' and 'unequip <slot>'.",
        "Uses equipFirstMatchingFromBags and unequipToBags."
      ]
    },
    "mud.commands.player.inventory": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/inventoryCommand.ts",
      "function": "handleInventoryCommand",
      "dependsOn": [
        "items.inventoryView",
        "mud.context"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'inventory' / 'inv'.",
        "Renders inventory using buildInventoryLines and joins lines with newlines."
      ]
    },
    "mud.commands.player.itemInfo": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/itemInfoCommand.ts",
      "function": "handleItemInfoCommand",
      "dependsOn": [
        "items.display",
        "mud.context"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'iteminfo <token>'.",
        "Uses getItemTooltip to render item label, lines, and rarity, or reports no item found."
      ]
    },
    "mud.commands.player.melody": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/melodyCommand.ts",
      "function": "handleMelodyCommand",
      "dependsOn": [
        "mud.context",
        "songs.engine",
        "spells.table"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'melody' meta-command for Virtuoso.",
        "Supports subcommands: add, remove, clear, start, stop; manages song queues via SongEngine."
      ]
    },
    "mud.commands.player.recovery": {
      "kind": "mud_command_group",
      "path": "worldcore/mud/commands/player/recoveryCommand.ts",
      "functions": [
        "handleRespawnCommand",
        "handleRestCommand"
      ],
      "dependsOn": [
        "mud.context",
        "world.respawns?",
        "core.entities",
        "systems.recovery",
        "mud.autoattack",
        "mud.trainingDummy",
        "resources.power"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'respawn' and 'rest'.",
        "Respawn uses RespawnService when available, falling back to local respawnInPlace.",
        "Rest uses recoveryOps and also restores mana/fury via PowerResources."
      ]
    },
    "mud.commands.player.resources": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/resourcesCommand.ts",
      "function": "handleResourcesCommand",
      "dependsOn": [
        "resources.power"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'resources'.",
        "Shows primary resource pool (Fury or Mana) and optional secondary pool for Adventurer."
      ]
    },
    "mud.commands.player.risk": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/riskCommand.ts",
      "function": "handleRiskCommand",
      "dependsOn": [
        "mud.context",
        "combat.cowardice?",
        "world.regionDanger"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'risk' and 'cowardice' commands.",
        "Shows cowardice stacks, tier, and net damageTakenPct from cowardice.",
        "Also shows current RegionDanger tier label and indicates that tier >= 3 applies Region Peril (+5% incoming damage)."
      ]
    },
    "mud.commands.player.skills": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/skillsCommand.ts",
      "function": "handleSkillsCommand",
      "dependsOn": [
        "mud.context",
        "skills.progression"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'skills'.",
        "Shows weapon skills, spell schools (except for pure-song classes like Virtuoso), and song schools."
      ]
    },
    "mud.commands.player.songs": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/songsCommand.ts",
      "function": "handleSongsCommand",
      "dependsOn": [
        "mud.context",
        "spells.table"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'songs'.",
        "Lists non-hidden songs (isSong=true) that match class or 'any' and are <= character level."
      ]
    },
    "mud.commands.player.spells": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/spellsCommand.ts",
      "function": "handleSpellsCommand",
      "dependsOn": [
        "mud.context",
        "spells.table"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'spells'.",
        "Lists non-song spells for the character's class (or 'any') that meet min level."
      ]
    },
    "mud.commands.player.stats": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/player/statsCommand.ts",
      "function": "handleStatsCommand",
      "dependsOn": [
        "mud.context",
        "characters.sheet",
        "mud.progression",
        "characters.titles"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'stats'.",
        "Builds character sheet line including gear and active title using buildCharacterSheetLine."
      ]
    },
    "mud.commands.progression.progress": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/progression/progressCommand.ts",
      "function": "handleProgressCommand",
      "dependsOn": [
        "progression.progressText"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'progress'.",
        "Uses renderProgressText(char) to show progression counters."
      ]
    },
    "mud.commands.progression.quests": {
      "kind": "mud_command_group",
      "path": "worldcore/mud/commands/progression/questsCommand.ts",
      "functions": [
        "handleQuestsCommand",
        "handleQuestCommand"
      ],
      "dependsOn": [
        "mud.progression",
        "quests.turnIn"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'quests' and 'quest ...' commands.",
        "Default shows quest log; subcommand 'turnin'/'turn-in'/'complete' turns in a quest by target string.",
        "Provides board/accept/abandon",
        "Help text advertises warfront-friendly turn-in: 'quest turnin list|ready' and 'quest turnin <#|id|name>'."
      ]
    },
    "mud.commands.progression.reward": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/progression/rewardCommand.ts",
      "function": "handleRewardCommand",
      "dependsOn": [
        "mud.context",
        "progression.ProgressionCore",
        "rewards.RewardDelivery",
        "characters.service"
      ],
      "invokedBy": [
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'reward list' and 'reward claim' for pendingRewards delivery."
      ]
    },
    "mud.commands.progression.titles": {
      "kind": "mud_command_group",
      "path": "worldcore/mud/commands/progression/titlesCommand.ts",
      "functions": [
        "handleTitleCommand",
        "handleTitlesCommand",
        "handleSetTitleCommand"
      ],
      "dependsOn": [
        "progression.titles.text",
        "progression.titles.setActive"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "notes": [
        "Implements 'title', 'titles', and 'settitle ...'.",
        "Renders current title, lists available titles, and sets active title based on fuzzy input."
      ]
    },
    "mud.commands.registry": {
      "kind": "registry",
      "path": "worldcore/mud/commands/registry.ts",
      "dependsOn": [
        "mud.commands.bank",
        "mud.commands.guildBank",
        "mud.commands.economy.trade",
        "mud.commands.economy.vendor",
        "mud.commands.economy.auction",
        "mud.commands.social.mail",
        "mud.commands.craft",
        "mud.commands.world.look",
        "mud.commands.world.examine",
        "mud.commands.world.inspectRegion",
        "mud.commands.world.nearby",
        "mud.commands.world.map",
        "mud.commands.world.save",
        "mud.commands.world.move",
        "mud.commands.world.walkto",
        "mud.commands.world.interact",
        "mud.commands.world.talk",
        "mud.commands.social.chat",
        "mud.commands.social.guildChat",
        "mud.commands.social.who",
        "mud.commands.meta.help",
        "mud.commands.player.inventory",
        "mud.commands.player.itemInfo",
        "mud.commands.player.equipment",
        "mud.commands.player.stats",
        "mud.commands.player.recovery",
        "mud.commands.player.resources",
        "mud.commands.player.skills",
        "mud.commands.player.melody",
        "mud.commands.player.abilities",
        "mud.commands.player.songs",
        "mud.commands.player.spells",
        "mud.commands.combat.cast",
        "mud.commands.combat.ability",
        "mud.commands.combat.attack",
        "mud.commands.combat.autoattack",
        "mud.commands.gathering.picking",
        "mud.commands.gathering.mining",
        "mud.commands.gathering.quarrying",
        "mud.commands.progression.quests",
        "mud.commands.progression.progress",
        "mud.commands.progression.titles",
        "mud.commands.debug.handlers",
        "mud.commands.debug.withDebugGate",
        "rewards.RewardDelivery"
      ],
      "notes": [
        "Maps text commands (bank, move, cast, etc.) to specific handler functions.",
        "Central router used by MudCommandHandler to dispatch player commands."
      ]
    },
    "mud.commands.sessionLookup": {
      "kind": "utility",
      "path": "worldcore/mud/commands/sessionLookup.ts",
      "functions": [
        "findSessionByCharacterNameInRoom",
        "findSessionByCharacterId"
      ],
      "dependsOn": [
        "core.sessions"
      ],
      "notes": [
        "Helpers to resolve sessions by character id or name in a room.",
        "Used by commands that need to target other players."
      ]
    },
    "mud.commands.social.chat": {
      "kind": "mud_command_group",
      "path": "worldcore/mud/commands/social/chatCommand.ts",
      "functions": [
        "handleSayCommand",
        "handleTellCommand"
      ],
      "dependsOn": [
        "mud.context",
        "core.sessions",
        "core.rooms?"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'say' and 'tell' chat commands.",
        "Broadcasts room chat via room.broadcast where possible, falls back to iterating sessions."
      ]
    },
    "mud.commands.social.guildChat": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/social/guildChatCommand.ts",
      "function": "handleGuildChatCommand",
      "dependsOn": [
        "mud.context",
        "guilds.service",
        "core.sessions"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'gchat'.",
        "Fetches guild for character, hydrates char.guildId, and broadcasts messages to all guild members online."
      ]
    },
    "mud.commands.social.mail": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/social/mailCommand.ts",
      "function": "handleMailCommand",
      "dependsOn": [
        "mail.service",
        "items.service",
        "characters.service",
        "auth.staffRole",
        "auth.staffAudit"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements player mailbox commands: mail list, mail read <id>, mail claim <id>.",
        "Also includes staff-only mail event_reward (explicit mail as a feature; not overflow policy)."
      ]
    },
    "mud.commands.social.who": {
      "kind": "mud_command_group",
      "path": "worldcore/mud/commands/social/whoCommand.ts",
      "functions": [
        "handleWhoCommand",
        "handleWhoAllCommand",
        "handleWhoIsCommand"
      ],
      "dependsOn": [
        "core.sessions",
        "world.regionText"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'who', 'whoall', and 'whois'.",
        "Lists visible players in room, all online players, or detailed info for a single character."
      ]
    },
    "mud.commands.types": {
      "kind": "types",
      "path": "worldcore/mud/commands/types.ts",
      "notes": [
        "Defines MudCommandInput, MudServices, and MudCommandHandlerFn.",
        "Used by command modules and the central registry for typing."
      ]
    },
    "mud.commands.world.examine": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/examineCommand.ts",
      "function": "handleExamineCommand",
      "dependsOn": [
        "mud.context",
        "core.entities",
        "npc.types",
        "npc.state",
        "target.finders"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'examine <target>'.",
        "Shows level, HP, and tags for NPCs/resources like ore veins and rats; falls back if nothing matches."
      ]
    },
    "mud.commands.world.examineRegion": {
      "kind": "alias",
      "path": "worldcore/mud/commands/world/inspectRegionCommand.ts",
      "notes": [
        "Alias entry kept separate in case you introduce alternate region inspection commands later."
      ]
    },
    "mud.commands.world.inspect": {
      "kind": "alias",
      "path": "worldcore/mud/commands/world/examineCommand.ts",
      "notes": [
        "Optional alias placeholder for future 'inspect' behavior."
      ]
    },
    "mud.commands.world.inspectRegion": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/inspectRegionCommand.ts",
      "function": "handleInspectRegionCommand",
      "dependsOn": [
        "world.manager",
        "world.spawnPoints"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Developer-facing region inspector (supports optional 'inspect_region <x> <z>' / comma forms).",
        "Prints region identity + sampling info when available.",
        "Also queries DB spawn_points: counts spawns in the region and near the query point (radius=10), and prints a short list."
      ]
    },
    "mud.commands.world.interact": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/interactCommand.ts",
      "function": "handleInteractCommand",
      "dependsOn": [
        "interaction.ops",
        "mud.progression"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'interact <what>' and 'use <what>'.",
        "Routes to interactInRoom with quest-log rendering for feedback."
      ]
    },
    "mud.commands.world.look": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/lookCommand.ts",
      "function": "handleLookCommand",
      "dependsOn": [
        "mud.context",
        "core.entities",
        "world.manager"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'look'.",
        "Describes current region and nearby NPCs in the same room with HP readouts."
      ]
    },
    "mud.commands.world.map": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/mapCommand.ts",
      "function": "handleMapCommand",
      "dependsOn": [
        "mud.mapRenderer",
        "world.manager"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'map [radius]'.",
        "Calls buildAsciiMap(world, char, radius) for ANSI map output."
      ]
    },
    "mud.commands.world.move": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/moveCommand.ts",
      "function": "handleMoveCommand",
      "dependsOn": [
        "movement.ops",
        "movement.commands",
        "world.manager"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'move', 'walk', and 'go'.",
        "Parses direction, calls moveCharacterAndSync, and returns movement text or failure reason."
      ]
    },
    "mud.commands.world.nearby": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/nearbyCommand.ts",
      "function": "handleNearbyCommand",
      "dependsOn": [
        "mud.context",
        "core.entities",
        "npc.spawns",
        "mud.handles.nearbyHandles"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'nearby'.",
        "Refreshes personal nodes, then lists nearby entities within radius with short handles like rat.1.",
        "filter/group/sort flags",
        "--limit / --max",
        "safe caps + \u201cUI-friendly output shaping"
      ]
    },
    "mud.commands.world.save": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/saveCommand.ts",
      "function": "handleSaveCommand",
      "dependsOn": [
        "characters.service",
        "auth.identity",
        "utils.logger"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'save'.",
        "Patch-updates the character record with position, attributes, inventory, equipment, spellbook, abilities, and progression."
      ]
    },
    "mud.commands.world.serviceGates": {
      "kind": "utility",
      "path": "worldcore/mud/commands/world/serviceGates.ts",
      "lifecycle": "stateless",
      "dependsOn": [
        "mud.context",
        "core.entities",
        "core.sessions",
        "vendor.service"
      ],
      "functions": [
        "requireTownService(ctx:MudContext, char:CharacterState, service:\"bank\"|\"guildbank\"|\"vendor\"|\"auction\"|\"mail\", run:()=>Promise<T>|T):Promise<T|string>"
      ],
      "notes": [
        "Enforces proximity gating for town services (bank/guildbank/vendor/auction/mail) when session+entities context exists.",
        "Vendor gating is always enforced when proximity can be evaluated (prevents remote shopping even if PW_SERVICE_GATES is off).",
        "Test-friendly: if proximity cannot be evaluated, the call is not blocked.",
        "Admin/dev bypass via duck-typed session.auth (roles/scopes/permissions flags).",
        "Env: PW_SERVICE_GATES (enable non-vendor gates), PW_SERVICE_RADIUS (default 2.5), PW_SERVICE_GATES_STRICT (deny if no anchor exists)."
      ]
    },
    "mud.commands.world.talk": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/talkCommand.ts",
      "function": "handleTalkCommand",
      "dependsOn": [
        "mud.context",
        "core.entities",
        "npc.types",
        "npc.state",
        "target.finders",
        "progression.core",
        "mud.progression",
        "mud.handles.nearbyHandles"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'talk <npc>'.",
        "Finds an NPC in the room, fires a talk_to progression event, runs hooks, and prints any progression snippets."
      ]
    },
    "mud.commands.world.walkto": {
      "kind": "mud_command",
      "path": "worldcore/mud/commands/world/walktoCommand.ts",
      "function": "handleWalkToCommand",
      "dependsOn": [
        "movement.ops",
        "movement.commands",
        "core.entities",
        "core.rooms",
        "world.manager"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "notes": [
        "Implements 'walkto <handle|name|service>' auto-walk with per-step delay.",
        "Supports service keywords: bank/gbank/mail/ah/vendor by walking to nearest service anchor entity.",
        "Includes persistent risk-mode + coward toggle (stored on CharacterState progression.flags) to allow walking through combat with penalties.",
        "Walk interrupted on hit unless risk, and that it mirrors flags to entity fields (_pw_walkto*)",
        "Service targeting prefers service anchors (tags/serviceKind) and avoids ambiguous numeric-name matches (e.g. 'walkto 2' accidentally hitting guard.2)."
      ]
    },
    "mud.context": {
      "kind": "model",
      "path": "worldcore/mud/MudContext.ts",
      "types": [
        "MudContext"
      ],
      "dependsOn": [
        "core.sessions",
        "guilds.service",
        "world.manager?",
        "world.characters?",
        "core.entities?",
        "core.rooms?",
        "world.npcs?",
        "world.trades?",
        "world.vendors?",
        "world.bank?",
        "world.auctions?",
        "world.mail?",
        "world.respawns?"
      ],
      "notes": [
        "Shared dependency bag for all MUD handlers (commands, actions, progression).",
        "Threaded from MessageRouter for each incoming 'mud' command."
      ]
    },
    "mud.handler": {
      "kind": "gateway",
      "path": "worldcore/mud/MudCommandHandler.ts",
      "class": "MudCommandHandler",
      "lifecycle": "stateless",
      "dependsOn": [
        "mud.context",
        "mud.map",
        "mud.abilities",
        "mud.spells",
        "mud.actions.combat",
        "mud.actions.world",
        "mud.progression",
        "mud.progressionHooks",
        "mud.help",
        "mud.presence",
        "core.sessions",
        "core.rooms",
        "world.manager?",
        "world.query?",
        "world.events?"
      ],
      "handlesCommandsFromHelp": true,
      "notes": [
        "Parses MUD command lines and routes them to the appropriate action/utility.",
        "Commands roughly correspond 1:1 to HELP_ENTRIES in MudHelpMenu.ts."
      ]
    },
    "mud.handles.nearbyHandles": {
      "kind": "utility",
      "path": "worldcore/mud/handles/NearbyHandles.ts",
      "functions": [
        "distanceXZ",
        "getEntityXZ",
        "isDeadNpcLike",
        "makeShortHandleBase",
        "makeShortHandleBaseFromEntity",
        "parseHandleToken",
        "classifyNearbyEntityForViewer",
        "buildNearbyTargetSnapshot",
        "resolveNearbyHandleInRoom",
        "isWorldSpawnsEnabled",
        "getPlayerXZ"
      ],
      "dependsOn": [],
      "notes": [
        "Shared nearby-handle + snapshot utilities for MUD commands (e.g. rat.1, alchemist.1).",
        "Centralizes handle parsing, short-handle base derivation, dead/alive classification, and distance sorting.",
        "Provides resolveNearbyHandleInRoom(...) for commands that accept nearby handles; uses last-write-wins on same handle and stable indexing by sorted snapshot.",
        "Exports getPlayerXZ(...) and isWorldSpawnsEnabled() helpers used by nearby/vendor workflows."
      ]
    },
    "mud.help": {
      "kind": "utility",
      "path": "worldcore/mud/MudHelpMenu.ts",
      "symbol": "HELP_ENTRIES",
      "dependsOn": [],
      "provides": [
        "HELP_ENTRIES: { cmd:string, desc:string, debug?:boolean }[]"
      ],
      "notes": [
        "Source of truth for the MUD help text and visible commands."
      ]
    },
    "mud.map": {
      "kind": "utility",
      "path": "worldcore/mud/MapRenderer.ts",
      "function": "buildAsciiMap",
      "dependsOn": [
        "world.manager"
      ],
      "provides": [
        "buildAsciiMap(world:ServerWorldManager|undefined, char:CharacterState, radius?:number):string"
      ],
      "notes": [
        "Builds ANSI-friendly minimap strings using RegionMap biomes.",
        "Used by 'map [radius]' command."
      ]
    },
    "mud.presence": {
      "kind": "utility",
      "path": "worldcore/mud/PresenceCommands.ts",
      "functions": [
        "who(sessions:SessionManager):Promise<string>",
        "nearby(sessions:SessionManager, regionId:string|null):Promise<string>"
      ],
      "dependsOn": [
        "core.sessions",
        "guilds.service"
      ],
      "notes": [
        "Implements 'who' and 'nearby' using SessionManager + GuildService."
      ]
    },
    "mud.progression": {
      "kind": "facade",
      "path": "worldcore/mud/MudProgression.ts",
      "lifecycle": "stateless",
      "dependsOn": [
        "progression.core",
        "progression.tasks",
        "progression.titles",
        "progression.quests"
      ],
      "provides": [
        "ensureProgression(char)",
        "incrementProgressionCounter(char, category, key, amount?)",
        "recordActionProgress(char, key, amount?)",
        "ensureTaskList(char)",
        "updateTasksFromProgress(char)",
        "ensureTitlesContainer(char)",
        "updateTitlesFromProgress(char)",
        "ensureQuestState(char)",
        "updateQuestsFromProgress(char)",
        "renderQuestLog(char)"
      ],
      "notes": [
        "Thin adapter between core progression modules and MUD-facing code.",
        "Keeps MUD imports stable even if progression internals move."
      ]
    },
    "mud.progressionHooks": {
      "kind": "service",
      "path": "worldcore/mud/MudProgressionHooks.ts",
      "class": "MudProgressionHooks",
      "lifecycle": "stateless",
      "dependsOn": [
        "mud.progression",
        "characters.service",
        "characters.titles",
        "progression.rewards"
      ],
      "provides": [
        "applyProgressionForEvent(ctx:MudContext, char:CharacterState, category:'kills'|'harvests', key:string):Promise<{snippets:string[]}>"
      ],
      "notes": [
        "Handles kill/harvest progression reactions: tasks, titles, quests, rewards, and DB patch.",
        "Does NOT increment counters itself; action handlers fire applyProgressionEvent in ProgressionCore directly."
      ]
    },
    "mud.resources": {
      "kind": "legacy_facade",
      "path": "worldcore/mud/MudResources.ts",
      "lifecycle": "stateless",
      "dependsOn": [],
      "provides": [
        "ensurePowerResourceMap(char)",
        "getOrInitPowerResource(char, kind)",
        "trySpendPowerResource(char, kind, cost)",
        "gainPowerResource(char, kind, amount)",
        "getPrimaryPowerResourceForClass(classId)"
      ],
      "notes": [
        "Older MUD-local resource helpers; new code prefers '../resources/PowerResources'.",
        "Safe to treat as compatibility layer while refactoring."
      ]
    },
    "mud.runtime": {
      "kind": "utility",
      "path": "worldcore/mud/runtime/mudRuntime.ts",
      "functions": [
        "getSelfEntity"
      ],
      "dependsOn": [
        "mud.context",
        "core.entities"
      ],
      "notes": [
        "Helper to resolve the world entity owned by the current session.",
        "Used by talk and other world-interaction commands that need the player entity."
      ]
    },
    "mud.spells": {
      "kind": "service",
      "path": "worldcore/mud/MudSpells.ts",
      "lifecycle": "stateless",
      "dependsOn": [
        "mud.context",
        "spells.table",
        "resources.power",
        "combat.cooldowns",
        "mud.actions.combat",
        "skills.progression",
        "combat.damagePolicy",
        "characters.stats",
        "songs.songScaling",
        "items.catalog"
      ],
      "provides": [
        "listKnownSpellsForChar(char):SpellDefinition[]",
        "castSpellForCharacter(ctx, char, spell, targetNameRaw?):Promise<string>",
        "handleCastCommand(ctx, char, spellNameRaw, targetNameRaw?):Promise<string>"
      ],
      "notes": [
        "Implements 'spells' and 'cast <name> [target]'.",
        "Supports damage_single_npc and heal_self kinds.",
        "Supports Virtuoso song casts (isSong + songSchool) including melody-driven auto-casts via SongEngine.",
        "Applies song scaling from song school skill and an optional equipped instrument bonus (instrumentPct / instrumentPctBySchool) for deterministic song tuning.",
        "Tracks cooldowns and power resource costs via CastingGates / PowerResources; trains song schools on successful song casts."
      ]
    },
    "mud.trainingDummy": {
      "kind": "service",
      "path": "worldcore/mud/MudTrainingDummy.ts",
      "lifecycle": "singleton",
      "dependsOn": [
        "mud.context",
        "core.sessions"
      ],
      "provides": [
        "getTrainingDummyForRoom(roomId):TrainingDummyState",
        "computeTrainingDummyDamage(attrs):number",
        "startTrainingDummyAi(ctx, sessionId, roomId):void",
        "stopTrainingDummyAi(sessionId):void"
      ],
      "notes": [
        "Provides per-room immortal training dummies and their simple AI loop.",
        "Used by attack/dummy flows and autoattack toggling."
      ]
    },
    "npc.crime": {
      "kind": "service",
      "path": "worldcore/npc/NpcCrime.ts",
      "functions": [
        "isProtectedNpc",
        "recordNpcCrimeAgainst",
        "resolveGuardCallRadius"
      ],
      "dependsOn": [
        "npc.types",
        "utils.logger"
      ],
      "notes": [
        "Determines which NPCs are 'protected' (civilian, vendor, questgiver, protected_town, etc.) and records crimes against them on the attacker.",
        "Sets recentCrimeUntil and recentCrimeSeverity (minor|severe) on characters to drive guard response.",
        "law_exempt > law_protected > legacy tags precedence",
        "guards/resources are never “protected” for crime purposes"
      ]
    },
    "npc.manager": {
      "kind": "service",
      "path": "worldcore/npc/NpcManager.ts",
      "class": "NpcManager",
      "dependsOn": [
        "core.entities",
        "core.sessions",
        "npc.types",
        "npc.threat",
        "npc.crime",
        "ai.localSimpleBrain",
        "combat.entityCombat",
        "classes.definitions",
        "utils.logger",
        "combat.damagePolicy"
      ],
      "notes": [
        "Owns runtime NPC state, per-room maps, threat tables, and bridges EntityManager ↔ AI brain ↔ sessions/chat.",
        "Spawns/Despawns NPCs, applies damage, records threat, coordinates guard/pack help, coward fleeing, gating, and drives AI decisions each tick.",
        "On lethal damage and before despawn, clears combat status effects so corpses don't keep ticking DOTs or carry modifiers."
      ]
    },
    "npc.postgres": {
      "kind": "service",
      "path": "worldcore/npc/PostgresNpcService.ts",
      "class": "PostgresNpcService",
      "dependsOn": [
        "db.main",
        "npc.types"
      ],
      "notes": [
        "Loads NPC prototypes and loot tables from npcs and npc_loot tables.",
        "Maps DB rows into NpcPrototype and NpcLootEntry arrays suitable for setNpcPrototypes."
      ]
    },
    "npc.spawnController": {
      "kind": "service",
      "path": "worldcore/npc/NpcSpawnController.ts",
      "class": "NpcSpawnController",
      "dependsOn": [
        "npc.manager",
        "world.spawnPoints",
        "core.entities",
        "progression.core",
        "utils.logger"
      ],
      "notes": [
        "Controls NPC and resource/node spawning from DB-backed SpawnPointService.",
        "Spawns shared NPCs per room and personal resource nodes per player, respecting per-character depletion via isNodeAvailable and deduping spawn points per scope."
      ]
    },
    "npc.threat": {
      "kind": "service",
      "path": "worldcore/npc/NpcThreat.ts",
      "functions": [
        "updateThreatFromDamage",
        "getLastAttackerFromThreat"
      ],
      "notes": [
        "Minimal threat bookkeeping: last attacker entity id and timestamp.",
        "Used by NpcManager to steer AI targeting toward whoever last harmed the NPC."
      ]
    },
    "npc.types": {
      "kind": "model",
      "path": "worldcore/npc/NpcTypes.ts",
      "notes": [
        "Defines NpcId, GuardProfile, NpcBehavior, NpcLootEntry, NpcPrototype, and NpcRuntimeState.",
        "Includes DEFAULT_NPC_PROTOTYPES (training_dummy, town_rat, coward_rat, ore_vein_small, town_guard, rat_pack_raider, bandit_caster, starter_alchemist) plus guard call radius helpers and a live prototype registry."
      ]
    },
    "progression.core": {
      "kind": "service",
      "path": "worldcore/progression/ProgressionCore.ts",
      "functions": [
        "ensureProgression",
        "incrementProgressionCounter",
        "recordActionProgress",
        "applyProgressionEvent",
        "getNodeDepletedUntil",
        "isNodeAvailable",
        "setNodeDepletedUntil"
      ],
      "dependsOn": [
        "characters.types",
        "progression.events.raw"
      ],
      "notes": [
        "Canonical per-character progression blob and event application logic.",
        "Tracks kills, harvests, actions, collects, flags, exploration, gathering, quests, tasks, and titles.",
        "Also encodes personal node depletion using progression flags."
      ]
    },
    "progression.eventSink": {
      "kind": "service_contract",
      "path": "worldcore/progression/ProgressionEventSink.ts",
      "functions": [
        "recordEvent"
      ],
      "dependsOn": [
        "progression.core"
      ],
      "notes": [
        "Async sink interface for streaming ProgressionEvent records to external stores.",
        "Extends events with userId, characterId, shardId, roomId, and occurredAt."
      ]
    },
    "progression.events.highLevel": {
      "kind": "model",
      "path": "worldcore/progression/ProgressionEvents.ts",
      "notes": [
        "Older high-level ProgressEvent model with kinds kill_npc, harvest_node, item_turnin, talk_to_npc, visit_room.",
        "Kept for compatibility with any legacy progression/quest triggers that still use this shape."
      ]
    },
    "progression.events.raw": {
      "kind": "model",
      "path": "worldcore/progression/ProgressEvents.ts",
      "notes": [
        "Low-level immutable ProgressEvent log shape used for analytics or external sinks.",
        "Defines ProgressEventKind, GatheringKind, GatheringStats, and ProgressEvent payload."
      ]
    },
    "progression.helpers": {
      "kind": "service",
      "path": "worldcore/progression/ProgressionHelpers.ts",
      "functions": [
        "normalizeProgression",
        "getOrInitPowerResource",
        "modifyPowerResource",
        "getCooldowns",
        "isAbilityOnCooldown",
        "setAbilityCooldown",
        "getSkills",
        "getOrInitSkillBucket",
        "getGathering",
        "getOrInitGatherDiscipline"
      ],
      "dependsOn": [
        "progression.types"
      ],
      "notes": [
        "Utility helpers to normalize and manipulate CharacterProgression.",
        "Covers power pools, cooldowns, generic skill buckets, and gathering disciplines."
      ]
    },
    "progression.progressText": {
      "kind": "service",
      "path": "worldcore/progression/progressText.ts",
      "functions": [
        "renderProgressText"
      ],
      "dependsOn": [
        "progression.tasks.types"
      ],
      "notes": [
        "Renders a 'Progress:' text block showing kills, harvests, and simple tasks with [ ]/[x] markers.",
        "Used by the 'progress' MUD command."
      ]
    },
    "progression.rewards.grantTaskRewards": {
      "kind": "module",
      "path": "worldcore/progression/rewards/grantTaskRewards.ts",
      "functions": [
        "grantTaskRewards"
      ],
      "dependsOn": [
        "utils.logger",
        "economy.EconomyHelpers",
        "progression.ProgressionCore",
        "loot.OverflowDelivery",
        "rewards.RewardDelivery",
        "characters.service?"
      ],
      "notes": [
        "Aggregates task reward XP/gold/items across completed tasks.",
        "XP is granted via CharacterService.grantXp; gold applied via EconomyHelpers.",
        "Item delivery uses RewardDelivery (bags-first, overflow-to-mail if available; otherwise queues to progression.pendingRewards).",
        "When items are queued, players can retrieve them later via 'reward claim'."
      ]
    },
    "progression.rewards.tasks": {
      "kind": "service",
      "path": "worldcore/progression/rewards/grantTaskRewards.ts",
      "functions": [
        "grantTaskRewards"
      ],
      "dependsOn": [
        "utils.logger",
        "characters.service?",
        "economy.helpers",
        "rewards.RewardDelivery"
      ],
      "notes": [
        "Aggregates XP, gold, and item rewards from completed tasks and applies them to the character.",
        "Uses characters.grantXp and EconomyHelpers.grantReward, with optional patchCharacter to persist inventory."
      ]
    },
    "progression.tasks.engine": {
      "kind": "service",
      "path": "worldcore/progression/tasks/taskEngine.ts",
      "functions": [
        "ensureTaskList",
        "updateTasksFromProgress"
      ],
      "dependsOn": [
        "progression.core",
        "progression.tasks.types",
        "characters.types"
      ],
      "notes": [
        "Maintains prog.tasks as SimpleTask[] and updates completion based on kills/harvests counters.",
        "Returns a list of newly completed tasks for reward processing."
      ]
    },
    "progression.tasks.types": {
      "kind": "model",
      "path": "worldcore/progression/tasks/taskTypes.ts",
      "notes": [
        "Defines SimpleTask with id, type ('kill'|'harvest'), target, required count, completion flag, and optional reward.",
        "Used by taskEngine, progress text, and reward logic."
      ]
    },
    "progression.titles.setActive": {
      "kind": "service",
      "path": "worldcore/progression/titles/setActiveTitle.ts",
      "functions": [
        "setActiveTitle"
      ],
      "dependsOn": [
        "utils.logger",
        "mud.progression",
        "characters.titles"
      ],
      "notes": [
        "Parses user input from 'settitle', fuzzy-matches to an unlocked title id, and sets it active.",
        "Persists updated progression via ctx.characters.patchCharacter when available."
      ]
    },
    "progression.titles.state": {
      "kind": "service",
      "path": "worldcore/progression/titles/titleState.ts",
      "functions": [
        "ensureTitlesContainer",
        "updateTitlesFromProgress"
      ],
      "dependsOn": [
        "characters.types",
        "progression.core",
        "characters.titles"
      ],
      "notes": [
        "Ensures prog.titles exists and is well-formed, with unlocked[] and active.",
        "Computes newly unlocked titles from kills/harvests using TITLES unlock rules."
      ]
    },
    "progression.titles.text": {
      "kind": "service",
      "path": "worldcore/progression/titles/titleText.ts",
      "functions": [
        "renderCurrentTitle",
        "renderTitlesList"
      ],
      "dependsOn": [
        "progression.titles.state",
        "characters.titles"
      ],
      "notes": [
        "Renders 'Current title: ...' and 'Titles:' lists using TITLES definitions.",
        "Used by 'title' and 'titles' MUD commands."
      ]
    },
    "progression.types": {
      "kind": "model",
      "path": "worldcore/progression/ProgressionTypes.ts",
      "notes": [
        "Defines PowerResourceState, CooldownsState, SkillsState, TitlesState, GatheringState, CountersState, and FlagsState.",
        "Represents the canonical character.progression JSON layout."
      ]
    },
    "protocol.objects": {
      "kind": "model",
      "path": "worldcore/protocol/ObjectMessages.ts",
      "dependsOn": [
        "shards.worldBlueprint"
      ],
      "notes": [
        "Defines ClientObjectRequestPayload and ObjectChunkPayload for static world objects and spawn points.",
        "Used by ObjectStream and any client that wants shared types for blueprint objects and spawns."
      ]
    },
    "protocol.terrain": {
      "kind": "model",
      "path": "worldcore/protocol/WGEv3ChunkProtocol.ts",
      "notes": [
        "Single source of truth for WGEv3 terrain streaming protocol.",
        "Defines TerrainChunkCoord, TerrainChunkId, TerrainBlueprintMeta, TerrainChunkDataWire, and client/server terrain message envelopes and unions.",
        "Provides type guards isClientTerrainMessage and isServerTerrainMessage."
      ]
    },
    "pvp.duels": {
      "kind": "service",
      "path": "worldcore/pvp/DuelService.ts",
      "dependsOn": [],
      "functions": [
        "DuelService",
        "DUEL_SERVICE",
        "requestDuel",
        "acceptDuel",
        "acceptAny",
        "declineDuel",
        "endDuelFor",
        "isActiveBetween",
        "getActiveDuel",
        "getOpponentId",
        "tick"
      ],
      "provides": [
        "In-memory duel handshake + active duel pairing",
        "Duel-gated PvP enablement hook (mode: 'duel')"
      ],
      "notes": [
        "Ephemeral state only (resets on server restart).",
        "Requests expire quickly to avoid stale challenges.",
        "Used by MudCommandHandler (duel/accept/decline/yield) and MudCombatActions (duel-gated player attack)."
      ]
    },
    "pvp.rules": {
      "kind": "utility",
      "path": "worldcore/pvp/PvpRules.ts",
      "functions": [
        "areAllies",
        "canDamagePlayer",
        "resolvePlayerDamageMode"
      ],
      "dependsOn": [
        "characters.types"
      ],
      "notes": [
        "Centralized PvP gating rules (v1). Fail-closed by default; duel allows; open PvP region allows unless allies (same guild)."
      ]
    },
    "quests.TownQuestBoard": {
      "kind": "service",
      "path": "worldcore/quests/TownQuestBoard.ts",
      "functions": [
        "renderTownQuestBoard(ctx, char)",
        "acceptTownQuest(ctx, char, idOrIndex)",
        "abandonQuest(ctx, char, idOrIndex)",
        "resolveQuestDefinitionFromStateId(questId, entry)"
      ],
      "dependsOn": [
        "quests.QuestGenerator",
        "quests.QuestRegistry",
        "quests.QuestState",
        "progression.core",
        "characters.service",
        "core.EntityManager",
        "core.RoomManager"
      ],
      "provides": [
        "Town-scoped deterministic quest board output",
        "Accept/abandon writes QuestState entries",
        "Quest definition resolution for generated quests via QuestSource metadata"
      ],
      "notes": [
        "Quest Board v0: lists deterministic generated quests for current town context (region/town key + tier + epoch).",
        "Acceptance creates QuestState entries (quests are no longer implicitly active just because they exist in the registry).",
        "resolveQuestDefinitionFromStateId enables QuestEngine/QuestText/turnInQuest to resolve generated quests without needing live ctx."
      ]
    },
    "quests.engine": {
      "kind": "service",
      "path": "worldcore/quests/QuestEngine.ts",
      "functions": [
        "updateQuestsFromProgress"
      ],
      "dependsOn": [
        "progression.core",
        "quests.state",
        "quests.registry",
        "items.inventoryHelpers",
        "characters.types",
        "quests.TownQuestBoard"
      ],
      "notes": [
        "Scans all quests against kills, harvests, actions, flags, and inventory to update completion state.",
        "Marks active quests as completed when all objectives are satisfied and returns the completed list.",
        "No auto-activation",
        "Evaluates accepted quest state entries (not only registry-known quests)",
        "Supports generated TownQuestBoard quest IDs"
      ]
    },
    "quests.generator": {
      "kind": "module",
      "service": "quests",
      "path": "worldcore/quests/QuestGenerator.ts",
      "class": "(module) QuestGenerator",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [
        "quests.types"
      ],
      "provides": [
        "stableQuestGenSeed({townId,tier,epoch}): stable 32-bit seed",
        "generateTownQuests({townId,tier,epoch,...}): deterministic town quest set",
        "mergeRewards(a,b): helper to sum QuestReward bags"
      ],
      "notes": [
        "Quest Generator v0: deterministic per (townId, tier, epoch).",
        "Uses conservative objective pools (ids already present in QuestTypes examples) so generated quests are completable with current content.",
        "Introduces small deterministic jitter on required counts and XP/gold rewards."
      ]
    },
    "quests.postgres": {
      "kind": "service",
      "path": "worldcore/quests/PostgresQuestService.ts",
      "class": "PostgresQuestService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "quests.service",
        "quests.types"
      ],
      "notes": [
        "Loads quest definitions, objectives, and rewards from Postgres quests, quest_objectives, and quest_rewards tables.",
        "Aggregates reward rows into QuestReward (xp, gold, items, titles) and maps objective rows into QuestObjective.",
        "Implements listQuests and getQuest with filtering on is_enabled and repeatable/maxCompletions mapping."
      ]
    },
    "quests.registry": {
      "kind": "service",
      "path": "worldcore/quests/QuestRegistry.ts",
      "functions": [
        "setQuestDefinitions",
        "getQuestById",
        "getAllQuests"
      ],
      "dependsOn": [
        "quests.types"
      ],
      "notes": [
        "Wraps QUESTS in a mutable registry so quests can be loaded from DB.",
        "setQuestDefinitions replaces questMap with provided definitions."
      ]
    },
    "quests.service": {
      "kind": "service_contract",
      "path": "worldcore/quests/QuestService.ts",
      "notes": [
        "QuestService interface: getQuest, listQuests, and optional admin-style createOrUpdateQuest/deleteQuest.",
        "Implemented by PostgresQuestService."
      ]
    },
    "quests.state": {
      "kind": "service",
      "path": "worldcore/quests/QuestState.ts",
      "functions": [
        "ensureQuestState"
      ],
      "dependsOn": [
        "progression.core",
        "characters.types"
      ],
      "notes": [
        "Defines QuestStateEntry (state and completions) and QuestStateMap.",
        "ensureQuestState attaches quest state to char.progression.quests."
      ]
    },
    "quests.text": {
      "kind": "service",
      "path": "worldcore/quests/QuestText.ts",
      "functions": [
        "renderQuestLog"
      ],
      "dependsOn": [
        "progression.core",
        "quests.state",
        "quests.registry",
        "items.inventoryHelpers",
        "characters.types"
      ],
      "notes": [
        "Renders textual quest log including status marks [ ], [C], [T] and repeatable completion counters.",
        "Prints per-objective progress lines for kill, harvest, collect_item, craft, city, and talk_to objectives.",
        "No auto-activation."
      ]
    },
    "quests.turnInQuest": {
      "kind": "service",
      "path": "worldcore/quests/turnInQuest.ts",
      "functions": [
        "turnInQuest"
      ],
      "dependsOn": [
        "mud.context",
        "characters.types",
        "quests.registry",
        "quests.state",
        "progression.core",
        "items.inventoryHelpers",
        "economy.helpers",
        "rewards.RewardDelivery"
      ],
      "notes": [
        "Handles quest turn-in: resolves quest by id/name, checks completion and repeatable caps, and revalidates objectives.",
        "Consumes collect_item requirements from inventory, applies XP via ctx.characters.grantXp, and grants gold/items via grantReward.",
        "Unlocks title rewards, updates quest completions and state (active/turned_in), and patches character progression + inventory.",
        "Warfront-friendly: supports 'turnin list'/'ready' and numeric index turn-in (1-based) using stable quest log ordering (sorted ids)."
      ]
    },
    "quests.types": {
      "kind": "model",
      "path": "worldcore/quests/QuestTypes.ts",
      "functions": [
        "listAllQuests"
      ],
      "notes": [
        "Defines QuestObjectiveKind (kill, harvest, collect_item, craft, city, talk_to) and their concrete interfaces.",
        "Defines QuestReward and QuestDefinition with repeatable/maxCompletions fields.",
        "Provides QUESTS hardcoded map including rat_culling, ore_sampling, rat_tail_collection, greet_quartermaster."
      ]
    },
    "resources.power": {
      "kind": "service",
      "path": "worldcore/resources/PowerResources.ts",
      "functions": [
        "ensurePowerResourceMap",
        "getOrInitPowerResource",
        "trySpendPowerResource",
        "gainPowerResource",
        "getPrimaryPowerResourceForClass"
      ],
      "dependsOn": [
        "characters.types",
        "utils.logger"
      ],
      "notes": [
        "Manages Fury/Mana pools stored under char.progression.powerResources.",
        "Provides class->primary resource mapping and helpers to spend/gain power."
      ]
    },
    "rewards.RewardDelivery": {
      "kind": "helper",
      "path": "worldcore/rewards/RewardDelivery.ts",
      "functions": [
        "deliverRewardItems",
        "claimPendingRewards"
      ],
      "dependsOn": [
        "progression.ProgressionCore",
        "loot.OverflowDelivery"
      ],
      "notes": [
        "Central reward item delivery: uses OverflowDelivery (bags-first, overflow-to-mail).",
        "Queues undelivered reward items into progression.pendingRewards so rewards are never lost.",
        "Supports strict preflight mode for quest turn-ins when mail is unavailable."
      ]
    },
    "shards.worldBlueprint": {
      "kind": "model",
      "path": "worldcore/shards/WorldBlueprint.ts",
      "functions": [
        "buildDemoPrimeWorld"
      ],
      "dependsOn": [
        "terrain.regionTypes"
      ],
      "notes": [
        "Defines WorldBoundary, BlueprintObject, SpawnPoint, and WorldBlueprint for shards.",
        "buildDemoPrimeWorld() creates the current demo Prime Shard blueprint used by ServerWorldManager."
      ]
    },
    "shared.entities": {
      "kind": "model",
      "path": "worldcore/shared/Entity.ts",
      "notes": [
        "Defines Entity: id, type, roomId, ownerSessionId, position, facing, HP, labels, spawn metadata, and targetId.",
        "Used by EntityManager, combat, NPC systems, and MUD commands."
      ]
    },
    "shared.messages": {
      "kind": "model",
      "path": "worldcore/shared/messages.ts",
      "notes": [
        "Defines ClientOpcode, ServerOpcode, ClientMessage, ServerMessage, WhereAmI* messages, and MudResultPayload.",
        "Shared envelope protocol for MMO/MUD/Web clients over WebSocket."
      ]
    },
    "shared.region": {
      "kind": "alias",
      "path": "worldcore/shared/region.ts",
      "dependsOn": [
        "terrain.regionTypes"
      ],
      "notes": [
        "Re-exports RegionId, Region, and RegionSample from terrain/regions/RegionTypes.",
        "Convenience alias to avoid deep import paths in callers."
      ]
    },
    "shared.session": {
      "kind": "model",
      "path": "worldcore/shared/Session.ts",
      "notes": [
        "Defines Session: id, displayName, WebSocket, roomId, lastSeen, shardId, identity, and attached CharacterState.",
        "Used by SessionManager and MUD/sessionLookup helpers."
      ]
    },
    "shared.wgev3ChunkProtocol": {
      "kind": "alias",
      "path": "worldcore/shared/WGEv3ChunkProtocol.ts",
      "notes": [
        "Re-exports the canonical WGEv3ChunkProtocol from worldcore/protocol.",
        "Kept for backward compatibility with older imports."
      ]
    },
    "shared.worldCoreContext": {
      "kind": "types",
      "path": "worldcore/shared/WorldCoreContext.ts",
      "notes": [
        "Defines lightweight SessionLike, SessionsManagerLike, and EntitiesManagerLike interfaces.",
        "Used where full SessionManager/EntityManager are not desired as hard deps."
      ]
    },
    "sim.brainActions": {
      "kind": "types",
      "path": "worldcore/sim/BrainActions.ts",
      "notes": [
        "Types for Mother-Brain style planning outputs (audit → plan actions → apply).",
        "Includes PlaceSpawnAction used by SettlementPlanner + simBrain apply."
      ]
    },
    "sim.gapFiller": {
      "kind": "utility",
      "path": "worldcore/sim/GapFiller.ts",
      "provides": [
        "planGapFillSpawns(existingSpawns, cfg) -> GapFillSpawn[]",
        "Worst-gap-first loop; places at cell center; enforces minDistance from graveyard/checkpoint blockers."
      ],
      "dependsOn": [
        "sim.grid",
        "sim.respawnCoverage"
      ],
      "notes": [
        "Gap filling planner for respawn coverage: adds checkpoints/graveyards only where gaps exist.",
        "Deterministic spawnId per cell (`checkpoint_gap_<cx>_<cz>` etc.) so reruns update rather than duplicate."
      ]
    },
    "sim.grid": {
      "kind": "utility",
      "path": "worldcore/sim/SimGrid.ts",
      "provides": [
        "cellCenter(cell, cellSize)",
        "cellBounds(cell, cellSize)",
        "makeRegionId(shardId, cell) -> `${shardId}:${cx},${cz}`",
        "parseBounds(spec) -> Bounds",
        "other grid helpers"
      ],
      "notes": [
        "Grid primitives for simulation and world tooling (cell bounds, region ids, cell center math).",
        "Shared by settlement planner, respawn coverage report, and gap filler."
      ]
    },
    "sim.motherBrainWaveOps": {
      "kind": "module",
      "service": "sim",
      "path": "worldcore/sim/MotherBrainWaveOps.ts",
      "class": "(functions)",
      "lifecycle": "static",
      "ctorArgs": [],
      "provides": [
        "computeBrainWaveApplyPlan",
        "computeBrainWipePlan",
        "parseBrainSpawnIdLoose"
      ],
      "dependsOn": [
        "sim.motherBrainWavePlanner"
      ],
      "owns": [],
      "notes": [
        "Pure helper utilities for reasoning about Mother Brain wave idempotence/replace behavior and wipe selection without DB access.",
        "Used primarily by tests; safe to import anywhere."
      ]
    },
    "sim.motherBrainWavePlanner": {
      "kind": "module",
      "service": "sim",
      "path": "worldcore/sim/MotherBrainWavePlanner.ts",
      "class": "(functions)",
      "lifecycle": "static",
      "ctorArgs": [],
      "provides": [
        "planBrainWave",
        "mother-wipe: delete brain-owned spawn_points within bounds (filterable by --theme/--epoch), dry-run vs --commit",
        "CLI: mother-wipe"
      ],
      "dependsOn": [],
      "owns": [],
      "notes": [
        "Deterministic planner for Mother Brain \"brain-owned\" spawn_points waves (preview/commit pipeline).",
        "Used by tools.simBrain (mother-wave/mother-status) and web admin spawnpoints route."
      ]
    },
    "sim.respawnCoverage": {
      "kind": "utility",
      "path": "worldcore/sim/RespawnCoverage.ts",
      "provides": [
        "computeRespawnCoverage(spawns, cfg) -> { rows, summary }",
        "Eligibility: graveyard/checkpoint always; settlement-ish types unless variantId === 'kos'"
      ],
      "dependsOn": [
        "sim.grid"
      ],
      "notes": [
        "Respawn coverage auditing utilities for the Dev Simulation Harness.",
        "Scans a cell bounds box and marks each cell center covered if within respawnRadius of an eligible respawn source."
      ]
    },
    "sim.rng": {
      "kind": "utility",
      "path": "worldcore/sim/SimRng.ts",
      "class": "SimRng",
      "lifecycle": "factory",
      "ctorArgs": [
        "seed"
      ],
      "dependsOn": [],
      "provides": [
        "shuffle(array) -> newArray",
        "hash32(string) -> uint32",
        "other deterministic RNG helpers"
      ],
      "notes": [
        "Deterministic RNG utilities for repeatable world planning."
      ]
    },
    "sim.settlementPlanner": {
      "kind": "utility",
      "path": "worldcore/sim/SettlementPlanner.ts",
      "provides": [
        "planInitialOutposts(factions, cfg) -> BrainAction[]"
      ],
      "dependsOn": [
        "sim.grid",
        "sim.rng",
        "sim.brainActions"
      ],
      "notes": [
        "Deterministic outpost placement with spacing constraints inside cell bounds.",
        "SpawnId format: outpost_<factionKey>_<index>_<cx>_<cz>.",
        "Supports FactionSeedSpec.startIndex to avoid spawnId collisions in append-only (safe) runs.",
        "Adds deterministic jitter within a cell border margin."
      ]
    },
    "sim.townBaselinePlanner": {
      "kind": "module",
      "service": "sim",
      "path": "worldcore/sim/TownBaselinePlanner.ts",
      "class": "(functions)",
      "lifecycle": "static",
      "ctorArgs": [],
      "provides": [
        "planTownBaselines",
        "TownBaselinePlanOptions",
        "TownBaselinePlan",
        "TownLikeSpawnRow",
        "TownBaselineSpawnIdMode",
        "spawnIdMode: legacy | seed",
        "seedBase namespace (default seed:town_baseline)"
      ],
      "owns": [],
      "notes": [
        "Plans baseline services around towns (mailboxes/rest/guards/dummies/stations/vendors).",
        "TownLikeSpawnRow now accepts townTier (DB) so station seeding can be tier-gated per town.",
        "Supports spawnIdMode: \"seed\" (seed:* spawnIds suitable for web placement ownership) vs \"legacy\" (svc_* ids for backwards compatibility).",
        "Made bounds typing structural so backend-provided bounds typechecks cleanly",
        "Made polarOffset() accept optional radius to avoid number | undefined TS errors"
      ]
    },
    "sim.townTierSeeding": {
      "kind": "module",
      "service": "sim",
      "path": "worldcore/sim/TownTierSeeding.ts",
      "class": "(functions)",
      "lifecycle": "static",
      "ctorArgs": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Provides tier assignment helpers."
      ]
    },
    "skills.progression": {
      "kind": "service",
      "path": "worldcore/skills/SkillProgression.ts",
      "functions": [
        "getWeaponSkill",
        "gainWeaponSkill",
        "getSpellSchoolSkill",
        "gainSpellSchoolSkill",
        "getSongSchoolSkill",
        "gainSongSchoolSkill"
      ],
      "dependsOn": [
        "characters.types",
        "combat.engine"
      ],
      "notes": [
        "Stores weapon, spell, and song instrument skills under char.progression.skills.",
        "Skills are capped at level * 10 and default to 0 if missing."
      ]
    },
    "songs.engine": {
      "kind": "service",
      "path": "worldcore/songs/SongEngine.ts",
      "functions": [
        "getSongsState",
        "getMelody",
        "setMelody",
        "addSongToMelody",
        "removeSongFromMelody",
        "clearMelody",
        "setMelodyActive",
        "tickSongsForCharacter"
      ],
      "dependsOn": [
        "characters.types",
        "mud.context",
        "spells.types",
        "mud.spells",
        "utils.logger",
        "core.entities",
        "songs.melodyScheduler"
      ],
      "notes": [
        "Manages Virtuoso song state and melodies stored under char.progression.songs.",
        "tickSongsForCharacter auto-casts a rotating list of Virtuoso songs on a timer using the normal spell pipeline."
      ]
    },
    "songs.melodyScheduler": {
      "kind": "service",
      "path": "worldcore/songs/MelodyScheduler.ts",
      "functions": [
        "normalizeMelody",
        "getPlaylist",
        "currentSpellId",
        "advanceAndSchedule"
      ],
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Pure melody state machine helpers extracted from SongEngine.",
        "Guarantee: advanceAndSchedule always advances index and schedules next tick even on cast failure.",
        "Keeps spellIds and legacy songIds mirrored for back-compat."
      ]
    },
    "songs.songScaling": {
      "kind": "service",
      "path": "worldcore/songs/SongScaling.ts",
      "functions": [
        "computeSongScalar",
        "scaleSongHealFloor"
      ],
      "dependsOn": [
        "skills.skillProgression"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Central song scaling math to prevent drift across MudSpells/CombatEngine/SongEngine.",
        "Baseline scalar rule: 1 + (songSkill/100).",
        "Supports an additional multiplicative instrument bonus (from equipped gear stats) so songs can scale with instruments without touching core attributes."
      ]
    },
    "spells.catalog": {
      "kind": "service",
      "path": "worldcore/spells/SpellCatalog.ts",
      "summary": "Loads spell/song definitions + aliases from Postgres (spells + spell_aliases tables).",
      "dependsOn": [],
      "notes": [
        "Used by spells.types to hydrate the runtime SPELLS map from DB.",
        "Small loader module; safe to keep dumb and predictable."
      ]
    },
    "spells.types": {
      "kind": "model",
      "path": "worldcore/spells/SpellTypes.ts",
      "functions": [
        "findSpellByNameOrId"
      ],
      "dependsOn": [
        "combat.engine",
        "resources.power",
        "skills.progression",
        "spells.catalog",
        "utils.logger",
        "spells.unlockRules"
      ],
      "notes": [
        "Defines SpellDefinition and SpellKind plus the SPELLS registry.",
        "Includes debug_arcane_bolt, mage_fire_bolt, cleric_minor_heal, and Virtuoso song spells.",
        "SpellKind includes buff/debuff/DOT kinds (buff_self, buff_single_ally, debuff_single_npc, damage_dot_single_npc).",
        "SpellStatusEffect payloads define status effect id/modifiers/duration/maxStacks for buff/debuff/DOT spells.",
        "Current wiring: buff_self and buff_single_ally are implemented in MudSpells; NPC debuffs/DOTs remain a TODO until NPC statusEffects + ticking lands."
      ]
    },
    "spells.unlocks": {
      "kind": "helper",
      "path": "worldcore/spells/SpellUnlocks.ts",
      "functions": [
        "getSpellUnlockSource",
        "getAllSpellUnlockRules",
        "getAutoGrantUnlocksFor",
        "initSpellUnlocksFromDbOnce",
        "__setSpellUnlocksForTest",
        "__resetSpellUnlocksForTest"
      ],
      "dependsOn": [
        "spells.types"
      ],
      "notes": [
        "DB-driven spell/song unlock rules that feed spellbook auto-grants.",
        "Supports test overrides and a one-time DB hydration step.",
        "If the spell_unlocks table is missing, the system falls back to the code unlock list; creating the table/migrations is planned once class progression is stabilized."
      ]
    },
    "strategy.regionService": {
      "kind": "service",
      "path": "worldcore/strategy/api/RegionService.ts",
      "class": "RegionService",
      "dependsOn": [
        "shards.worldBlueprint",
        "terrain.regionTypes"
      ],
      "notes": [
        "Query helper over WorldBlueprint for city-builder/strategy layer.",
        "Can list all shards, all regions, regions per shard, and filter by biome or tag."
      ]
    },
    "strategy.world": {
      "kind": "service",
      "path": "worldcore/strategy/domain/world.ts",
      "functions": [
        "seedWorld"
      ],
      "dependsOn": [
        "shards.worldBlueprint"
      ],
      "notes": [
        "Defines domain-level World and WorldShard types for the strategy layer.",
        "seedWorld() builds the demo Prime Shard world from buildDemoPrimeWorld with biome-based danger ratings."
      ]
    },
    "systems.recovery": {
      "kind": "service",
      "path": "worldcore/systems/recovery/recoveryOps.ts",
      "functions": [
        "restoreEntityToFull",
        "respawnInPlace",
        "restOrSleep"
      ],
      "dependsOn": [
        "combat.entityCombat"
      ],
      "notes": [
        "Recovery helpers operating on entities via a RecoveryContext with session and entities provider.",
        "respawnInPlace and restOrSleep resurrect or fully restore the player entity and shut down autoattack/training dummy hooks."
      ]
    },
    "systems.regen": {
      "kind": "service",
      "path": "worldcore/systems/regen/ensureRegenLoop.ts",
      "functions": [
        "ensureRegenLoop"
      ],
      "dependsOn": [
        "core.sessions",
        "core.entities",
        "combat.entityCombat"
      ],
      "notes": [
        "Starts a global HP regen loop once, ticking every 5 seconds.",
        "Iterates all sessions and heals non-dead, out-of-combat entities by a fixed amount up to maxHp."
      ]
    },
    "targeting.finders": {
      "kind": "utility",
      "path": "worldcore/targeting/targetFinders.ts",
      "functions": [
        "findTargetPlayerEntityByName",
        "findNearestNpcByName",
        "findNpcTargetByName"
      ],
      "dependsOn": [
        "core.sessions",
        "core.entities",
        "shared.entities"
      ],
      "notes": [
        "High-level helpers for resolving player and NPC targets by name within a room.",
        "Supports numbered syntax like 'guard.2' and pure index-based targeting for NPCs."
      ]
    },
    "targeting.resolver": {
      "kind": "utility",
      "path": "worldcore/targeting/TargetResolver.ts",
      "functions": [
        "resolveTargetInRoom"
      ],
      "dependsOn": [
        "shared.entities"
      ],
      "notes": [
        "Resolves a target entity in a room by index ('2'), short handle ('rat.1'), or partial name.",
        "Normalizes names and filters by a caller-provided predicate."
      ]
    },
    "terrain.biomeRules": {
      "kind": "utility",
      "path": "worldcore/terrain/biomes/BiomeRules.ts",
      "function": "computeBiome",
      "dependsOn": [
        "backend.worldDimensions?"
      ],
      "provides": [
        "computeBiome(x:number, z:number, height:number, slope:number, dim:WorldDimensions):BiomeResult"
      ],
      "notes": [
        "Scale-aware simple biome classifier used by older pipelines.",
        "Currently imports WorldDimensions from planarwar-backend; treat as optional bridge."
      ]
    },
    "terrain.heightmap": {
      "kind": "utility",
      "path": "worldcore/terrain/height/Heightmap.ts",
      "class": "Heightmap",
      "lifecycle": "factory",
      "ctorArgs": [
        "seed:number"
      ],
      "dependsOn": [],
      "provides": [
        "setNoiseScale(scale:number)",
        "sample(x:number, z:number, biome?:string):number",
        "sampleSlope(x:number, z:number, biomeHint?:string):number"
      ],
      "notes": [
        "Deterministic 2D noise heightfield used by ServerWorldManager and RegionMap.",
        "Biome hint tweaks terrain shape slightly for roads/rivers/hills/farms/etc."
      ]
    },
    "terrain.index": {
      "kind": "barrel",
      "path": "worldcore/terrain/index.ts",
      "reexports": [
        "terrain.heightmap",
        "terrain.regionTypes",
        "terrain.regionSampler",
        "terrain.regionMap",
        "worldgen.scaled"
      ]
    },
    "terrain.regionDifficulty": {
      "kind": "utility",
      "path": "worldcore/terrain/regions/RegionDifficulty.ts",
      "function": "getRegionTier",
      "dependsOn": [
        "terrain.regionTypes"
      ],
      "provides": [
        "getRegionTier(region:Region):1|2|3|4|5"
      ],
      "notes": [
        "Computes difficulty tier by radial distance from world center.",
        "Uses max world radius ≈ 2048 units for current prime shard."
      ]
    },
    "terrain.regionDisplay": {
      "kind": "utility",
      "path": "worldcore/terrain/regions/RegionDisplay.ts",
      "function": "getRegionDisplayName",
      "dependsOn": [
        "terrain.regionTypes",
        "terrain.regionNaming",
        "factions.types?"
      ],
      "provides": [
        "getRegionDisplayName(region:Region, controllingFaction?):string"
      ],
      "notes": [
        "UI helper that decorates region name with 'Domain of <faction>'."
      ]
    },
    "terrain.regionMap": {
      "kind": "service",
      "path": "worldcore/terrain/regions/RegionMap.ts",
      "class": "RegionMap",
      "lifecycle": "factory",
      "ctorArgs": [
        "terrain.heightmap",
        "{ worldId, seed, worldRadius, cellSize? }"
      ],
      "dependsOn": [
        "terrain.heightmap"
      ],
      "provides": [
        "getRegionAt(x:number, z:number):Region|undefined",
        "getBiomeAt(x:number, z:number):string",
        "sampleAt(x:number, z:number):RegionSample|undefined",
        "toOverviewGrid(overviewSize?:number):Region[]"
      ],
      "notes": [
        "Lazy LRU-cached region grid over a circular world disk.",
        "Used by ServerWorldManager for region lookup and overview generation."
      ]
    },
    "terrain.regionNaming": {
      "kind": "utility",
      "path": "worldcore/terrain/regions/RegionNaming.ts",
      "function": "generateRegionName",
      "dependsOn": [
        "terrain.regionTypes"
      ],
      "provides": [
        "generateRegionName(region:Region):string"
      ],
      "notes": [
        "Deterministic procedural names based on biome and position.",
        "Uses internal RNG seeded by worldId + region.id so names are stable."
      ]
    },
    "terrain.regionSampler": {
      "kind": "utility",
      "path": "worldcore/terrain/regions/RegionSampler.ts",
      "class": "RegionSampler",
      "lifecycle": "factory",
      "ctorArgs": [
        "worldId:string",
        "seed:number",
        "terrain.heightmap"
      ],
      "dependsOn": [
        "terrain.heightmap"
      ],
      "provides": [
        "sampleRegion(cx:number, cz:number, radius:number):Region"
      ],
      "notes": [
        "Older helper: random (non-deterministic) sampling of avg height/slope in a disk.",
        "Safe to treat as legacy; RegionMap is the main runtime authority."
      ]
    },
    "terrain.regionTypes": {
      "kind": "model",
      "path": "worldcore/terrain/regions/RegionTypes.ts",
      "types": [
        "RegionId",
        "Region",
        "RegionSample"
      ],
      "notes": [
        "Shared region data model for MMO, strategy layer, and tools."
      ]
    },
    "test.behaviorReloadSpawnsHereReconcilesSharedNpcs": {
      "kind": "test",
      "path": "worldcore/test/behavior_reloadSpawnsHereReconcilesSharedNpcs.test.ts",
      "dependsOn": [
        "mud.commands.debug.reload",
        "npc.spawnController",
        "core.entities"
      ],
      "notes": [
        "Behavior: 'reload spawns --here=<r>' reconciles only spawn_points-driven shared NPCs in radius.",
        "Ensures nodes/personal spawns (ownerSessionId) are never despawned by reconcile."
      ]
    },
    "test.behaviorReloadSpawnsRegionReconcilesSharedNpcs": {
      "kind": "test",
      "path": "worldcore/test/behavior_reloadSpawnsRegionReconcilesSharedNpcs.test.ts",
      "dependsOn": [
        "mud.commands.debug.reload",
        "npc.spawnController",
        "core.entities",
        "world.spawnPoints"
      ],
      "notes": [
        "Behavior: 'reload spawns --region' reconciles spawn_points-driven shared NPCs for the current region.",
        "Locks down epoch swap flows (MotherBrain waves replacing themes) without requiring relog."
      ]
    },
    "test.combatEngineContract": {
      "kind": "test",
      "path": "worldcore/test/combatEngine.contract.test.ts",
      "class": "(test)",
      "lifecycle": "test",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: CombatEngine invariants"
      ]
    },
    "test.contractCastSpellPreGatesNoLeak": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_castSpell_preGates_noLeak.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "mud.spells",
        "mud.combatGates",
        "combat.damagePolicy",
        "pvp.duels",
        "combat.castingGates",
        "test.utils"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: castSpell must consult denial gates (region combat disabled, PvP/duel denial) BEFORE spending resources or starting cooldowns.",
        "Also asserts duels end when a spell kill occurs."
      ]
    },
    "test.contractCastingDeniedDoesNotConsumeCostOrCooldown": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_castingDeniedDoesNotConsumeCostOrCooldown.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "mud.spells",
        "mud.abilities",
        "spells.types",
        "abilities.types",
        "combat.cooldowns",
        "resources.powerResources",
        "combat.serviceProtection"
      ],
      "provides": [],
      "notes": [
        "Contract: if casting is denied after resolving a valid target (e.g. service-protected NPC), do not consume resource cost and do not start cooldowns."
      ]
    },
    "test.contractCastingGatesCostCooldown": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_castingGates_costCooldown.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "combat.castingGates"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: action cost+cooldown gates must never start cooldowns on resource failure.",
        "Contract: cooldown blocks must not spend resource.",
        "Contract: success spends resource and starts cooldown deterministically (with injected now)."
      ]
    },
    "test.contractCombatEngine": {
      "kind": "test",
      "path": "worldcore/test/contract_combatEngine.test.ts",
      "class": "(test)",
      "lifecycle": "test",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: CombatEngine behavior surface"
      ]
    },
    "test.contractCraftingRequiresStations": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_craftingRequiresStations.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "mud.commands.craft",
        "test.utils"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: when PW_CRAFT_STATIONS_REQUIRED=1, crafting requires the correct station in the room.",
        "Prevents regressions where station checks silently stop seeing room entities."
      ]
    },
    "test.contractGatheringCommandsResourceTags": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_gatheringCommandsResourceTags.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: gathering commands must pass correct gatheringKind and resource_tag.",
        "Ensures fish/farm/quarry do not accidentally use resource_ore."
      ]
    },
    "test.contractHarvestProgressionHookWired": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_harvestProgressionHookWired.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: MudWorldActions wires harvest progression reactions and guards hook failures.",
        "Ensures applyProgressionEvent(kind:'harvest') + applyProgressionForEvent(...,'harvests',...) remain present and non-fatal."
      ]
    },
    "test.contractMelodyScheduler": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_melodyScheduler.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "songs.melodyScheduler"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: melody normalization supports legacy songIds and mirrors spellIds.",
        "Contract: index clamps safely and advanceAndSchedule always advances + schedules next cast."
      ]
    },
    "test.contractQuestsCommandHelpMentionsTurninListIndex": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_questsCommandHelpMentionsTurninListIndex.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: questsCommand help text mentions 'quest turnin list|ready' and index-based turn-in '<#|id|name>'.",
        "Prevents UX regressions where command help stops advertising key turn-in shortcuts."
      ]
    },
    "test.contractReloadSpawnsForcesHydration": {
      "kind": "test",
      "path": "worldcore/test/contract_reloadSpawnsForcesHydration.test.ts",
      "dependsOn": [
        "mud.commands.debug.reload",
        "world.spawnHydrator"
      ],
      "notes": [
        "Contract: 'reload spawns' must force SpawnHydrator.rehydrateRoom(force=true) for the current room/region.",
        "Prevents regressions where spawns only refresh indirectly via 'nearby' or movement."
      ]
    },
    "test.contractSongEngineMelodyThrowAdvance": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_songEngine_melodyAdvanceOnThrow.test.ts",
      "lifecycle": "test",
      "dependsOn": [
        "test.utils",
        "songs.engine"
      ],
      "notes": [
        "Contract: SongEngine must advance melody index and schedule next tick even if cast path throws.",
        "Prevents regressions where melody stalls due to exceptions."
      ]
    },
    "test.contractSongInstrumentGearBonus": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_songInstrumentGearBonus.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "mud.spells",
        "songs.songScaling",
        "items.catalog"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: equipped instrument bonus increases song healing deterministically (no RNG).",
        "Protects the instrument scaling seam so future refactors of MudSpells/SongScaling cannot silently drop gear bonuses."
      ]
    },
    "test.contractSongScaling": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_songScaling.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "songs.songScaling"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: song scalar math is deterministic (v0: 1 + skill/100).",
        "Contract: safe behavior when progression blob is missing."
      ]
    },
    "test.contractSpellBuffSelfStatusEffect": {
      "kind": "test",
      "path": "worldcore/test/contract_spellBuffSelfStatusEffect.test.ts",
      "class": "(test)",
      "lifecycle": "test",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: self buff status effect applies correctly"
      ]
    },
    "test.contractSpellBuffSingleAllyStatusEffect": {
      "kind": "test",
      "path": "worldcore/test/contract_spellBuffSingleAllyStatusEffect.test.ts",
      "class": "(test)",
      "lifecycle": "test",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: single ally buff status effect applies correctly"
      ]
    },
    "test.contractStatusEffects": {
      "kind": "test",
      "path": "worldcore/test/contract_statusEffects.test.ts",
      "class": "(test)",
      "lifecycle": "test",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: status effects apply/expire/stack invariants"
      ]
    },
    "test.contractTargetFindersNpc": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_targetFinders_npcSelection.test.ts",
      "lifecycle": "test",
      "dependsOn": [
        "test.utils",
        "targeting.finders"
      ],
      "notes": [
        "Contract: findNpcTargetByName provides stable ordering and supports index-only and name.# syntax."
      ]
    },
    "test.contractTargetFindersPlayer": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_targetFinders_playerSelection.test.ts",
      "lifecycle": "test",
      "dependsOn": [
        "test.utils",
        "targeting.finders"
      ],
      "notes": [
        "Contract: findTargetPlayerEntityByName resolves by session character name (case-insensitive) and requires same-room."
      ]
    },
    "test.contractTargetResolver": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_targetResolver_inRoomSelection.test.ts",
      "lifecycle": "test",
      "dependsOn": [
        "test.utils",
        "targeting.resolver"
      ],
      "notes": [
        "Contract: TargetResolver.resolveTargetInRoom supports index-only and name.# syntax.",
        "Contract: filter predicate is authoritative and selfId is excluded."
      ]
    },
    "test.contractTurnInQuestWarfrontFriendly": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_turnInQuestWarfrontFriendly.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: turnInQuest is warfront-friendly (list/ready + numeric index) and keeps legacy blank prompt.",
        "Prevents regressions where turn-in UX loses discoverability or stable ordering."
      ]
    },
    "test.contract_npcDebuffsAndDots": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_npcDebuffsAndDots.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "mud.spells",
        "spells.types",
        "combat.statusEffects",
        "combat.npc",
        "core.tickEngine"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: NPC debuffs + DOT vertical slice works end-to-end (cast → status apply → tick → damage).",
        "Guards the DOT tick + defender snapshot seam so damageTakenPct modifiers influence both direct hits and DOT ticks."
      ]
    },
    "test.contract_reloadSpawnsInvalidatesHydratorCache": {
      "kind": "test",
      "service": "test",
      "path": "worldcore/test/contract_reloadSpawnsInvalidatesHydratorCache.test.ts",
      "dependsOn": [
        "mud.commands.debug.reload",
        "dev.hotReloadService",
        "world.spawnHydrator"
      ],
      "provides": [
        "[contract] reload spawns invalidates SpawnHydrator hydration cache before POI rehydrate",
        "Asserts hot reload report includes SpawnHydrator=cleared"
      ],
      "notes": [
        "Guards against stale POI hydration when spawn_points change at runtime."
      ]
    },
    "test.contract_statusStackingPolicy_versionedByApplier": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_statusStackingPolicy_versionedByApplier.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "combat.statusEffects",
        "combat.statusStackingPolicy"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: versioned_by_applier stacks distinct versions by distinct appliers (cap enforced).",
        "Same applier upgrades their slot (no duplicate stacks). Same version does not stack; refresh/replace semantics are last-write-wins."
      ]
    },
    "test.contract_townQuestBoardAcceptAndAbandon": {
      "kind": "test",
      "service": "test",
      "path": "worldcore/test/contract_townQuestBoardAcceptAndAbandon.test.ts",
      "dependsOn": [
        "quests.TownQuestBoard",
        "quests.text",
        "mud.commands.progression.quests"
      ],
      "provides": [
        "[contract] town quest board accept adds quest to questlog",
        "[contract] quest abandon removes quest from questlog"
      ],
      "notes": [
        "Covers the minimal quest runtime loop: board -> accept -> questlog -> abandon."
      ]
    },
    "test.contract_townQuestGeneratorDeterminism": {
      "kind": "test",
      "service": "test",
      "path": "worldcore/test/contract_townQuestGeneratorDeterminism.test.ts",
      "dependsOn": [
        "quests.generator"
      ],
      "provides": [
        "[contract] town quest generator is deterministic for identical inputs",
        "[contract] different epoch changes output (seeded variance)"
      ],
      "notes": [
        "Guards reproducibility for generated quest sets so server restarts and tooling yield identical results."
      ]
    },
    "test.contract_townQuestGeneratorObjectivePool": {
      "kind": "test",
      "service": "test",
      "path": "worldcore/test/contract_townQuestGeneratorObjectivePool.test.ts",
      "dependsOn": [
        "quests.generator",
        "quests.types"
      ],
      "provides": [
        "[contract] generated quest objectives only use safe ids from the current content set",
        "[contract] generated quest ids are unique and town-prefixed"
      ],
      "notes": [
        "Prevents the generator from emitting impossible objectives until content pools expand intentionally."
      ]
    },
    "test.duelService": {
      "kind": "test",
      "path": "worldcore/test/duelService.test.ts",
      "dependsOn": [
        "combat.duelService",
        "core.sessions?",
        "core.entities?"
      ],
      "notes": [
        "Regression: duel lifecycle (challenge/accept/decline/yield) and state transitions."
      ]
    },
    "test.gapTableAuditLib": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/gapTableAuditLib.test.ts",
      "lifecycle": "test",
      "dependsOn": [
        "tools.gapTableAuditLib"
      ],
      "notes": [
        "Regression tests for SQL table-name extraction (CREATE/ALTER; ONLY; quoted identifiers)."
      ]
    },
    "test.pvpFriendlyFireGuild": {
      "kind": "test",
      "path": "worldcore/test/pvpFriendlyFireGuild.test.ts",
      "dependsOn": [
        "combat.pvpRules",
        "guilds.service?"
      ],
      "notes": [
        "Regression: friendly-fire prevention for same-guild participants when configured."
      ]
    },
    "test.pvpRules": {
      "kind": "test",
      "path": "worldcore/test/pvpRules.test.ts",
      "dependsOn": [
        "combat.pvpRules"
      ],
      "notes": [
        "Regression: PvP gating rules (duel vs open vs warfront) behave as expected.",
        "Foundation for future faction/party friendly-fire rules."
      ]
    },
    "test.regionDangerScalar": {
      "kind": "test",
      "path": "worldcore/test/regionDangerScalar.test.ts",
      "dependsOn": [
        "combat.regionDangerAuras",
        "world.regionDanger",
        "combat.statusEffects"
      ],
      "notes": [
        "Regression: region danger scalar influences the Region Peril aura / danger scaling behavior."
      ]
    },
    "test.skinningFallbackLoot": {
      "kind": "test",
      "path": "worldcore/test/skinningFallbackLoot.test.ts",
      "dependsOn": [
        "mud.actions.world"
      ],
      "notes": [
        "Smoke test for applyFallbackSkinLoot(protoId).",
        "Ensures starter skinning fallback returns hide_scraps with sane qty bounds."
      ]
    },
    "test.smokeChecklist": {
      "kind": "test",
      "path": "worldcore/test/smokeChecklist.test.ts",
      "dependsOn": [
        "test.utils",
        "combat.engine",
        "combat.statusEffects"
      ],
      "notes": [
        "High-level smoke checklist for combat math invariants.",
        "Catches regressions when CombatEngine / StatusEffects ordering changes."
      ]
    },
    "test.songEngineMelody": {
      "kind": "test",
      "path": "worldcore/test/SongEngine.melody.test.ts",
      "summary": "Contract tests for melody normalization + alias/duplicate safety in SongEngine.",
      "dependsOn": [
        "test.utils",
        "core.entityManager",
        "mud.context",
        "songs.songEngine",
        "characters.types"
      ],
      "notes": [
        "Ensures melody lists are normalized and stable.",
        "Protects against alias IDs and duplicates causing playlist inflation."
      ]
    },
    "test.statusDamageDealt": {
      "kind": "test",
      "path": "worldcore/test/statusDamageDealt.test.ts",
      "class": "(test)",
      "lifecycle": "test",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Status: outgoing damage modifiers"
      ]
    },
    "test.statusDamageDealtBySchool": {
      "kind": "test",
      "path": "worldcore/test/statusDamageDealtBySchool.test.ts",
      "dependsOn": [
        "test.utils",
        "combat.engine",
        "combat.statusEffects"
      ],
      "notes": [
        "Regression: outgoing per-school damage dealt modifiers apply only to matching school.",
        "Regression: stacks additively with global damageDealtPct."
      ]
    },
    "test.statusDamageTaken": {
      "kind": "test",
      "path": "worldcore/test/statusDamageTaken.test.ts",
      "class": "(test)",
      "lifecycle": "test",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Status: incoming damage modifiers"
      ]
    },
    "test.statusDamageTakenBySchool": {
      "kind": "test",
      "path": "worldcore/test/statusDamageTakenBySchool.test.ts",
      "dependsOn": [
        "test.utils",
        "combat.engine",
        "combat.statusEffects",
        "combat.mitigation",
        "combat.resists"
      ],
      "notes": [
        "Regression: incoming per-school damage taken modifiers apply only to matching school.",
        "Regression: stacks additively with global damageTakenPct.",
        "Verifies ordering remains: mitigation (armor/resist) then incoming multipliers."
      ]
    },
    "test.statusEffectsContract": {
      "kind": "test",
      "path": "worldcore/test/statusEffects.contract.test.ts",
      "class": "(test)",
      "lifecycle": "test",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: status effect snapshot math + modifiers"
      ]
    },
    "test.contract_nearbyHandles_resolution": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_nearbyHandles_resolution.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "mud.handles.nearbyHandles"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: nearby-handle snapshot prefers alive entities over corpses when distance ties (corpse should sort last).",
        "Contract: nearby-handle snapshot hides personal nodes owned by other sessions (no cross-player leakage)."
      ]
    },
    "test.contractDebugEffectsCommand": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_debugEffectsCommand.test.ts",
      "dependsOn": [
        "mud.commands.debug.debugEffectsCommand",
        "test.utils"
      ],
      "notes": [
        "Ensures debug_effects resolves nearby handles and can emit valid JSON."
      ]
    },
    "test.contract_statusEffects_clearOnDeath": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_statusEffects_clearOnDeath.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "combat.statusEffects"
      ],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: death clears combat status effects (DOTs, debuffs, etc.).",
        "Guards that corpses do not keep ticking DOTs, and ticking stops immediately when lethal DOT damage is applied."
      ]
    },
    "test.contractTargetResolverNearbyHandles": {
      "kind": "test",
      "path": "worldcore/test/contract_targetResolver_nearbyHandles.test.ts",
      "dependsOn": [
        "test.utils",
        "targeting.resolver",
        "mud.handles.nearbyHandles"
      ],
      "notes": [
        "Contract: TargetResolver resolves NPC targets consistently with NearbyHandles ordering (index '2' == snapshot index, handle 'rat.1' == same entity).",
        "Contract: exact entity id wins over index/handle/name matching."
      ]
    },
    "test.contractAttackNoSuchTargetMessage": {
      "kind": "test",
      "service": "test.contract",
      "path": "worldcore/test/contract_attack_noSuchTargetMessage.test.ts",
      "class": null,
      "lifecycle": "test",
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "mud.handler",
        "mud.commands.combat.attack",
        "mud.actions.combat",
        "targeting.resolver"
      ],
      "provides": [],
      "notes": [
        "Contract: attack invalid target token emits standardized message: [world] No such target: '<token>'."
      ]
    },
    "test.utils": {
      "kind": "test_utility",
      "path": "worldcore/test/testUtils.ts",
      "functions": [
        "withRandomSequence",
        "/* other deterministic RNG helpers */"
      ],
      "dependsOn": [],
      "notes": [
        "Shared helpers for deterministic Math.random sequences in tests.",
        "Used by smokeChecklist and damage-by-school regression tests."
      ]
    },
    "tools.applySchema": {
      "kind": "service",
      "path": "worldcore/tools/applySchema.ts",
      "class": "ToolScript",
      "lifecycle": "tool",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts",
        "utils.logger"
      ],
      "provides": [
        "Applies SQL files under worldcore/infra/schema in numeric order",
        "Tracks applied migrations in schema_migrations",
        "Supports --dry-run"
      ],
      "owns": [
        "Migration ordering",
        "Idempotency tracking",
        "Safe logging + failure visibility"
      ],
      "notes": [
        "This tool is required now that DB-backed recipes are authoritative.",
        "Without a runner, new schema/seed files rely on manual psql execution."
      ]
    },
    "tools.auditNpcLawTags": {
      "kind": "service",
      "path": "worldcore/tools/auditNpcLawTags.ts",
      "class": "ToolScript",
      "lifecycle": "tool",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts",
        "utils.logger"
      ],
      "provides": [
        "audits + optionally cleans npcs.tags law/protection contradictions",
        "Supports --dry-run"
      ],
      "owns": [],
      "notes": []
    },
    "tools.gapTableAudit": {
      "kind": "tool",
      "path": "worldcore/tools/gapTableAudit.ts",
      "bin": "dist/worldcore/tools/gapTableAudit.js",
      "dependsOn": [
        "tools.gapTableAuditLib"
      ],
      "notes": [
        "Milestone B: compares expected tables (migrations) vs existing tables (schema dump).",
        "Outputs missing/orphan tables; supports --json and --strict."
      ]
    },
    "tools.gapTableAuditLib": {
      "kind": "helper",
      "path": "worldcore/tools/gapTableAuditLib.ts",
      "functions": [
        "stripSqlComments",
        "extractTableRefsFromSql",
        "extractTableNamesFromSql"
      ],
      "dependsOn": [],
      "notes": [
        "Milestone B: heuristic SQL table-name extraction for CREATE/ALTER statements.",
        "Used by gapTableAudit tool and its unit tests."
      ]
    },
    "tools.resourceBaseline": {
      "kind": "dev_script",
      "path": "worldcore/tools/resourceBaseline.ts",
      "dependsOn": [
        "db.main",
        "world.spawnPoints",
        "worldgen.v2.resources"
      ],
      "provides": [
        "plan/commit: deterministic baseline resource spawn_points (ore/herb/wood/fish/rare) within --bounds",
        "dry-run preview: prints planned inserts/updates with seed + density controls (use --commit to write)",
        "audit mode: summarize resource node coverage by bounds / proto kinds"
      ],
      "notes": [
        "Baseline seeding tool for v1 gathering; complements tools.simBrain town-baseline + coverage workflows.",
        "Writes to spawn_points (authoritative spawn metadata). Safe by default (dry-run) unless --commit.",
        "Keep seed inputs stable for reproducible dev environments and deterministic tests."
      ]
    },
    "tools.simBrain": {
      "kind": "dev_script",
      "path": "worldcore/tools/simBrain.ts",
      "dependsOn": [
        "db.Database",
        "infra.schema",
        "sim.SimWorld",
        "sim.SimGrid",
        "sim.SimRng",
        "sim.BrainActions",
        "sim.townBaselinePlanner",
        "sim.motherBrainWavePlanner",
        "world.spawnPointService",
        "world.spawnHydrator"
      ],
      "provides": [
        "preview/apply: deterministic outpost planning (dry-run vs --commit)",
        "report/status: respawn coverage audit across bounds (status supports --topGaps)",
        "fill-gaps: place checkpoints/graveyards to patch coverage gaps (dry-run vs --commit)",
        "era: orchestrated outposts + gapfill run with safe-mode caps + artifact output",
        "mother-wave: plan/apply deterministic Mother Brain wave (dry-run vs --commit), with --append/--theme/--epoch controls",
        "mother-status: summarize Mother Brain (brain-owned) spawn_points within bounds (optionally list)",
        "trim-outposts: enforce per-faction cap by deleting extras within bounds",
        "snapshot-spawns/restore-spawns: export + reapply spawn_points slices",
        "wipe-placements: delete spawn_points of selected types within bounds",
        "town-baseline command: seed town/outpost baseline spawn_points (mailbox/rest/guards) into spawn_points table",
        "CLI: town-baseline",
        "CLI: mother-status",
        "CLI: mother-wave",
        "Flag: --stations",
        "Flag: --respectTierStations / --tierStations",
        "Flag: --townTier <1..5>",
        "DB seeding: town services + stations + guards + dummies"
      ],
      "owns": [
        "artifacts/brain/*"
      ],
      "notes": [
        "Dev Simulation Harness CLI entrypoint.",
        "Includes Mother Brain wave planning commands (mother-wave/mother-status) for brain-owned spawn_points pipelines.",
        "Follows audit → plan → apply pattern with safe default rollback unless --commit.",
        "Safety rails: refuses literal '...' arg; refuses --commit without explicit --bounds (unless --allowDefaultBounds).",
        "Artifacts are dev-only outputs; keep them gitignored."
      ]
    },
    "trade.auditLog": {
      "kind": "service",
      "path": "worldcore/trade/TradeAuditLog.ts",
      "functions": [
        "logCompletedTrade"
      ],
      "dependsOn": [
        "db.main",
        "utils.logger",
        "trade.types"
      ],
      "notes": [
        "Persists completed trades into trade_log table including gold before/after and JSON-encoded item lists.",
        "Errors are caught and logged without breaking the trade flow."
      ]
    },
    "trade.memory": {
      "kind": "service",
      "path": "worldcore/trade/InMemoryTradeService.ts",
      "class": "InMemoryTradeService",
      "dependsOn": [
        "auth.types",
        "trade.types",
        "trade.service"
      ],
      "notes": [
        "In-memory implementation of TradeService using Maps keyed by session id and character id.",
        "Supports one active trade per character and manages status transitions including both_confirmed."
      ]
    },
    "trade.ops": {
      "kind": "utility",
      "path": "worldcore/trade/tradeOps.ts",
      "functions": [
        "formatTradeSessionView",
        "finalizeTrade"
      ],
      "dependsOn": [
        "trade.types",
        "trade.auditLog",
        "characters.types",
        "items.inventoryHelpers",
        "economy.helpers"
      ],
      "notes": [
        "Pure trade finalization logic operating on inventories and gold amounts.",
        "Validates that offered items and gold still exist, moves items between inventories, updates gold, logs the trade, notifies both sessions, and marks the session as completed."
      ]
    },
    "trade.service": {
      "kind": "service_contract",
      "path": "worldcore/trade/TradeService.ts",
      "notes": [
        "TradeService interface: createSession, getSessionFor, cancelFor, clearOffers, setOfferGold, addOfferItem, setAccepted.",
        "Implemented by InMemoryTradeService and used by trade commands."
      ]
    },
    "trade.types": {
      "kind": "model",
      "path": "worldcore/trade/TradeTypes.ts",
      "notes": [
        "Defines TradeStatus, TradeItemOffer, TradeSide, and TradeSession.",
        "Shared between trade service, audit log, and tradeOps."
      ]
    },
    "tradeskills.recipes": {
      "kind": "service",
      "path": "worldcore/tradeskills/RecipeCatalog.ts",
      "functions": [
        "listAllRecipes",
        "getRecipe",
        "findRecipeByIdOrName"
      ],
      "dependsOn": [
        "tradeskills.types"
      ],
      "notes": [
        "Static v1 recipe catalog for smelting and alchemy test recipes (e.g., smelt_iron_ingot, brew_minor_heal).",
        "Provides lookup helpers by id and by case-insensitive name."
      ]
    },
    "tradeskills.recipes.db": {
      "kind": "service",
      "path": "worldcore/tradeskills/TradeRecipeService.ts",
      "class": "TradeRecipeService",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [
        "tradeskills.types",
        "tradeskills.recipes",
        "worldcore/db/Database.ts",
        "utils.logger"
      ],
      "provides": [
        "ensureLoaded()",
        "listAll()",
        "get(id)",
        "findByIdOrName(token)",
        "hasDbRecipes()",
        "getTradeRecipeService()"
      ],
      "owns": [
        "DB-first recipe resolution (trade_recipes / trade_recipe_inputs / trade_recipe_outputs)",
        "Static fallback merge with RecipeCatalog during migration",
        "In-memory cache of merged recipes"
      ],
      "notes": [
        "DB-backed recipe service (authoritative).",
        "Safely falls back to static RecipeCatalog while DB tables or rows are missing.",
        "Designed for incremental migration: DB overrides code; code fills gaps."
      ]
    },
    "tradeskills.types": {
      "kind": "model",
      "path": "worldcore/tradeskills/RecipeTypes.ts",
      "notes": [
        "Defines TradeskillCategory, RecipeIngredient, RecipeOutput, TradeRecipe, and RecipeMap.",
        "Used by RecipeCatalog and crafting commands."
      ]
    },
    "types.shims": {
      "kind": "types",
      "path": "worldcore/types/shims.d.ts",
      "notes": [
        "Ambient declarations for Node/third-party modules (uuid, ws, pg, redis, dotenv, jsonwebtoken, crypto, node:test, assert).",
        "Also declares process, console, timers, and NodeJS.Timeout so TS can compile in bare JS runtimes."
      ]
    },
    "utils.colors": {
      "kind": "utility",
      "path": "worldcore/utils/colors.ts",
      "exports": [
        "Colors",
        "colorize"
      ],
      "dependsOn": [],
      "notes": [
        "ANSI color codes and colorize(text,color) helper for Node console output.",
        "Used by the logger and can be reused by any CLI tools."
      ]
    },
    "utils.logger": {
      "kind": "utility",
      "path": "worldcore/utils/logger.ts",
      "class": "Logger",
      "dependsOn": [
        "utils.colors",
        "config.logconfig"
      ],
      "notes": [
        "Scope-based logger with timestamp, level coloring, and logEnabled(scope,level) filtering.",
        "Provides debug/info/warn/error/success methods and a static scope(scope) factory."
      ]
    },
    "utils.random": {
      "kind": "utility",
      "path": "worldcore/utils/random.ts",
      "functions": [
        "rollInt"
      ],
      "dependsOn": [
        "utils.logger"
      ],
      "notes": [
        "Simple random integer helper: rollInt(min,max) using Math.random().",
        "Keeps a scoped logger for future debugging, though current implementation does not log."
      ]
    },
    "utils.rng": {
      "kind": "utility",
      "path": "worldcore/utils/Rng.ts",
      "class": "Rng",
      "dependsOn": [],
      "notes": [
        "Deterministic RNG based on a hashed seed (mulberry32-style).",
        "Provides next(), range(min,max), int(min,maxInclusive), and pick(list)."
      ]
    },
    "utils.uuid": {
      "kind": "utility",
      "path": "worldcore/utils/uuid.ts",
      "functions": [
        "uuidv4"
      ],
      "dependsOn": [],
      "notes": [
        "Wrapper around crypto.randomUUID() with a fallback fixed v4-like UUID if unavailable.",
        "Used anywhere a stable UUIDv4 string is needed without pulling extra deps."
      ]
    },
    "vendors.postgres": {
      "kind": "service",
      "path": "worldcore/vendors/PostgresVendorService.ts",
      "class": "PostgresVendorService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "vendors.types",
        "vendors.service"
      ],
      "notes": [
        "Postgres-backed implementation of VendorService.",
        "Queries vendors and vendor_items tables and maps rows to VendorDefinition and VendorItem."
      ]
    },
    "vendors.service": {
      "kind": "service_contract",
      "path": "worldcore/vendors/VendorService.ts",
      "notes": [
        "VendorService interface: getVendor(id) and listVendors().",
        "Implemented by PostgresVendorService and used by vendor commands."
      ]
    },
    "vendors.transactions": {
      "kind": "utility",
      "path": "worldcore/vendors/VendorTransactions.ts",
      "functions": [
        "resolveVendorItem",
        "buyFromVendor",
        "sellToVendor"
      ],
      "dependsOn": [
        "characters.types",
        "economy.helpers",
        "vendors.types"
      ],
      "notes": [
        "Pure transaction logic for buying and selling with vendors.",
        "buyFromVendor checks gold, tries to add items, then spends gold only for successfully added quantity.",
        "sellToVendor finds vendor price reference and pays 50% per unit, consuming items atomically.",
        "Sell/Buy rules live here"
      ]
    },
    "vendors.types": {
      "kind": "model",
      "path": "worldcore/vendors/VendorTypes.ts",
      "notes": [
        "Defines VendorItem (id,itemId,priceGold) and VendorDefinition (id,name,items).",
        "Shared shape for vendor services, economy helpers, and MUD commands."
      ]
    },
    "world.boundary": {
      "kind": "utility",
      "path": "worldcore/world/Boundary.ts",
      "class": "DomeBoundary",
      "lifecycle": "factory",
      "ctorArgs": [
        "centerX",
        "centerZ",
        "radius",
        "softRadius"
      ],
      "dependsOn": [],
      "provides": [
        "isInside(x, z)",
        "clampPosition(x, z) -> { x, z, clamped, distance }",
        "falloff(x, z) -> 0..1",
        "toState()",
        "fromState(DomeBoundaryState)"
      ],
      "notes": [
        "Pure math helper for circular play-area checks and soft edges.",
        "Currently not wired into ServerWorldManager; kept as reusable utility."
      ]
    },
    "world.events": {
      "kind": "service",
      "path": "worldcore/world/WorldEventBus.ts",
      "class": "WorldEventBus",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [],
      "provides": [
        "on(event, handler)",
        "off(event, handler)",
        "emit(event, payload)",
        "emitAsync(event, payload)",
        "clear()"
      ],
      "eventDomain": "world",
      "events": [
        "entity.spawned",
        "entity.despawned",
        "entity.moved",
        "region.changed",
        "room.entered",
        "room.exited",
        "npc.aggressed",
        "npc.died",
        "player.connected",
        "player.disconnected",
        "law.crime",
        "weather.changed"
      ],
      "notes": [
        "Typed pub/sub bus for world-layer events.",
        "Goal: future systems (AI, law, weather, crime) hang off this instead of directly calling each other."
      ]
    },
    "world.manager": {
      "kind": "service",
      "path": "worldcore/world/ServerWorldManager.ts",
      "class": "ServerWorldManager",
      "lifecycle": "singleton",
      "ctorArgs": [
        "seed?"
      ],
      "dependsOn": [
        "spells.types",
        "db.Database"
      ],
      "provides": [
        "getWorldBlueprintForRoom(roomId)",
        "getWorldBlueprint()",
        "getHeightmap()",
        "getRegionMap()",
        "getRegionAt(x, z)",
        "isInsideWorld(x, z)"
      ],
      "notes": [
        "Owns Heightmap + RegionMap for the prime shard.",
        "Builds a WorldBlueprint via ScaledWorldgen.",
        "Implements WorldBlueprintProvider for RoomManager."
      ]
    },
    "world.navGrid": {
      "kind": "service",
      "path": "worldcore/world/NavGridManager.ts",
      "class": "NavGridManager",
      "lifecycle": "singleton",
      "ctorArgs": [
        "world.manager"
      ],
      "dependsOn": [
        "world.manager"
      ],
      "provides": [
        "init()"
      ],
      "notes": [
        "Stub v1; just logs init.",
        "Intended to own navmesh/pathing data keyed off ServerWorldManager."
      ]
    },
    "world.query": {
      "kind": "service",
      "path": "worldcore/world/WorldQueryService.ts",
      "class": "WorldQueryService",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [
        "db.main"
      ],
      "provides": [
        "look(shardId, regionId)",
        "inspectRegion(shardId, regionId)"
      ],
      "notes": [
        "DB-only read model: useful for admin tools, MUD look/inspect, etc.",
        "Does not mutate world state."
      ]
    },
    "world.regionDanger": {
      "kind": "utility",
      "path": "worldcore/world/RegionDanger.ts",
      "functions": [
        "getRegionDangerForRegionId(regionId, nowMs?)",
        "getRegionDangerSnapshotForRegionId(regionId, nowMs?)",
        "getRegionDangerForCharacter(char, nowMs?)",
        "bumpRegionDanger(regionId, delta, source, nowMs?)",
        "setRegionDangerScore(regionId, score, source, nowMs?)"
      ],
      "dependsOn": [
        "characters.types"
      ],
      "notes": [
        "Tracks per-region dynamic danger score and effective tier (1–5) based on base distance ring + recent activity.",
        "Applies exponential-style decay over time so regions cool down naturally.",
        "Used by cowardice, Region Peril aura, debug_region_danger, and debug_bump_region_danger."
      ]
    },
    "world.regionFlags": {
      "kind": "service",
      "path": "worldcore/world/RegionFlags.ts",
      "functions": [
        "normalizeRegionIdForDb",
        "getRegionFlags",
        "isPvpEnabledForRegion",
        "isCombatEnabledForRegion",
        "isEventEnabledForRegion",
        "getDangerScalarForRegion",
        "clearRegionFlagsCache",
        "setRegionFlagsTestOverrides(overrides | null)"
      ],
      "dependsOn": [
        "characters.types",
        "characters.db",
        "utils.logger"
      ],
      "notes": [
        "DB-backed region flags lookup (jsonb) with cache.",
        "combatEnabled defaults to true when unset; safe hubs can set combatEnabled=false."
      ]
    },
    "world.regions": {
      "kind": "service",
      "path": "worldcore/world/RegionManager.ts",
      "class": "RegionManager",
      "lifecycle": "singleton",
      "ctorArgs": [
        "core.entities",
        "core.rooms",
        "world.respawns?",
        "mmo.shardService?"
      ],
      "dependsOn": [
        "core.entities",
        "core.rooms",
        "world.respawns?",
        "mmo.shardService?"
      ],
      "provides": [
        "initialize(regions: RegionDefinition[])",
        "getRegion(id)",
        "getAllRegions()",
        "assignEntityToRegion(entityId, regionId)",
        "handleEntityTransfer(entityId, fromRoomId, toRoomId)",
        "findRegionByRoom(roomId)",
        "getRespawnPoint(regionId)",
        "handleRespawnRequest(entityId)",
        "registerShardLink(shardService)",
        "getShardForRegion(regionId)"
      ],
      "notes": [
        "Authoritative registry of regions and their room ownership.",
        "Bridges entity/room world-space with MMO concepts like shards and respawns."
      ]
    },
    "world.respawns": {
      "kind": "service",
      "path": "worldcore/world/RespawnService.ts",
      "class": "RespawnService",
      "lifecycle": "singleton",
      "ctorArgs": [
        "world.manager",
        "world.spawnPoints",
        "world.characters",
        "core.entities"
      ],
      "dependsOn": [
        "world.manager",
        "world.spawnPoints",
        "world.characters",
        "core.entities"
      ],
      "provides": [
        "respawnCharacter(session, char)",
        "/* internal */ pickSpawnPointFor(char)"
      ],
      "notes": [
        "Central respawn logic: chooses spawn, heals entity, saves CharacterState.",
        "v3 behavior: respawn prefers a closer eligible settlement spawn over a graveyard; otherwise uses nearest graveyard (then nearest any).",
        "Settlement eligibility placeholder: variantId 'kos' or 'hostile' makes a settlement ineligible."
      ]
    },
    "world.services": {
      "kind": "composition_root",
      "path": "worldcore/world/WorldServices.ts",
      "factory": "createWorldServices",
      "lifecycle": "per-shard",
      "dependsOn": [
        "world.events",
        "core.sessions",
        "core.entities",
        "core.rooms",
        "world.manager",
        "world.regions",
        "world.spawns",
        "world.respawns",
        "world.navGrid",
        "world.boundary?",
        "world.spawnPoints",
        "world.query?",
        "world.navGrid?",
        "core.movement",
        "core.combat",
        "core.objectStream",
        "core.terrainStream",
        "core.tickEngine",
        "npc.manager?"
      ],
      "notes": [
        "Intended to construct and wire all world + core services for a shard.",
        "Current implementation in codebase has mismatched constructor calls; registry should be treated as the target shape for the eventual fixed WorldServices.ts."
      ]
    },
    "world.spawnAuthority": {
      "kind": "module",
      "service": "world",
      "path": "worldcore/world/spawnAuthority.ts",
      "class": "(module) spawnAuthority",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [],
      "provides": [
        "SpawnAuthority: anchor|seed|brain|manual",
        "getSpawnAuthority(spawnId): infer authority from spawnId prefix",
        "isSpawnEditable(spawnId): false for brain-owned points",
        "isSpawnAnchor/isSpawnSeed/isSpawnBrain helpers"
      ],
      "owns": []
    },
    "world.spawnHydrator": {
      "kind": "service",
      "service": "world",
      "path": "worldcore/world/SpawnHydrator.ts",
      "class": "SpawnHydrator",
      "lifecycle": "singleton",
      "ctorArgs": [
        "spawnPoints",
        "entities"
      ],
      "dependsOn": [
        "core.entities",
        "world.spawnPoints",
        "world.townBaselines"
      ],
      "provides": [
        "SpawnHydrator.invalidateAll(): clears per-region hydration cache (for hot reload + tests)",
        "SpawnHydrator.invalidateRegion(shardId, regionId): clears hydration cache for a single region",
        "SpawnHydrator.rehydrateRoom({ shardId, regionId, roomId, force?, dryRun? }): materializes POI-like spawn_points into inert entities (never mobs/resources)",
        "Respects WORLD_SPAWNS_ENABLED and WORLD_SPAWNS_TYPES; optional town baselines via PW_TOWN_BASELINES / WORLD_TOWN_BASELINES"
      ],
      "owns": [],
      "notes": [
        "Caches hydration per (shardId, regionId) to avoid redundant DB reads; invalidate* clears that cache only (no despawns)."
      ]
    },
    "world.spawnPointCache": {
      "kind": "module",
      "service": "world",
      "path": "worldcore/world/SpawnPointCache.ts",
      "class": "(module) SpawnPointCache",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [
        "world.spawnPoints"
      ],
      "provides": [
        "upsertSpawnPoint(p): cache/refresh a single DbSpawnPoint row",
        "upsertSpawnPoints(points): batch cache refresh",
        "getSpawnPoint(spawnPointId): read cached entry",
        "setSpawnPointCoords(spawnPointId, coords): dev/test override of cached coords",
        "clearSpawnPointCache(): drop all cached entries"
      ],
      "owns": []
    },
    "world.spawnPoints": {
      "kind": "service",
      "path": "worldcore/world/SpawnPointService.ts",
      "class": "SpawnPointService",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [
        "db.main"
      ],
      "provides": [
        "DbSpawnPoint",
        "SpawnPointRow",
        "SpawnPointService.getSpawnPointsInBounds",
        "SpawnPointService.getSpawnPointsNear",
        "SpawnPointService.getSpawnPointsForRegion"
      ],
      "notes": [
        "Reads spawn_points from Postgres with test-safe lazy DB import.",
        "Now also reads spawn_points.town_tier into DbSpawnPoint.townTier for town-tier aware planning."
      ]
    },
    "world.spawns": {
      "kind": "service",
      "path": "worldcore/world/SpawnService.ts",
      "class": "SpawnService",
      "lifecycle": "singleton",
      "ctorArgs": [
        "core.entities",
        "core.rooms",
        "world.regions?",
        "world.respawns?"
      ],
      "dependsOn": [
        "core.entities",
        "core.rooms",
        "world.regions?",
        "world.respawns?"
      ],
      "provides": [
        "spawnEntity(SpawnOptions)",
        "despawnEntity(DespawnOptions)"
      ],
      "notes": [
        "Controls spawning and despawning of entities with optional region + respawn integration.",
        "Some called methods (createEntity, unregister, placeEntityInRoom, removeEntityFromRoom) are aspirational and will need to be aligned with EntityManager/RoomManager."
      ]
    },
    "world.storage": {
      "kind": "service",
      "path": "worldcore/world/ServerWorldStorage.ts",
      "class": "ServerWorldStorage",
      "lifecycle": "per-shard",
      "ctorArgs": [
        "shardId",
        "db.shardStorage",
        "worldGeneratorFn",
        "options?"
      ],
      "dependsOn": [
        "db.shardStorage"
      ],
      "provides": [
        "loadOrGenerate()"
      ],
      "notes": [
        "Bridges worldgen pipeline and shard storage.",
        "Not currently invoked in the runtime core; used when building/loading shards."
      ]
    },
    "world.townBaselines": {
      "kind": "module",
      "service": "world",
      "path": "worldcore/world/TownBaselines.ts",
      "class": "TownBaselines",
      "lifecycle": "singleton",
      "ctorArgs": [
        "entities"
      ],
      "dependsOn": [
        "core.entities"
      ],
      "provides": [
        "ensureTownBaseline(spawnPoint, roomId): ensures service anchors exist around town-like POIs (runtime fallback)"
      ],
      "owns": []
    },
    "world.townTierRules": {
      "kind": "module",
      "service": "world",
      "path": "worldcore/world/TownTierRules.ts",
      "class": "(functions)",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [
        "world.spawnPoints"
      ],
      "provides": [
        "TownTierId",
        "TownServiceId",
        "TownStationProtoId",
        "getTownTierRule(tier)",
        "getServicesForTier(tier)",
        "getStationProtoIdsForTier(tier)",
        "tryInferTownTierFromSpawn(spawn)",
        "inferTownTierFromSpawn(spawn)",
        "getServicesForTownSpawn(spawn)",
        "getStationProtoIdsForTownSpawn(spawn)"
      ],
      "owns": [],
      "notes": [
        "Centralized design-time rules for town tiers and which service anchors each tier should provide.",
        "Tier 1 = rest + mailbox + guards (current baseline). Higher tiers add vendor / bank / auction / guildbank once service gating is wired."
      ]
    },
    "worldcore/data/items/ItemDatabase.ts": {
      "kind": "data_table",
      "path": "worldcore/data/items/ItemDatabase.ts",
      "class": "ItemDatabase",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/data/items/ItemTypes.ts"
      ],
      "provides": [
        "ItemDatabase"
      ],
      "owns": [],
      "notes": [
        "Shared in-memory item database for basic herbs, ores, lumber, tools and magical resources; used for drops, rewards and simple inventories across MMO, webend and MUD."
      ]
    },
    "worldcore/data/items/ItemTypes.ts": {
      "kind": "types",
      "path": "worldcore/data/items/ItemTypes.ts",
      "class": "(exports)",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [],
      "provides": [
        "ItemCategory",
        "ItemRarity",
        "ResourceTag",
        "ItemDef"
      ],
      "owns": [],
      "notes": [
        "Canonical item model (categories, rarities, resource tags, base ItemDef) shared across all frontends and backends."
      ]
    },
    "worldcore/db/ChunkCache.ts": {
      "kind": "service",
      "path": "worldcore/db/ChunkCache.ts",
      "class": "(exports)",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts",
        "worldcore/utils/logger.ts"
      ],
      "provides": [
        "ChunkPayload",
        "ChunkCacheOptions",
        "ChunkCache"
      ],
      "owns": [],
      "notes": [
        "Redis-backed generic chunk cache used by future terrain/worldgen streaming (WGEv3, TerrainStream v3) to store arbitrary per-chunk payloads."
      ]
    },
    "worldcore/db/Database.ts": {
      "kind": "infra",
      "path": "worldcore/db/Database.ts",
      "class": "(exports)",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [
        "pg",
        "redis",
        "dotenv",
        "worldcore/utils/logger.ts"
      ],
      "provides": [
        "db",
        "redis",
        "testDbConnection",
        "ensureRedisConnected"
      ],
      "owns": [],
      "notes": [
        "Central Postgres and Redis connection layer with pooled DB access and lazy Redis connection; currently parked for when shard storage and other DB-backed systems go live."
      ]
    },
    "worldcore/db/ShardStorage.ts": {
      "kind": "service",
      "path": "worldcore/db/ShardStorage.ts",
      "class": "ShardStorage",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts",
        "worldcore/utils/logger.ts",
        "worldcore/shards/WorldBlueprint.ts"
      ],
      "provides": [
        "ShardStorage"
      ],
      "owns": [],
      "notes": [
        "Shard-level persistence helper for loading world blueprints (boundary, regions, objects, spawns) from the shards table into WorldBlueprint structures."
      ]
    },
    "worldcore/economy/EconomyHelpers.ts": {
      "kind": "helpers",
      "path": "worldcore/economy/EconomyHelpers.ts",
      "class": "(exports)",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/characters/CharacterTypes.ts",
        "worldcore/items/InventoryHelpers.ts"
      ],
      "provides": [
        "SimpleItemStack",
        "ItemApplyResult",
        "getCharacterInventory",
        "getCharacterGold",
        "setCharacterGold",
        "giveGold",
        "trySpendGold",
        "removeItemQuantityFromInventory",
        "addItemQuantityToInventory",
        "giveItemsToCharacter",
        "takeItemsFromCharacter",
        "tryConsumeItems",
        "tryPayCost",
        "grantReward"
      ],
      "owns": [],
      "notes": [
        "High-level gold and item helpers for characters: give/take gold, add/remove item quantities, cost checks and reward application for shops, quests and other systems."
      ]
    },
    "worldcore/factions/FactionTypes.ts": {
      "kind": "types",
      "path": "worldcore/factions/FactionTypes.ts",
      "class": "(exports)",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [],
      "provides": [
        "FactionId",
        "Faction",
        "getFactionById",
        "getAllFactions"
      ],
      "owns": [],
      "notes": [
        "Basic faction model and temporary in-memory faction registry (including test_empire) for early region control, naming and UI tests."
      ]
    },
    "worldcore/gathering/GatherTables.ts": {
      "kind": "data_table",
      "path": "worldcore/gathering/GatherTables.ts",
      "class": "(exports)",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [],
      "provides": [
        "ResourceDrop",
        "HERB_TABLES"
      ],
      "owns": [],
      "notes": [
        "Weighted herb drop tables keyed by biome+tier (e.g. plains:1, plains:3, plains:5) used by gathering nodes to roll what items a harvest yields."
      ]
    },
    "worldcore/guilds/GuildService.ts": {
      "kind": "service",
      "path": "worldcore/guilds/GuildService.ts",
      "class": "GuildService",
      "lifecycle": "singleton",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "provides": [
        "GuildService"
      ],
      "owns": [],
      "notes": [
        "DB-backed guild service for resolving a character's guild and listing guild members with rank and basic character info."
      ]
    },
    "worldcore/index.ts": {
      "kind": "barrel",
      "path": "worldcore/index.ts",
      "class": "(exports)",
      "lifecycle": "static",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/config/config",
        "worldcore/config/logconfig",
        "worldcore/config/worldscale",
        "worldcore/shards/WorldBlueprint.ts",
        "worldcore/shared/region.ts",
        "worldcore/terrain/index.ts",
        "worldcore/terrain/worldgen/ScaledWorldgen.ts"
      ],
      "provides": [
        "config/config",
        "config/logconfig",
        "config/worldscale",
        "shards/WorldBlueprint",
        "shared/region",
        "terrain",
        "terrain/worldgen/ScaledWorldgen"
      ],
      "owns": [],
      "notes": [
        "Root worldcore barrel that re-exports config, shard blueprints, shared region types and terrain/worldgen entrypoints as a stable public API."
      ]
    },
    "worldgen.scaled": {
      "kind": "worldgen_factory",
      "path": "worldcore/terrain/worldgen/ScaledWorldgen.ts",
      "function": "buildWorldBlueprint",
      "dependsOn": [],
      "provides": [
        "buildWorldBlueprint(input:ShardWorldInput):WorldBlueprint"
      ],
      "notes": [
        "Ultra-light v1 worldgen: creates a dome boundary and a default spawn for a shard.",
        "Used directly by ServerWorldManager to build the prime shard blueprint."
      ]
    },
    "worldgen.v2.biomes": {
      "kind": "worldgen_stage",
      "path": "worldcore/terrain/worldgen/WGEv2Biomes.ts",
      "class": "WGEv2BiomesStage",
      "lifecycle": "stateless",
      "dependsOn": [
        "worldgen.v2.landforms",
        "worldgen.v2.erosion",
        "worldgen.v2.climate"
      ],
      "provides": [
        "run(input:BiomeInput, ctx?:WorldGenContext):BiomeResult"
      ],
      "notes": [
        "Stage 2.3.4 – biome assignment per cell + connected biome clusters.",
        "Outputs biomeMap + cluster IDs + counts per biome."
      ]
    },
    "worldgen.v2.civilization": {
      "kind": "worldgen_stage",
      "path": "worldcore/terrain/worldgen/WGEv2Civilization.ts",
      "class": "WGEv2CivilizationStage",
      "lifecycle": "stateless",
      "dependsOn": [
        "worldgen.v2.landforms",
        "worldgen.v2.erosion",
        "worldgen.v2.climate",
        "worldgen.v2.biomes"
      ],
      "provides": [
        "run(input:CivilizationInput, ctx?:WorldGenContext):CivilizationResult"
      ],
      "notes": [
        "Stage 2.3.5 – settlements, roads, and POIs.",
        "Scores candidate cells, picks settlements with spacing, builds a road graph, scatters points of interest."
      ]
    },
    "worldgen.v2.climate": {
      "kind": "worldgen_stage",
      "path": "worldcore/terrain/worldgen/WGEv2Climate.ts",
      "class": "WGEv2ClimateStage",
      "lifecycle": "stateless",
      "dependsOn": [
        "worldgen.v2.landforms",
        "worldgen.v2.erosion?"
      ],
      "provides": [
        "run(input:ClimateInput, ctx?:WorldGenContext):ClimateResult"
      ],
      "notes": [
        "Stage 2.3.3 – temperature, moisture, and compact climate zones.",
        "Can optionally use erosion outputs to bias humidity near rivers/lakes."
      ]
    },
    "worldgen.v2.erosion": {
      "kind": "worldgen_stage",
      "path": "worldcore/terrain/worldgen/WGEv2Erosion.ts",
      "class": "WGEv2ErosionStage",
      "lifecycle": "stateless",
      "dependsOn": [
        "worldgen.v2.landforms"
      ],
      "provides": [
        "run(input:{ landforms:LandformResult, params?:ErosionParams }, ctx?:WorldGenContext):ErosionResult"
      ],
      "notes": [
        "Stage 2.3.2 – hydrology, erosion, rivers, lakes.",
        "Outputs updated elevation, water, sediment, flow dirs, river/lake masks."
      ]
    },
    "worldgen.v2.landforms": {
      "kind": "worldgen_stage",
      "path": "worldcore/terrain/worldgen/WGEv2Landforms.ts",
      "class": "WGEv2LandformsStage",
      "lifecycle": "stateless",
      "dependsOn": [],
      "provides": [
        "run(input:ShardSeedInput, ctx?:WorldGenContext):LandformResult"
      ],
      "notes": [
        "Stage 2.3.1 – base landforms: tectonics, continents, uplift, macro elevation.",
        "First stage in the WGEv2 pipeline; everything else builds on its LandformResult."
      ]
    },
    "worldgen.v2.resources": {
      "kind": "worldgen_stage",
      "path": "worldcore/terrain/worldgen/WGEv2Resources.ts",
      "class": "WGEv2ResourcesStage",
      "lifecycle": "stateless",
      "dependsOn": [
        "worldgen.v2.landforms",
        "worldgen.v2.erosion",
        "worldgen.v2.climate",
        "worldgen.v2.biomes",
        "worldgen.v2.civilization"
      ],
      "provides": [
        "run(input:ResourceInput, ctx?:WorldGenContext):ResourceResult"
      ],
      "notes": [
        "Stage 2.3.6 – resource node placement (ore/herb/wood/fish/rare) plus per-kind masks.",
        "Respects biome, elevation, climate, hydrology, and avoids city centers while tagging 'near settlement' nodes."
      ]
    }
  }
}
