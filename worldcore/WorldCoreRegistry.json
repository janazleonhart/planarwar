{
  "services": {
    "abilities.learning": {
      "class": "(module) AbilityLearning",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Ability learning/autogrant engine; computes which abilities a character should know at a given level.",
        "Designed to mirror SpellLearning rules (no leaks: only unlocks up to level; deterministic)."
      ],
      "owns": [],
      "path": "worldcore/abilities/AbilityLearning.ts",
      "provides": [
        "getAbilitiesToAutograntAtLevel",
        "applyAbilityAutogrants"
      ]
    },
    "abilities.types": {
      "dependsOn": [
        "actions.types",
        "combat.engine",
        "mud.resources"
      ],
      "functions": [
        "findAbilityByNameOrId"
      ],
      "kind": "model",
      "notes": [
        "Defines AbilityKind and AbilityDefinition plus ABILITIES map (e.g. warrior_power_strike, warrior_cleave) with channel, weaponSkill, resourceType, damage multipliers, and cooldownMs.",
        "findAbilityByNameOrId resolves abilities by id or case-insensitive name."
      ],
      "path": "worldcore/abilities/AbilityTypes.ts"
    },
    "abilities.unlocks": {
      "class": "(module) AbilityUnlocks",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Authoritative unlock rules + lookup for abilities (classId/minLevel/autogrant).",
        "Backed by DB table ability_unlocks; used by AbilityLearning to decide grants."
      ],
      "owns": [],
      "path": "worldcore/abilities/AbilityUnlocks.ts",
      "provides": [
        "getAbilityUnlocksForClass",
        "getAbilityUnlocksUpToLevel",
        "resolveAbilityIdAlias"
      ]
    },
    "actions.types": {
      "kind": "model",
      "notes": [
        "Defines AttackChannel ('weapon'|'spell'|'ability') and ActionRequest union over AttackActionRequest and HarvestActionRequest.",
        "Used as the transport-neutral action envelope for MUD and future 2.5D clients."
      ],
      "path": "worldcore/actions/ActionTypes.ts"
    },
    "actions.worldService": {
      "dependsOn": [
        "actions.types",
        "mud.actions"
      ],
      "functions": [
        "performAction"
      ],
      "kind": "service",
      "notes": [
        "Shared entry point for generic world actions (v1: attack + harvest) across MUD and future clients.",
        "Currently delegates to MudActions.handleAttackAction and handleGatherAction and returns ActionResult with message lines."
      ],
      "path": "worldcore/actions/WorldActionService.ts"
    },
    "ai.behaviorContext": {
      "kind": "model",
      "notes": [
        "Defines BehaviorContext (perception, players, cooldownMs, attackCooldownMs, setCooldownMs, optional guardMemory) and GuardMemory helpers.",
        "BehaviorHandler type is a pure function BehaviorContext -> NpcDecision|null."
      ],
      "path": "worldcore/ai/brains/BehaviorContext.ts"
    },
    "ai.brainTypes": {
      "kind": "model",
      "notes": [
        "Defines NpcPerception, PerceivedPlayer, and NpcDecision variants (idle, attack_entity, move_to_room, say, flee) plus NpcBrain interface.",
        "Engine-agnostic AI contract usable in-process or over-the-wire to a remote AI service."
      ],
      "path": "worldcore/ai/NpcBrainTypes.ts"
    },
    "ai.brains.aggressive": {
      "dependsOn": [
        "ai.brainTypes",
        "ai.behaviorContext"
      ],
      "functions": [
        "decideAggressiveBehavior"
      ],
      "kind": "service",
      "notes": [
        "Aggressive brain: if no cooldown and at least one player, attacks the first player and resets cooldown; otherwise returns null.",
        "Always uses melee attack_style for now."
      ],
      "path": "worldcore/ai/brains/AggressiveBrain.ts"
    },
    "ai.brains.coward": {
      "dependsOn": [
        "ai.brainTypes",
        "ai.behaviorContext",
        "ai.brains.aggressive"
      ],
      "functions": [
        "decideCowardBehavior"
      ],
      "kind": "service",
      "notes": [
        "Coward brain: if HP < maxHp, emits a flee decision away from the first perceived player; otherwise defers to aggressive behavior."
      ],
      "path": "worldcore/ai/brains/CowardBrain.ts"
    },
    "ai.brains.guard": {
      "dependsOn": [
        "ai.brainTypes",
        "ai.behaviorContext"
      ],
      "functions": [
        "pickGuardTarget",
        "decideGuardBehavior"
      ],
      "kind": "service",
      "notes": [
        "Guard brain: targets players with recent crime, preferring healer > dps > tank and lower HP, and can warn or call for help based on severity and safe-hub status.",
        "Uses guardMemory to avoid spamming warnings and to track help calls."
      ],
      "path": "worldcore/ai/brains/GuardBrain.ts"
    },
    "ai.brains.neutral": {
      "dependsOn": [
        "ai.behaviorContext",
        "ai.brainTypes"
      ],
      "functions": [
        "decideNeutralBehavior"
      ],
      "kind": "service",
      "notes": [
        "Neutral brain: always returns null; used for non-hostile NPCs that currently do nothing."
      ],
      "path": "worldcore/ai/brains/NeutralBrain.ts"
    },
    "ai.localSimpleBrain": {
      "class": "LocalSimpleAggroBrain",
      "dependsOn": [
        "ai.brainTypes"
      ],
      "functions": [
        "decide"
      ],
      "kind": "service",
      "notes": [
        "Simple in-process NPC brain that attacks the first player in room on a cooldown and makes cowards flee once injured.",
        "Tracks per-NPC cooldown in memory keyed by npcId."
      ],
      "path": "worldcore/ai/LocalSimpleNpcBrain.ts"
    },
    "auction.auditLog": {
      "dependsOn": [
        "db.main",
        "utils.logger",
        "auction.types"
      ],
      "functions": [
        "logAuctionEvent"
      ],
      "kind": "service",
      "notes": [
        "Writes auction_log rows with shard, listing id, actor info, action, and JSON details for create/buy/cancel/expire/claim/reclaim events.",
        "Failures are logged via Logger.scope('AUCTION_AUDIT') but never thrown back to callers."
      ],
      "path": "worldcore/auction/AuctionAuditLog.ts"
    },
    "auction.format": {
      "dependsOn": [
        "auction.types",
        "mud.context"
      ],
      "functions": [
        "formatAuctionListing"
      ],
      "kind": "service",
      "notes": [
        "Builds a one-line MUD description for a listing like '#12 Hematite Iron Ore [common] x20 \u2013 3g each (total 60g) by Testing [active]'.",
        "Looks up item definitions via ctx.items?.get to resolve item name and rarity."
      ],
      "path": "worldcore/auction/AuctionFormat.ts"
    },
    "auction.postgres": {
      "class": "PostgresAuctionService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "auction.types",
        "auction.service",
        "auction.auditLog"
      ],
      "functions": [
        "browse",
        "get",
        "createListing",
        "buyout",
        "cancelListing",
        "listBySeller",
        "claimProceeds",
        "expireOld",
        "reclaimExpiredForSeller"
      ],
      "kind": "service",
      "notes": [
        "Postgres-backed AuctionService using auctions table; maps AuctionRow to AuctionListing via rowToListing.",
        "Implements search + pagination, creates active listings with expires_at TTL, marks rows sold/cancelled/expired, tracks proceeds, and supports reclaiming expired items for sellers."
      ],
      "path": "worldcore/auction/PostgresAuctionService.ts"
    },
    "auction.service": {
      "dependsOn": [
        "auction.types"
      ],
      "functions": [
        "browse",
        "get",
        "createListing",
        "buyout",
        "cancelListing",
        "listBySeller",
        "claimProceeds",
        "expireOld",
        "reclaimExpiredForSeller"
      ],
      "kind": "service_contract",
      "notes": [
        "AuctionService interface for browsing, creating, buying out, cancelling, expiring, and reclaiming auctions plus claiming proceeds.",
        "Used by PostgresAuctionService and MUD commands."
      ],
      "path": "worldcore/auction/AuctionService.ts"
    },
    "auction.types": {
      "kind": "model",
      "notes": [
        "Defines AuctionStatus ('active'|'sold'|'cancelled'|'expired') and AuctionListing with shard, seller, buyer, item, pricing, and proceeds fields.",
        "Used across auction services, formatting, and audit logging."
      ],
      "path": "worldcore/auction/AuctionTypes.ts"
    },
    "auth.debugGate": {
      "dependsOn": [
        "auth.types"
      ],
      "functions": [
        "getShardMode",
        "canUseDebugCommands",
        "requireDebug"
      ],
      "kind": "service",
      "notes": [
        "Gatekeeper for debug commands based on identity flags and shard mode.",
        "Disallows debug commands on live shards and enforces minimum StaffRole threshold."
      ],
      "path": "worldcore/auth/debugGate.ts"
    },
    "auth.postgres": {
      "class": "PostgresAuthService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "auth.service",
        "auth.types"
      ],
      "functions": [
        "registerAccount",
        "loginWithPassword",
        "verifyToken",
        "getAccountById"
      ],
      "kind": "service",
      "notes": [
        "Postgres + JWT implementation of AuthService with PBKDF2 password hashing and signed tokens.",
        "Persists flags JSONB on accounts, logs auth events, and returns AuthResult with expiry timestamp."
      ],
      "path": "worldcore/auth/PostgresAuthService.ts"
    },
    "auth.service": {
      "dependsOn": [
        "auth.types"
      ],
      "functions": [
        "registerAccount",
        "loginWithPassword",
        "verifyToken",
        "getAccountById"
      ],
      "kind": "service_contract",
      "notes": [
        "Abstract auth API over accounts: register, login, token verification, and profile lookup.",
        "AccountFlags include staff/debug knobs such as isGM, isDev, isOwner, isTester, isShardBuilder."
      ],
      "path": "worldcore/auth/AuthService.ts"
    },
    "auth.staffAudit": {
      "dependsOn": [
        "db.main",
        "utils.logger",
        "auth.types"
      ],
      "functions": [
        "logStaffAction"
      ],
      "kind": "service",
      "notes": [
        "Writes rows into staff_action_log with actor id/name, actionName, and JSON details.",
        "Errors are logged but never allowed to break the calling staff command."
      ],
      "path": "worldcore/auth/StaffAuditLog.ts"
    },
    "auth.staffRoles": {
      "kind": "model",
      "notes": [
        "Defines StaffRole ('player'|'guide'|'gm'|'dev'|'owner') and StaffRoleLevel numeric mapping.",
        "Used for permission checks and debug/staff tools."
      ],
      "path": "worldcore/auth/StaffRoles.ts"
    },
    "auth.types": {
      "functions": [
        "getStaffRole",
        "getStaffTier",
        "isGuide",
        "isGMOrHigher",
        "isDevOrHigher",
        "isOwner"
      ],
      "kind": "model",
      "notes": [
        "Shared auth/identity model: UserId, CharacterId, ShardId, AccountFlags, AccountProfile, CharacterSummary, AuthTokenPayload, AuthResult, AttachedIdentity.",
        "Also provides staff role helpers and StaffRole/StaffRoleLevel for permission checks."
      ],
      "path": "worldcore/shared/AuthTypes.ts"
    },
    "bank.economyHelpers": {
      "dependsOn": [
        "bank.service"
      ],
      "functions": [
        "getBankGold",
        "setBankGold",
        "addBankGold"
      ],
      "kind": "utility",
      "notes": [
        "Small helpers to read, clamp, and mutate bank.gold balance on BankState.",
        "Used by higher-level bank operations and services."
      ],
      "path": "worldcore/bank/BankEconomyHelpers.ts"
    },
    "bank.ops": {
      "dependsOn": [
        "bank.service",
        "items.service",
        "items.catalog",
        "characters.types",
        "bank.types",
        "economy.helpers",
        "bank.economyHelpers"
      ],
      "functions": [
        "addToBankSlots",
        "formatBankView",
        "takeFromInventoryExactSlot",
        "bankDepositFromInventorySlot"
      ],
      "kind": "service",
      "notes": [
        "High-level bank operations: stack-aware deposits, formatted bank views, and inventory-slot transfers.",
        "Handles unknown items by rolling back via giveItemsToCharacter and returns leftovers when the bank is full."
      ],
      "path": "worldcore/bank/bankOps.ts"
    },
    "bank.postgres": {
      "class": "PostgresBankService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "bank.service",
        "bank.types"
      ],
      "functions": [
        "getBank",
        "saveBank"
      ],
      "kind": "service",
      "notes": [
        "Postgres-backed implementation using bank_slots and bank_accounts tables.",
        "Maintains a fixed BANK_SLOT_COUNT, loads slots ordered by index, and persists both gold and per-slot item stacks in a transaction."
      ],
      "path": "worldcore/bank/PostgresBankService.ts"
    },
    "bank.service": {
      "dependsOn": [
        "bank.types",
        "characters.types"
      ],
      "functions": [
        "getBank",
        "saveBank"
      ],
      "kind": "service_contract",
      "notes": [
        "BankService interface over BankState with typed ownerKind.",
        "Supports loading/creating a bank and saving the full slot + gold state."
      ],
      "path": "worldcore/bank/BankService.ts"
    },
    "bank.types": {
      "kind": "model",
      "notes": [
        "Defines BankOwnerKind ('account'|'character'|'guild'|'city') and BankOwnerRef.",
        "Used across all bank operations and commands to address the correct bank entity."
      ],
      "path": "worldcore/bank/BankTypes.ts"
    },
    "characters.db": {
      "class": "PostgresCharacterService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "characters.types",
        "characters.leveling",
        "classes.definitions"
      ],
      "functions": [
        "listCharactersForUser",
        "loadCharacter",
        "loadCharacterForUser",
        "createCharacter",
        "saveCharacter",
        "patchCharacter",
        "grantXp",
        "learnSpell",
        "equipItem"
      ],
      "kind": "service",
      "notes": [
        "Postgres-backed character service using the characters table and CharacterRow \u2192 CharacterState mapping.",
        "Supports partial JSONB patching, XP/level gains with per-class attribute growth, and spell/equipment updates."
      ],
      "path": "worldcore/characters/PostgresCharacterService.ts"
    },
    "characters.leveling": {
      "functions": [
        "xpForNextLevel",
        "applyXp"
      ],
      "kind": "service",
      "notes": [
        "Simple linear XP curve (100 * level) used by PostgresCharacterService.",
        "applyXp applies a delta, loops level-ups, and returns a LevelingResult with old/new levels and XP plus leveledUp flag."
      ],
      "path": "worldcore/characters/Leveling.ts"
    },
    "characters.persist": {
      "dependsOn": [
        "characters.db",
        "shared.session"
      ],
      "functions": [
        "persistCharacterSnapshot"
      ],
      "kind": "service",
      "notes": [
        "Utility that snapshots the current CharacterState from a MUD context into Postgres via ctx.characters.patchCharacter.",
        "Persists position, region, attributes, inventory, equipment, spellbook, abilities, and progression."
      ],
      "path": "worldcore/characters/characterPersist.ts"
    },
    "characters.service": {
      "dependsOn": [
        "auth.types",
        "characters.types"
      ],
      "functions": [
        "listCharactersForUser",
        "createCharacter",
        "loadCharacter",
        "saveCharacter"
      ],
      "kind": "service_contract",
      "notes": [
        "Backend-agnostic character API shared by MMO shard, webend, and tools.",
        "Uses UserId/CharacterId/ShardId and CharacterState/Summary types."
      ],
      "path": "worldcore/characters/CharacterService.ts"
    },
    "characters.sheet": {
      "dependsOn": [
        "combat.entityCombat",
        "world.regionText",
        "characters.stats"
      ],
      "functions": [
        "buildCharacterSheetLine"
      ],
      "kind": "service",
      "notes": [
        "Builds a single-line textual character sheet including name, class, level, XP, HP, status, shard, region, base and effective attributes, and active title name.",
        "Uses computeEffectiveAttributes plus entity HP/in-combat flags for status labeling."
      ],
      "path": "worldcore/characters/characterSheet.ts"
    },
    "characters.stateGuard": {
      "dependsOn": [
        "characters.types",
        "world.manager",
        "utils.logger"
      ],
      "functions": [
        "hydrateCharacterRegion"
      ],
      "kind": "service",
      "notes": [
        "Ensures CharacterState.lastRegionId matches the region resolved by ServerWorldManager at posX/posZ.",
        "Logs region changes for debugging and returns either original or updated CharacterState."
      ],
      "path": "worldcore/characters/CharacterStateGuard.ts"
    },
    "characters.stats": {
      "dependsOn": [
        "characters.types",
        "items.catalog",
        "items.service",
        "characters.titles"
      ],
      "functions": [
        "computeEffectiveAttributes"
      ],
      "kind": "service",
      "notes": [
        "Computes effective attributes by cloning base attributes, then applying item stat bonuses from ItemService or ItemCatalog and active title bonuses from TITLES.",
        "Used by characterSheet and any system that needs gear-adjusted attributes."
      ],
      "path": "worldcore/characters/Stats.ts"
    },
    "characters.titles": {
      "functions": [
        "getTitleDefinition",
        "listAllTitles"
      ],
      "kind": "model",
      "notes": [
        "Defines TitleDefinition and TITLES map including rat_slayer and ore_breaker unlocks and attribute bonuses.",
        "Used both by progression.titles.* and characterStats for bonus application."
      ],
      "path": "worldcore/characters/TitleTypes.ts"
    },
    "characters.types": {
      "functions": [
        "defaultAttributes",
        "defaultInventory",
        "defaultEquipment",
        "defaultSpellbook",
        "defaultAbilities",
        "defaultProgression",
        "rowToCharacterState",
        "toCharacterSummary"
      ],
      "kind": "model",
      "notes": [
        "Canonical CharacterRow and CharacterState model plus typed v1.5 JSONB blobs for attributes, inventory, equipment, spellbook, abilities, and progression.",
        "Includes SimpleTask/QuestState integration in ProgressionState and helpers to transform DB rows into in-memory state and UI CharacterSummary DTOs."
      ],
      "path": "worldcore/characters/CharacterTypes.ts"
    },
    "classes.definitions": {
      "functions": [
        "getClassDefinition",
        "getCombatRoleForClass",
        "getPerLevelAttributesForClass",
        "getPrimaryResourceForClass",
        "getPowerResourcesForClass",
        "getAllClassDefinitions"
      ],
      "kind": "model",
      "notes": [
        "Defines ClassId, ClassDefinition, CombatRole, archetypes, and class power resources plus full CLASS_DEFINITIONS and CLASS_PER_LEVEL tables for Virtuoso, Illusionist, Adventurer, legacy Warrior/Mage/Rogue/Priest, and others.",
        "Provides helpers for per-level attribute gains, primary/secondary resources, favored schools/weapon skills, and armor/weapon access."
      ],
      "path": "worldcore/classes/ClassDefinitions.ts"
    },
    "combat.castingGates": {
      "dependsOn": [
        "combat.cooldowns",
        "resources.power",
        "characters.types"
      ],
      "functions": [
        "applyActionCostAndCooldownGates"
      ],
      "kind": "service",
      "notes": [
        "Centralized gates for action resource costs + cooldowns (spells/songs/abilities).",
        "Guarantees: cooldowns do not start and resources are not consumed if the action fails.",
        "Order: check cooldown remaining \u2192 spend resource \u2192 start cooldown.",
        "Also supports post-success power builders (e.g., Rune Strike \u2192 Runic Power, Jab \u2192 Chi)."
      ],
      "path": "worldcore/combat/CastingGates.ts"
    },
    "combat.combatLog": {
      "dependsOn": [],
      "functions": [
        "clampInt(n,min,max)",
        "formatHpPart(hpAfter?, maxHp?)",
        "formatWorldSpellDotTickLine(opts)",
        "formatWorldSpellHotTickLine(opts)",
        "formatWorldSpellDirectDamageLine(opts)"
      ],
      "kind": "service",
      "notes": [
        "Keep these formatters boring and stable; contract tests pin exact output shapes.",
        "All formatters include hp/maxHp when provided, and clamp numeric values defensively."
      ],
      "path": "worldcore/combat/CombatLog.ts",
      "provides": [
        "Deterministic combat log line formatting for DOT/HOT ticks and direct spell hits.",
        "Canonical [world] [spell:*] prefix used by mud_result lines for parsing and UI."
      ]
    },
    "combat.cooldowns": {
      "dependsOn": [
        "characters.types"
      ],
      "functions": [
        "ensureCooldownBucket",
        "getCooldownRemaining",
        "startCooldown",
        "checkAndStartCooldown"
      ],
      "kind": "service",
      "notes": [
        "Stores cooldowns under char.progression.cooldowns[bucket][key].",
        "Provides helpers to query remaining time and atomically check+start cooldowns with user-facing error strings."
      ],
      "path": "worldcore/combat/Cooldowns.ts"
    },
    "combat.cowardice": {
      "dependsOn": [
        "characters.types",
        "world.regionDanger"
      ],
      "functions": [
        "resolveCowardiceTier",
        "computeCowardiceDamageTakenMultiplier",
        "getCowardiceInfo",
        "formatCowardiceStatus"
      ],
      "kind": "utility",
      "notes": [
        "Cowardice/risk-mode incoming damage logic. Returns scalar multiplier applied to incoming damage.",
        "Uses RegionDanger tier to scale cowardice impact."
      ],
      "path": "worldcore/combat/Cowardice.ts"
    },
    "combat.damagePolicy": {
      "dependsOn": [
        "combat.serviceProtection",
        "pvp.rules",
        "world.regionFlags"
      ],
      "functions": [
        "serviceProtectionGate",
        "resolvePlayerVsPlayerPolicy",
        "canDamage",
        "canDamageFast"
      ],
      "kind": "utility",
      "notes": [
        "Centralized 'can I damage this target?' policy layer.",
        "v1: blocks damage to protected service NPCs; applies fail-closed PvP gating using RegionFlags + PvpRules; defaults to PvE allow otherwise."
      ],
      "path": "worldcore/combat/DamagePolicy.ts"
    },
    "combat.engine": {
      "dependsOn": [
        "actions.types",
        "characters.types",
        "combat.mitigation",
        "combat.resists",
        "combat.scaling",
        "combat.statusEffects",
        "shared.entities",
        "skills.progression",
        "utils.logger"
      ],
      "functions": [
        "computeDamage"
      ],
      "kind": "service",
      "notes": [
        "Core damage math for weapon, ability, spell, and song channels.",
        "Scales off STR/INT, level, weapon skill, spell school, or song instrument skill, with crit/glancing and rough armor/resist mitigation.",
        "WeaponSkillId expanded to include 'dagger' for Cutthroat/rogue kits; training uses the existing weapon-skill progression plumbing."
      ],
      "path": "worldcore/combat/CombatEngine.ts"
    },
    "combat.entityCombat": {
      "dependsOn": [
        "characters.types",
        "combat.cowardice",
        "combat.statusEffects",
        "shared.entities",
        "world.regionDanger"
      ],
      "functions": [
        "markInCombat",
        "killEntity",
        "isDeadEntity",
        "resurrectEntity",
        "applySimpleDamageToPlayer",
        "computeNpcMeleeDamage",
        "applyCombatResultToPlayer"
      ],
      "kind": "utility",
      "notes": [
        "Shared entity HP helpers and NPC melee damage formula.",
        "Tags entities in combat, handles simple kill/resurrect, applies simple damage with cowardice & status effect multipliers.",
        "On player death, bumps RegionDanger for the character's region to make that area temporarily more dangerous.",
        "Min-damage rule v1: positive fractional incoming damage becomes at least 1.",
        "Note that DamageContext.incomingModsAlreadyApplied exists and why (prevents double-dip when CombatEngine bakes defender taken mods)"
      ],
      "path": "worldcore/combat/entityCombat.ts"
    },
    "combat.mitigation": {
      "dependsOn": [],
      "functions": [
        "applyArmorMitigation",
        "armorMultiplier"
      ],
      "kind": "service",
      "notes": [
        "v1 armor mitigation helper for physical damage.",
        "Pure functions: no world state. Used by CombatEngine computeDamage/applyDamage pipeline."
      ],
      "path": "worldcore/combat/Mitigation.ts"
    },
    "combat.npc": {
      "dependsOn": [
        "actions.types",
        "characters.service",
        "characters.types",
        "combat.engine",
        "combat.entityCombat",
        "combat.serviceProtection",
        "core.rooms",
        "items.catalog",
        "items.inventoryHelpers",
        "loot.text",
        "mail.service",
        "npc.manager",
        "npc.types",
        "resources.power",
        "shared.entities",
        "skills.progression",
        "utils.logger",
        "utils.random",
        "combat.damagePolicy",
        "combat.physicalHitResolver"
      ],
      "functions": [
        "performNpcAttack",
        "applySimpleNpcCounterAttack",
        "announceSpawnToRoom",
        "scheduleNpcCorpseAndRespawn"
      ],
      "kind": "service",
      "notes": [
        "High-level NPC attack executor and death handling used by v1 brains.",
        "Uses CombatEngine for damage, updates skill and fury progression, applies counter-attacks, grants XP, and schedules corpse/respawn with resource-node special-casing.",
        "Now delegate overflow behavior to the helper",
        "Corpse/despawn/respawn flow assumes combat status effects are cleared on death and do not tick on corpses."
      ],
      "path": "worldcore/combat/NpcCombat.ts"
    },
    "combat.physicalHitResolver": {
      "dependsOn": [
        "characters.types",
        "combat.engine",
        "skills.progression"
      ],
      "functions": [
        "resolvePhysicalHit"
      ],
      "kind": "service",
      "notes": [
        "Skill-based physical hit resolution: miss/dodge/parry/block, crit hooks, double/triple attack hooks, and parry->riposte hook.",
        "Foundation for future pets, taunt/threat, shield tech, and stealth openers."
      ],
      "path": "worldcore/combat/PhysicalHitResolver.ts"
    },
    "combat.playerHotTicker": {
      "dependsOn": [
        "combat.combatLog",
        "combat.statusEffects",
        "core.entityManager",
        "core.sessionManager"
      ],
      "functions": [
        "tickAllPlayerHots(entities,sessions,nowMs)"
      ],
      "kind": "utility",
      "notes": [
        "Ticks HOTs stored on CharacterState for all sessions and applies healing to the corresponding player entity.",
        "Used by TickEngine to keep periodic healing in the canonical heartbeat.",
        "Controlled by PW_HOT_TICK_MESSAGES (default on)."
      ],
      "path": "worldcore/combat/PlayerHotTicker.ts",
      "provides": []
    },
    "combat.regionDangerAuras": {
      "dependsOn": [
        "world.regionDanger",
        "world.RegionFlags",
        "characters.types",
        "combat.statusEffects"
      ],
      "functions": [
        "getRegionDangerAuraStrengthForTier(tier, config?)",
        "updateRegionDangerAuraForCharacter(char, nowMs?, config?)"
      ],
      "kind": "utility",
      "notes": [
        "Converts RegionDanger tier into an ambient debuff aura ('Region Peril').",
        "Default config applies +5% damageTakenPct when region danger tier >= 3.",
        "TickEngine calls updateRegionDangerAuraForCharacter per character tick to keep aura in sync with current region."
      ],
      "path": "worldcore/combat/RegionDangerAuras.ts"
    },
    "combat.resists": {
      "dependsOn": [],
      "functions": [
        "resistMultiplier",
        "applyResistMitigation"
      ],
      "kind": "utility",
      "notes": [
        "Resists v1 helper. Pure functions for non-physical damage mitigation.",
        "Default curve: mitigation = min(0.75, resist/200). Resist values are 'rating-like' not percent."
      ],
      "path": "worldcore/combat/Resists.ts"
    },
    "combat.scaling": {
      "dependsOn": [
        "skills.progression",
        "characters.types"
      ],
      "functions": [
        "getWeaponSkillLevel",
        "getSpellSchoolLevel"
      ],
      "kind": "utility",
      "notes": [
        "Maps raw weapon/spell school skill into effective combat level.",
        "If no skill is recorded, falls back to character level; otherwise uses skill/5 with a minimum of 1."
      ],
      "path": "worldcore/combat/CombatScaling.ts"
    },
    "combat.serviceProtection": {
      "dependsOn": [],
      "functions": [
        "isServiceProtectedNpcProto",
        "isServiceProtectedEntity",
        "serviceProtectedCombatLine"
      ],
      "kind": "utility",
      "notes": [
        "Protects critical service NPCs (bank/mail/auction/etc.) from being killed/griefed.",
        "Pure helpers; detection based on proto id/tags and optional runtime flags."
      ],
      "path": "worldcore/combat/ServiceProtection.ts"
    },
    "combat.skinLootService": {
      "class": "SkinLootService",
      "ctorArgs": [],
      "dependsOn": [
        "db.database",
        "utils.logger"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "owns": [],
      "path": "worldcore/combat/SkinLootService.ts",
      "provides": [
        "getSkinLootService(): singleton accessor",
        "SkinLootService.getEntries(protoId, tags): proto-first + tag fallback, deterministic ordering"
      ],
      "service": "combat"
    },
    "combat.statusEffects": {
      "dependsOn": [
        "characters.types",
        "combat.statusStackingPolicy",
        "shared.entities"
      ],
      "functions": [
        "applyStatusEffect(char,input)",
        "applyStatusEffectToEntity(entity,input)",
        "clearAllStatusEffects(char)",
        "clearAllStatusEffectsFromEntity(entity)",
        "clearStatusEffect(char,id)",
        "clearStatusEffectFromEntity(entity,id)",
        "getActiveStatusEffects(char, nowMs?)",
        "getActiveStatusEffectsForEntity(entity, nowMs?)",
        "computeCombatStatusSnapshot(char, nowMs?)",
        "computeEntityCombatStatusSnapshot(entity, nowMs?)",
        "computeCombatStatusSnapshotForEntity (alias of computeEntityCombatStatusSnapshot)",
        "tickStatusEffects(char, nowMs?)",
        "tickEntityStatusEffects(entity, nowMs?)",
        "tickEntityStatusEffectsAndApplyDots(entity, nowMs?)"
      ],
      "kind": "service",
      "notes": [
        "Status effects are stored under character.progression.statusEffects (JSONB) and are ticked/expired via tickStatusEffects().",
        "Back-compat: NewStatusEffectInput accepts `stacks` as an alias for `initialStacks` (older call-sites/tests).",
        "damageTakenPct and damageDealtPct are FRACTIONS (0.05 = +5%).",
        "damageDealtPctBySchool and damageTakenPctBySchool are FRACTIONS (0.05 = +5%).",
        "Status effect spine used by vulnerability, region peril auras, and outgoing/incoming damage modifiers.",
        "NPC/Entity status-effects carrier + DOT ticking implemented; effects clear on death/despawn and DOT ticking stops immediately on death.",
        "Entity tick helpers can optionally apply DOT damage and must stop immediately if entity dies.",
        "Stacking behavior is governed by StatusStackingPolicy (including versioned_by_applier).",
        "Entity/NPC effects are stored under entity.statusEffects.active (mirrors character progression storage).",
        "Imports DamageSchool as a type from CombatEngine (type-only); no runtime circular dependency.",
        "tickEntityStatusEffectsAndApplyDots emits DotTickEvent meta including appliedByKind/appliedById for kill/XP attribution and combat log routing."
      ],
      "path": "worldcore/combat/StatusEffects.ts",
      "provides": [
        "CombatStatusSnapshot aggregation (attributes, damageDealtPct, damageTakenPct, damageDealtPctBySchool, damageTakenPctBySchool, armor/resist bonuses)",
        "DOT ticking helper for entities (applies damage and can trigger death).",
        "Stacking policy resolver support (refresh|unique|stack|refresh_stack|versioned_by_applier).",
        "StatusEffect storage for characters and entities (NPCs).",
        "StatusEffect storage under char.progression.statusEffects.active"
      ]
    },
    "combat.statusStackingPolicy": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [],
      "functions": [
        "isStatusStackingPolicy",
        "resolveStatusStackingPolicy"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Status stacking policy matrix + resolver used by StatusEffects to decide refresh/overwrite/stack behavior.",
        "Policies currently supported: refresh | unique | stack | refresh_stack | versioned_by_applier.",
        "versioned_by_applier: statusEffectVersion stacks only when applied by distinct appliers (per-applier slot), capped by maxStacks; same applier upgrades their slot; same version refreshes/last-write-wins (no extra stack)."
      ],
      "owns": [],
      "path": "worldcore/combat/StatusStackingPolicy.ts",
      "provides": [],
      "service": "combat"
    },
    "combat.vulnerability": {
      "dependsOn": [
        "characters.types",
        "combat.statusEffects"
      ],
      "functions": [
        "applyVulnerability(target, stacks?, nowMs?, config?)"
      ],
      "kind": "utility",
      "notes": [
        "Defines a generic incoming-damage debuff effect ('Exposed Weakness').",
        "Applies a StatusEffect that increases damageTakenPct per stack, up to a maxStacks cap.",
        "Intended to be used by spells, abilities, and NPC AI for 'take more damage' mechanics."
      ],
      "path": "worldcore/combat/Vulnerability.ts"
    },
    "config.logconfig": {
      "functions": [
        "logEnabled"
      ],
      "kind": "config",
      "notes": [
        "Log-level resolution for scoped loggers with global and per-scope env overrides.",
        "Used by Logger to decide if a given scope+level should emit output."
      ],
      "path": "worldcore/config/logconfig.ts"
    },
    "config.runtime": {
      "kind": "config",
      "notes": [
        "Runtime server config: WS_HOST, WS_PORT, heartbeat interval and timeout.",
        "Values are derived from PW_WS_HOST and PW_WS_PORT env vars with safe defaults."
      ],
      "path": "worldcore/config/config.ts"
    },
    "config.shardConfig": {
      "kind": "config",
      "notes": [
        "Shard-wide mode flag: 'dev' or 'live', driven by PW_SHARD_MODE env variable.",
        "Referenced by systems like item grant rules to gate dev-only behavior."
      ],
      "path": "worldcore/config/ShardConfig.ts"
    },
    "config.worldscale": {
      "functions": [
        "getWorldScale"
      ],
      "kind": "config",
      "notes": [
        "Defines dev_tiny, dev_medium, and live_prime world scales plus WORLD_SCALES registry.",
        "DEFAULT_WORLD_SCALE_ID is driven by PW_WORLD_SCALE; getWorldScale() returns the requested or default shard scale definition for worldgen, movement, and macro war sims."
      ],
      "path": "worldcore/config/worldscale.ts"
    },
    "core.combat": {
      "class": "CombatSystem",
      "ctorArgs": [
        "core.entities",
        "core.rooms",
        "core.sessions"
      ],
      "dependsOn": [
        "core.entities",
        "core.rooms",
        "core.sessions"
      ],
      "eventsEmitted": [
        "target_set",
        "ability_cast"
      ],
      "facade": "CombatFacade",
      "kind": "engine",
      "lifecycle": "singleton",
      "notes": [
        "v1 safe stub: no real damage or aggro yet.",
        "Stashes targetId on player entity.",
        "Broadcasts 'target_set' and 'ability_cast' events to the room."
      ],
      "path": "worldcore/core/CombatSystem.ts",
      "provides": [
        "setTarget(session, targetId?)",
        "handleCast(session, payload)"
      ]
    },
    "core.entities": {
      "class": "EntityManager",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Single source of truth for all Entity records.",
        "Enforces one 'player' entity per session.",
        "NPCs are simple entities with type 'npc' and model."
      ],
      "path": "worldcore/core/EntityManager.ts",
      "provides": [
        "createPlayerForSession(sessionId, roomId)",
        "createNpcEntity(roomId, model)",
        "get(entityId)",
        "getEntitiesInRoom(roomId)",
        "getEntityByOwner(sessionId)",
        "getAll()",
        "removeEntity(entityId)",
        "setPosition(entityId, x, y, z)"
      ]
    },
    "core.heartbeat": {
      "ctorArgs": [
        "core.sessions",
        "core.rooms",
        "config.heartbeat"
      ],
      "dependsOn": [
        "core.sessions",
        "core.rooms"
      ],
      "function": "startHeartbeat",
      "kind": "loop",
      "lifecycle": "timer",
      "notes": [
        "Periodic coarse idle session cleanup.",
        "Uses sessions.getAllSessions() and lastSeen for idle detection.",
        "Calls rooms.leaveRoom(session) before sessions.removeSession(sessionId)."
      ],
      "path": "worldcore/core/Heartbeat.ts",
      "provides": [
        "startHeartbeat(sessions, rooms, cfg) -> NodeJS.Timeout"
      ]
    },
    "core.movement": {
      "class": "MovementEngine",
      "ctorArgs": [
        "world.manager"
      ],
      "dependsOn": [
        "world.manager"
      ],
      "facade": "MovementEngineFacade",
      "kind": "engine",
      "lifecycle": "singleton",
      "notes": [
        "Validates client x/z/rotY.",
        "Samples heightmap for ground Y, keeps entity slightly above terrain.",
        "Logs when position is outside nominal world radius; world bounds enforcement is not strict yet."
      ],
      "path": "worldcore/core/MovementEngine.ts",
      "provides": [
        "applyClientMove(session, payload: ClientMovePayload) -> ResolvedMove|null"
      ]
    },
    "core.objectStream": {
      "class": "ObjectStream",
      "ctorArgs": [
        "world.manager",
        "core.sessions"
      ],
      "dependsOn": [
        "world.manager",
        "core.sessions"
      ],
      "eventsEmitted": [
        "object_chunk"
      ],
      "facade": "ObjectStreamFacade",
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Static v1 object stream.",
        "Fetches shard blueprint via world.getShardBlueprint().",
        "Sends a single 'object_chunk' with all objects + spawns for now."
      ],
      "path": "worldcore/core/ObjectStream.ts",
      "provides": [
        "handleObjectRequest(session, payload)"
      ]
    },
    "core.rooms": {
      "class": "RoomManager",
      "ctorArgs": [
        "core.sessions",
        "core.entities",
        "world.blueprints?"
      ],
      "dependsOn": [
        "core.sessions",
        "core.entities",
        "world.blueprints?"
      ],
      "eventsEmitted": [
        "world_blueprint",
        "room_joined",
        "room_left"
      ],
      "internalTypes": {
        "Room": {
          "ctorArgs": [
            "roomId",
            "core.sessions",
            "core.entities"
          ],
          "eventsEmitted": [
            "entity_list",
            "chat",
            "entity_update",
            "ability_cast",
            "target_set"
          ],
          "path": "worldcore/core/Room.ts",
          "responsibilities": [
            "Track membership for a room.",
            "Create/ensure player entity when a character joins a world room.",
            "Apply character position/name to entity before sending 'entity_list'.",
            "Broadcast chat and entity updates to members.",
            "Distinguish 'UI rooms' (lobby/auth/select_character) from world rooms."
          ]
        }
      },
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Creates Room instances on demand.",
        "Tracks which sessions are in which rooms.",
        "When joining a world room, fetches WorldBlueprint and sends 'world_blueprint' to that session."
      ],
      "path": "worldcore/core/RoomManager.ts",
      "provides": [
        "ensureRoom(roomId)",
        "get(roomId)",
        "listRooms()",
        "joinRoom(session, roomId)",
        "leaveRoom(session)"
      ]
    },
    "core.router": {
      "class": "MessageRouter",
      "ctorArgs": [
        "core.sessions",
        "core.rooms",
        "core.entities",
        "core.movement?",
        "core.combat?",
        "core.objectStream?",
        "core.terrainStream?",
        "world.manager?",
        "guilds.service",
        "world.characters?",
        "world.items?",
        "world.npcs?",
        "world.mail?",
        "world.trades?",
        "world.vendors?",
        "world.bank?",
        "world.auctions?"
      ],
      "dependsOn": [
        "core.sessions",
        "core.rooms",
        "core.entities",
        "core.movement?",
        "core.combat?",
        "core.objectStream?",
        "core.terrainStream?",
        "world.manager?",
        "guilds.service",
        "world.characters?",
        "world.items?",
        "world.npcs?",
        "world.mail?",
        "world.trades?",
        "world.vendors?",
        "world.bank?",
        "world.auctions?",
        "world.RegionFlags",
        "db.Database"
      ],
      "handlesClientOps": [
        "ping / hello / heartbeat",
        "join_room / leave_room / list_rooms",
        "object_request",
        "terrain_request / terrain (envelope)",
        "move / walk / go",
        "action (attack, harvest)",
        "set_target / cast",
        "chat",
        "whereami",
        "mud",
        "gchat"
      ],
      "kind": "gateway",
      "lifecycle": "singleton",
      "notes": [
        "Main entry point for all client->world traffic.",
        "Delegates movement to MovementEngineFacade, terrain/objects to streams, combat to CombatFacade.",
        "Builds a WorldActionContext bag for performAction and MudCommandHandler.",
        "Also exposes whereami resolution (roomId, pos, regionId, shardId) using both character and entity data."
      ],
      "path": "worldcore/core/MessageRouter.ts"
    },
    "core.sessions": {
      "class": "SessionManager",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Owns all active sessions in memory.",
        "Tracks lastSeen for heartbeat idle timeout.",
        "Defaults shardId to 'prime_shard' on createSession."
      ],
      "path": "worldcore/core/SessionManager.ts",
      "provides": [
        "createSession(socket, displayName)",
        "get(sessionId)",
        "getAllSessions()",
        "touch(sessionId)",
        "send(session, op, payload?)",
        "broadcast(op, payload?)"
      ]
    },
    "core.terrainStream": {
      "class": "TerrainStream",
      "ctorArgs": [
        "world.manager",
        "core.sessions"
      ],
      "dependsOn": [
        "world.manager",
        "core.sessions"
      ],
      "eventsEmitted": [
        "terrain"
      ],
      "facade": "TerrainStreamFacade",
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Samples heightmap around a center (x,z) into a small grid.",
        "Returns 'terrain' messages with kind 'simple_height_patch'.",
        "Envelope handler currently logs only; reserved for future streaming ops."
      ],
      "path": "worldcore/core/TerrainStream.ts",
      "provides": [
        "handleChunkRequest(session, payload)",
        "handleTerrainEnvelope(session, payload)"
      ]
    },
    "core.tickEngine": {
      "class": "TickEngine",
      "ctorArgs": [
        "core.entities",
        "core.rooms",
        "core.sessions",
        "world.manager",
        "config.tick",
        "world.npcs?"
      ],
      "dependsOn": [
        "core.entities",
        "core.rooms",
        "core.sessions",
        "world.manager",
        "world.npcs?"
      ],
      "kind": "engine",
      "lifecycle": "singleton",
      "notes": [
        "Fixed-interval tick loop (min 10ms).",
        "Ticks NPCs via NpcManager.updateAll each tick (if provided).",
        "Calls cfg.onTick(now, tick, deltaMs) hook for systems like SongEngine.",
        "Logs basic stats periodically.",
        "Ticks NPC status effects + DOT damage each tick (best-effort), skipping dead NPCs/corpses."
      ],
      "path": "worldcore/core/TickEngine.ts",
      "provides": [
        "start()",
        "stop()"
      ]
    },
    "dev.hotReloadService": {
      "dependsOn": [
        "utils.logger",
        "items.service?",
        "quests.registry?",
        "npc.types?",
        "world.spawnPointCache?",
        "world.spawnHydrator?",
        "world.spawnPoints?"
      ],
      "functions": [
        "parseHotReloadTargets(args:string[]):HotReloadTarget[]",
        "runHotReload(targets:HotReloadTarget[], deps:HotReloadDeps):Promise<HotReloadReport>",
        "formatHotReloadReport(r:HotReloadReport):string"
      ],
      "kind": "service",
      "notes": [
        "Central hot-reload coordinator used by the MUD 'reload' command.",
        "Supports targets: all/items/quests/npcs/spawns.",
        "Items reload prefers ItemService.reload() then falls back to loadAll().",
        "Quests reload pushes definitions into QuestRegistry via setQuestDefinitions().",
        "NPC reload pushes prototypes into NpcTypes via setNpcPrototypes().",
        "Spawns reload clears SpawnPointCache (best-effort dynamic import), optionally clears SpawnPointService caches (duck-typed), and invalidates SpawnHydrator hydration cache when present."
      ],
      "path": "worldcore/dev/HotReloadService.ts"
    },
    "infra.audit.npc_lawtags": {
      "class": "(sql) infra audit",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "schema_audit",
      "lifecycle": "static",
      "notes": [
        "Audit query to detect conflicting or suspicious law-related tags on NPC prototypes.",
        "Used during development/CI when verifying seed content and safety rules."
      ],
      "owns": [
        "Consistency checks for law_protected vs law_exempt tag combos"
      ],
      "path": "worldcore/infra/schema/audit_npc_lawtags.sql",
      "provides": [
        "SQL audit for npc law tags"
      ]
    },
    "infra.schema.001_init_shards": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 001 init shards."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/001_init_shards.sql",
      "provides": [
        "shards table"
      ]
    },
    "infra.schema.002_regions": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 002 regions."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/002_regions.sql",
      "provides": [
        "region_polygons table",
        "regions table"
      ]
    },
    "infra.schema.003_world_objects": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 003 world objects."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/003_world_objects.sql",
      "provides": [
        "world_objects table"
      ]
    },
    "infra.schema.004_spawn_points": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 004 spawn points."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/004_spawn_points.sql",
      "provides": [
        "spawn_points table"
      ]
    },
    "infra.schema.005_nav_graph": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 005 nav graph."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/005_nav_graph.sql",
      "provides": [
        "nav_edges table",
        "nav_nodes table"
      ]
    },
    "infra.schema.006_world_properties": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 006 world properties."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/006_world_properties.sql",
      "provides": [
        "world_properties table"
      ]
    },
    "infra.schema.007_character_state_v15": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 007 character state v15."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/007_character_state_v15.sql",
      "provides": [
        "characters.attributes column"
      ]
    },
    "infra.schema.007_items": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 007 items."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/007_items.sql",
      "provides": [
        "items table"
      ]
    },
    "infra.schema.008_guilds": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 008 guilds."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/008_guilds.sql",
      "provides": [
        "guild_members table",
        "guilds table"
      ]
    },
    "infra.schema.009_auth": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 009 auth."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/009_auth.sql",
      "provides": [
        "accounts table"
      ]
    },
    "infra.schema.010_characters": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 010 characters."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/010_characters.sql",
      "provides": [
        "characters table",
        "characters.guild_id column"
      ]
    },
    "infra.schema.011_add_account_flags": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Incremental schema/content update: 011 add account flags."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/011_add_account_flags.sql",
      "provides": [
        "accounts.flags column"
      ]
    },
    "infra.schema.012_add_item_grant_flags": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Incremental schema/content update: 012 add item grant flags."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/012_add_item_grant_flags.sql",
      "provides": [
        "items.is_dev_only column"
      ]
    },
    "infra.schema.013_create_staff_action_log": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates database structures for 013 create staff action log."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/013_create_staff_action_log.sql",
      "provides": [
        "staff_action_log table"
      ]
    },
    "infra.schema.014_create_mail_tables": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates database structures for 014 create mail tables."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/014_create_mail_tables.sql",
      "provides": [
        "mail_items table",
        "mailboxes table",
        "mails table"
      ]
    },
    "infra.schema.015_create_trade_log": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates database structures for 015 create trade log."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/015_create_trade_log.sql",
      "provides": [
        "trade_log table"
      ]
    },
    "infra.schema.016_create_vendors": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates database structures for 016 create vendors."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/016_create_vendors.sql",
      "provides": [
        "vendor_items table",
        "vendors table"
      ]
    },
    "infra.schema.017_create_bank_slots": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates database structures for 017 create bank slots."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/017_create_bank_slots.sql",
      "provides": [
        "bank_slots table"
      ]
    },
    "infra.schema.018_create_auctions": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates database structures for 018 create auctions."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/018_create_auctions.sql",
      "provides": [
        "auctions table"
      ]
    },
    "infra.schema.019_create_auction_log": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates database structures for 019 create auction log."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/019_create_auction_log.sql",
      "provides": [
        "auction_log table"
      ]
    },
    "infra.schema.020_add_auction_expires_at": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Incremental schema/content update: 020 add auction expires at."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/020_add_auction_expires_at.sql",
      "provides": [
        "auctions.expires_at column"
      ]
    },
    "infra.schema.021_add_auction_items_reclaimed": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Incremental schema/content update: 021 add auction items reclaimed."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/021_add_auction_items_reclaimed.sql",
      "provides": [
        "auctions.items_reclaimed column"
      ]
    },
    "infra.schema.021_quests": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 021 quests."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/021_quests.sql",
      "provides": [
        "quests table"
      ]
    },
    "infra.schema.022_quest_objectives": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 022 quest objectives."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/022_quest_objectives.sql",
      "provides": [
        "quest_objectives table"
      ]
    },
    "infra.schema.023_quest_rewards": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 023 quest rewards."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/023_quest_rewards.sql",
      "provides": [
        "quest_rewards table"
      ]
    },
    "infra.schema.024_npcs": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 024 npcs."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/024_npcs.sql",
      "provides": [
        "npcs table"
      ]
    },
    "infra.schema.025_bank_accounts": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 025 bank accounts."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/025_bank_accounts.sql",
      "provides": [
        "bank_accounts table"
      ]
    },
    "infra.schema.026_add_owner_kind_to_bank": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Incremental schema/content update: 026 add owner kind to bank."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/026_add_owner_kind_to_bank.sql",
      "provides": [
        "bank_slots.owner_kind column"
      ]
    },
    "infra.schema.027_add_talk_to_objective": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Incremental schema/content update: 027 add talk to objective."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/027_add_talk_to_objective.sql",
      "provides": [
        "quest_objective_kind enum: talk_to"
      ]
    },
    "infra.schema.028_spawn_points_proto_variant": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Database migration: 028 spawn points proto variant."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/028_spawn_points_proto_variant.sql",
      "provides": [
        "spawn_points.proto_id column"
      ]
    },
    "infra.schema.030_trade_recipes": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Tradeskills v1: introduces DB-backed recipes as authoritative content source.",
        "Inputs/outputs stored as separate tables for easy extension (stations, skill reqs, tools)."
      ],
      "owns": [
        "DB schema for DB-backed tradeskill recipes",
        "FK constraints into items(id)",
        "Indexes for recipe category lookups"
      ],
      "path": "worldcore/infra/schema/030_trade_recipes.sql",
      "provides": [
        "trade_recipes table",
        "trade_recipe_inputs table",
        "trade_recipe_outputs table"
      ]
    },
    "infra.schema.033_trade_recipes_station_kind": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.030_trade_recipes"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Nullable station_kind enables Crafting Stations v0 without breaking existing recipes.",
        "Enforcement is handled in craftCommand behind PW_CRAFT_STATIONS_REQUIRED=1."
      ],
      "owns": [
        "Crafting station requirement schema for trade recipes"
      ],
      "path": "worldcore/infra/schema/033_trade_recipes_station_kind.sql",
      "provides": [
        "trade_recipes.station_kind",
        "idx_trade_recipes_station_kind"
      ]
    },
    "infra.schema.035_skin_loot_v1": {
      "class": "(sql)",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.007_items"
      ],
      "kind": "schema",
      "lifecycle": "static",
      "owns": [],
      "path": "worldcore/infra/schema/035_skin_loot_v1.sql",
      "provides": [
        "skin_loot table for DB-backed skinning loot profiles (proto and/or tag targeting)"
      ],
      "service": "infra"
    },
    "infra.schema.036_seed_skin_loot_v1": {
      "class": "(sql)",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.035_skin_loot_v1"
      ],
      "kind": "schema_seed",
      "lifecycle": "static",
      "owns": [],
      "path": "worldcore/infra/schema/036_seed_skin_loot_v1.sql",
      "provides": [
        "minimal beast/critter starter skin loot rows (hide_scraps)"
      ],
      "service": "infra"
    },
    "infra.schema.037_add_town_tier_v1": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Incremental schema/content update: 037 add town tier v1."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/037_add_town_tier_v1.sql",
      "provides": [
        "spawn_points.town_tier column"
      ]
    },
    "infra.schema.039_fix_town_rat_tags_v1": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Incremental schema/content update: 039 fix town rat tags v1."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/039_fix_town_rat_tags_v1.sql",
      "provides": [
        "town_rat npc tag fix in npcs"
      ]
    },
    "infra.schema.040_create_spells_table": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates database structures for 040 create spells table."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/040_create_spells_table.sql",
      "provides": [
        "public table"
      ]
    },
    "infra.schema.042_create_abilities_catalog": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Creates abilities catalog table (id/name/description/kind/resource/cooldown/flags/role gates).",
        "Enables Abilities panel to behave like Spellbook: catalog + unlocks split."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/042_create_abilities_table.sql",
      "provides": []
    },
    "infra.schema.042_create_ability_unlocks": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Creates ability_unlocks table for DB-driven ability progression (class_id + ability_id + min_level + auto_grant).",
        "Mirrors spell_unlocks model; supports abilities catalog join."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/042_create_ability_unlocks_table.sql",
      "provides": []
    },
    "infra.schema.043_create_npc_loot_table": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates database structures for 043 create npc loot table."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/043_create_npc_loot_table.sql",
      "provides": [
        "public table"
      ]
    },
    "infra.schema.045_create_vendor_log": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Creates vendor_log for buy/sell auditing (ts, shard_id, actor, vendor, item, gold, result, meta)."
      ],
      "owns": [
        "Vendor transaction audit log"
      ],
      "path": "worldcore/infra/schema/045_create_vendor_log.sql",
      "provides": [
        "vendor_log table"
      ]
    },
    "infra.schema.046_vendor_economy_realism_v1": {
      "class": "SchemaMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.045_create_vendor_log"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Economy Realism v1: persistent vendor stock + restock knobs + price curve multipliers."
      ],
      "owns": [
        "Vendor stock persistence",
        "Restock + price-curve configuration"
      ],
      "path": "worldcore/infra/schema/046_vendor_economy_realism_v1.sql",
      "provides": [
        "vendor_item_economy table",
        "vendor_item_state table"
      ]
    },
    "infra.schema.047_vendor_economy_realism_v1_1": {
      "dependsOn": [
        "infra.schema.046_vendor_economy_realism_v1"
      ],
      "kind": "migration",
      "notes": [
        "Economy Realism v1.1: adds cadence fields to vendor_item_economy and backfills them from legacy restock_per_hour."
      ],
      "path": "worldcore/infra/schema/047_vendor_economy_realism_v1_1.sql",
      "provides": [
        "vendor_item_economy cadence fields (restock_every_sec, restock_amount)"
      ]
    },
    "infra.schema.048_create_cities": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Conservative: no triggers; region_id nullable; meta jsonb for early iteration."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/048_create_cities.sql",
      "provides": [
        "cities table (account-owned, shard-scoped) with UNIQUE(account_id, shard_id)",
        "CityBuilder v0 persistence foundation (prevents 1 city per character exploits)"
      ]
    },
    "infra.schema.049_create_spell_unlocks": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Creates spell_unlocks table for DB-driven spell/song progression."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/049_create_spell_unlocks_table.sql",
      "provides": []
    },
    "infra.schema.050_add_spell_effect_payloads_v1": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Adds status-effect payload columns/JSON to spells (status_effect, cleanse, etc) for System I MVP."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/050_add_spell_effect_payloads_v1.sql",
      "provides": []
    },
    "infra.schema.056_seed_crusader_class_kit_L1_10": {
      "kind": "schema",
      "lifecycle": "migration/seed",
      "notes": [
        "Adds unique Crusader spells instead of mapping to templar kit.",
        "Deletes old templar-mapped unlocks for Crusader (notes=wave1 kit: templar map)."
      ],
      "owns": [
        "public.spells (crusader_*)",
        "public.spell_unlocks (crusader, wave1 kit)"
      ],
      "path": "worldcore/infra/schema/056_seed_crusader_class_kit_L1_10.sql",
      "provides": [
        "Crusader L1\u201310 spell kit (spells + unlocks)"
      ],
      "service": "worldcore"
    },
    "infra.schema.057_seed_hunter_spellkit_L1_10": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds Hunter reference kit into DB (idempotent)."
      ],
      "owns": [
        "public.spells (hunter_*)",
        "public.spell_unlocks (hunter, wave1 kit)"
      ],
      "path": "worldcore/infra/schema/057_seed_hunter_spellkit_L1_10.sql",
      "provides": [
        "Hunter L1\u201310 spell kit (spells + unlocks)"
      ]
    },
    "infra.schema.058_cleanup_hunter_spellkit_L1_10": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Removes duplicate/merged Hunter definitions from earlier passes and keeps canonical ids."
      ],
      "owns": [
        "public.spells (hunter_*)",
        "public.spell_unlocks (hunter, wave1 kit)"
      ],
      "path": "worldcore/infra/schema/058_cleanup_hunter_spellkit_L1_10.sql",
      "provides": [
        "Hunter L1\u201310 spell kit cleanup (canonical ids + no duplicates)"
      ]
    },
    "infra.schema.059_seed_illusionist_spellkit_L1_10": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds Illusionist reference kit into DB (idempotent).",
        "v0 control semantics use damageDealtPct suppression until movement/action gating exists."
      ],
      "owns": [
        "public.spells (illusionist_*)",
        "public.spell_unlocks (illusionist, wave1 kit)"
      ],
      "path": "worldcore/infra/schema/059_seed_illusionist_spellkit_L1_10.sql",
      "provides": [
        "Illusionist L1\u201310 spell kit (spells + unlocks)"
      ]
    },
    "infra.schema.059_seed_runic_knight_spellkit_L1_10": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds Runic Knight reference kit into DB (idempotent)."
      ],
      "owns": [
        "public.spells (runic_knight_*)",
        "public.spell_unlocks (runic_knight, wave1 kit)"
      ],
      "path": "worldcore/infra/schema/059_seed_runic_knight_spellkit_L1_10.sql",
      "provides": [
        "Runic Knight L1\u201310 spell kit (spells + unlocks)"
      ]
    },
    "infra.schema.060_seed_ascetic_spellkit_L1_10": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds Ascetic reference kit into DB (idempotent).",
        "Chi is normalized to 100 and is built by Jab on successful use."
      ],
      "owns": [
        "public.spells (ascetic_*)",
        "public.spell_unlocks (ascetic, wave1 kit)"
      ],
      "path": "worldcore/infra/schema/060_seed_ascetic_spellkit_L1_10.sql",
      "provides": [
        "Ascetic L1\u201310 spell kit (spells + unlocks)",
        "Introduces Chi (primary resource) for Ascetic"
      ]
    },
    "infra.schema.061_seed_prophet_spellkit_L1_10": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds Prophet reference kit into DB (idempotent).",
        "Uses existing status-effect spine (dot + absorb shield + buff)."
      ],
      "owns": [
        "public.spells (prophet_*)",
        "public.spell_unlocks (prophet, wave1 kit)"
      ],
      "path": "worldcore/infra/schema/061_seed_prophet_spellkit_L1_10.sql",
      "provides": [
        "Prophet L1\u201310 spell kit (spells + unlocks)",
        "Wave1 shaman-ish DOT/shield/buff/heal baseline"
      ]
    },
    "infra.schema.062_seed_hierophant_spellkit_L1_10": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds Hierophant reference kit into DB (idempotent).",
        "Uses existing status-effect spine (hot + dot + buff + debuff)."
      ],
      "owns": [
        "public.spells (hierophant_*)",
        "public.spell_unlocks (hierophant, wave1 kit)"
      ],
      "path": "worldcore/infra/schema/062_seed_hierophant_spellkit_L1_10.sql",
      "provides": [
        "Hierophant L1\u201310 spell kit (spells + unlocks)",
        "Wave1 nature HOT/DOT/buff baseline"
      ]
    },
    "infra.schema.063_seed_revenant_spellkit_L1_10": {
      "class": "(sql) infra schema migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds Revenant reference kit into DB (idempotent).",
        "Uses existing status-effect spine (dot + absorb shield + debuff).",
        "No pet/minion verbs in Wave1; undead summoning arrives with the Pet Engine milestone."
      ],
      "owns": [
        "public.spells (revenant_*)",
        "public.spell_unlocks (revenant, wave1 kit)"
      ],
      "path": "worldcore/infra/schema/063_seed_revenant_spellkit_L1_10.sql",
      "provides": [
        "Revenant L1\u201310 spell kit (spells + unlocks)",
        "Wave1 shadow knight DOT/shield/debuff baseline"
      ]
    },
    "infra.seed.029_seed_crafting_items_v1": {
      "class": "SeedMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.007_items",
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Seeds baseline content for 029 seed crafting items v1."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/029_seed_crafting_items_v1.sql",
      "provides": [
        "seed rows for items"
      ]
    },
    "infra.seed.031_trade_recipes_v1": {
      "class": "SeedMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.030_trade_recipes",
        "infra.schema.007_items",
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Tradeskills v1 baseline DB recipes.",
        "Safe to re-run; uses ON CONFLICT UPSERT patterns."
      ],
      "owns": [
        "Baseline recipe seeds using UPSERT",
        "Inputs/outputs rows for each seeded recipe"
      ],
      "path": "worldcore/infra/schema/031_seed_trade_recipes_v1.sql",
      "provides": [
        "smelt_iron_ingot recipe (DB)",
        "brew_minor_heal recipe (DB)"
      ]
    },
    "infra.seed.032_trade_recipes_cooking_v1": {
      "class": "SeedMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.030_trade_recipes",
        "infra.schema.007_items",
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Migrates RecipeCatalog cooking recipes into DB so crafting is DB-authoritative.",
        "Safe to re-run."
      ],
      "owns": [
        "Starter cooking recipe seeds (UPSERT)",
        "Deterministic inputs/outputs replacement per recipe"
      ],
      "path": "worldcore/infra/schema/032_seed_trade_recipes_cooking_v1.sql",
      "provides": [
        "cook_river_trout (DB recipe seed)",
        "mill_wheat_flour (DB recipe seed)",
        "bake_simple_bread (DB recipe seed)"
      ]
    },
    "infra.seed.034_trade_recipes_station_kinds_v1": {
      "class": "SeedMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.033_trade_recipes_station_kind"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "owns": [
        "Station policy for starter recipes: campfire portable; forge/alchemy_table/millstone/oven town-only"
      ],
      "path": "worldcore/infra/schema/034_seed_trade_recipes_station_kinds_v1.sql",
      "provides": [
        "Starter recipe station_kind assignments"
      ]
    },
    "infra.seed.038_seed_skin_loot_town_rat_v1": {
      "class": "SeedMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.035_skin_loot_v1",
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Seeds baseline content for 038 seed skin loot town rat v1."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/038_seed_skin_loot_town_rat_v1.sql",
      "provides": [
        "seed rows for skin_loot"
      ]
    },
    "infra.seed.041_seed_spells_mvp": {
      "class": "SeedMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.040_create_spells_table",
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Seeds baseline content for 041 seed spells mvp."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/041_seed_spells_mvp.sql",
      "provides": [
        "seed rows for public"
      ]
    },
    "infra.seed.042_seed_abilities_from_unlocks": {
      "class": "(sql) infra seed migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Ensures abilities catalog rows exist for any ability referenced by ability_unlocks (safe upsert).",
        "Title-cases id into name when missing; does not overwrite existing descriptions."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/042_seed_abilities_from_unlocks.sql",
      "provides": []
    },
    "infra.seed.042_seed_ability_unlocks_mvp": {
      "class": "(sql) infra seed migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds MVP warrior ability unlocks for early UI/progression testing."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/042_seed_ability_unlocks_mvp.sql",
      "provides": []
    },
    "infra.seed.044_npc_loot_seed_v0": {
      "class": "SeedMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.043_create_npc_loot_table",
        "infra.schema.007_items",
        "infra.schema.024_npcs",
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Seeds baseline content for 044 npc loot seed v0."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/044_npc_loot_seed_v0.sql",
      "provides": [
        "seed rows for public"
      ]
    },
    "infra.seed.049_seed_spell_unlocks_from_spells": {
      "class": "(sql) infra seed migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Bootstrap seed: derives initial spell_unlocks rows from spells catalog."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/049_seed_spell_unlocks_from_spells.sql",
      "provides": []
    },
    "infra.seed.050_seed_reference_class_kits_L1_10": {
      "class": "(sql) infra seed migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds Reference Class Kits L1\u201310 (MVP) used by deterministic progression tests."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/050_seed_reference_class_kits_L1_10.sql",
      "provides": []
    },
    "infra.seed.050_seed_reference_status_effect_spells_v1": {
      "class": "(sql) infra seed migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds reference status effect spells (cleanse/HoT/shield/DOT) for System I MVP."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/050_seed_reference_status_effect_spells_v1.sql",
      "provides": []
    },
    "infra.seed.050_seed_spells_reference_kits_l1_10": {
      "class": "(sql) infra seed migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds spells catalog entries referenced by the L1\u201310 class kits."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/050_seed_spells_reference_kits_l1_10.sql",
      "provides": []
    },
    "infra.seed.051_seed_spell_unlocks_reference_kits_l1_10": {
      "class": "(sql) infra seed migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds spell_unlocks for L1\u201310 reference kits; enables deterministic autogrant tests."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/051_seed_spell_unlocks_reference_kits_l1_10.sql",
      "provides": []
    },
    "infra.seed.052_seed_npcs_training_dummies_and_civilian_v1": {
      "class": "SeedMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.024_npcs",
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Seeds training dummies and a protected town civilian prototype.",
        "Training dummies are explicitly law-exempt so guard/crime logic never reacts to DPS testing.",
        "Idempotent UPSERT into npcs(id)."
      ],
      "owns": [
        "Law tag correctness for training_dummy*",
        "Baseline town civilian prototype used by guard/crime tests"
      ],
      "path": "worldcore/infra/schema/052_seed_npcs_training_dummies_and_civilian_v1.sql",
      "provides": [
        "training_dummy NPC prototype",
        "training_dummy_big NPC prototype",
        "town_civilian NPC prototype",
        "seed rows for npcs"
      ]
    },
    "infra.seed.053_seed_basic_loot_items_v1": {
      "class": "SeedMigration",
      "ctorArgs": [],
      "dependsOn": [
        "infra.schema.007_items",
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "migration",
      "notes": [
        "Seeds minimal items required by early loot + tradeskill seeds (so npc_loot/skin_loot/recipes don't dangle).",
        "Idempotent UPSERT keyed by items(id)."
      ],
      "owns": [
        "Baseline item ids referenced by npc_loot and skin_loot seeds (rat_tail, rat_meat_raw, ore_iron_hematite)"
      ],
      "path": "worldcore/infra/schema/053_seed_basic_loot_items_v1.sql",
      "provides": [
        "seed rows for items",
        "ore_iron_hematite item",
        "rat_tail item",
        "rat_meat_raw item"
      ]
    },
    "infra.seed.054_seed_common_class_kits_L1_10": {
      "class": "(sql) infra seed migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Seeds a minimal common L1\u201310 spell kit (damage + dot + debuff + shield + hot) for classes that do not yet have bespoke kits.",
        "Designed to keep every class playable while per-class kits are authored later."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/054_seed_common_class_kits_L1_10.sql",
      "provides": []
    },
    "infra.seed.055_seed_wave1_class_kit_mappings_L1_10": {
      "class": "(sql) infra seed migration",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Wave 1 bootstrap: maps not-yet-bespoke classes onto proven kits (templar/archmage/warlock spells; warrior abilities).",
        "Also updates mapped kit spell rows in public.spells to class_id='any' so cross-class unlocks can actually surface in runtime/UI queries.",
        "Idempotent UPSERTs (ON CONFLICT DO UPDATE) so re-running seeds is safe.",
        "Intentionally does not touch Adventurer (special anti-datamine class rules)."
      ],
      "owns": [],
      "path": "worldcore/infra/schema/055_seed_wave1_class_kit_mappings_L1_10.sql",
      "provides": []
    },
    "interaction.ops": {
      "dependsOn": [
        "targeting.finders"
      ],
      "functions": [
        "interactInRoom"
      ],
      "kind": "service",
      "notes": [
        "Handles 'interact <what>' / 'use <what>' style interactions in the current room.",
        "Resolves NPC target by name and returns flavored text, with optional quest-log-based hints."
      ],
      "path": "worldcore/interaction/interactOps.ts"
    },
    "items.catalog": {
      "dependsOn": [
        "items.types"
      ],
      "functions": [
        "getItemTemplate",
        "listAllItems"
      ],
      "kind": "model",
      "notes": [
        "Static built-in item templates for starter gear, rat loot, and basic ore (plus a minimal instrument item for Virtuoso testing).",
        "Used as a fallback when DB-backed items are missing (e.g., debug_give and early/dev-only items).",
        "Convention: gear stats may include instrumentPct and instrumentPctBySchool for song scaling."
      ],
      "path": "worldcore/items/ItemCatalog.ts"
    },
    "items.config": {
      "kind": "config",
      "notes": [
        "Item-related runtime config; currently defines defaultOverflowPolicy used by ItemService."
      ],
      "path": "worldcore/items/ItemConfig.ts"
    },
    "items.display": {
      "dependsOn": [
        "items.service",
        "items.catalog",
        "items.types",
        "utils.colors"
      ],
      "functions": [
        "formatItemLabel",
        "formatItemDefinition",
        "formatItemTemplate",
        "getItemRarityColorCode",
        "getItemTooltip"
      ],
      "kind": "service",
      "notes": [
        "Builds human-readable labels and tooltips from DB-backed items or static templates.",
        "Maps item rarity to ANSI color codes for console output."
      ],
      "path": "worldcore/items/ItemDisplay.ts"
    },
    "items.economy": {
      "dependsOn": [
        "items.catalog"
      ],
      "functions": [
        "getItemSellValue"
      ],
      "kind": "service",
      "notes": [
        "Computes base vendor sell value for an item in gold based on template.baseValue.",
        "Returns 0 for unsellable or unknown items."
      ],
      "path": "worldcore/items/ItemEconomy.ts"
    },
    "items.equipmentOps": {
      "dependsOn": [
        "utils.logger",
        "items.catalog",
        "items.inventoryHelpers",
        "mail.service",
        "characters.service?",
        "loot.OverflowDelivery"
      ],
      "functions": [
        "equipFirstMatchingFromBags",
        "unequipToBags"
      ],
      "kind": "service",
      "notes": [
        "High-level equipment swap logic operating on character.inventory and equipment.",
        "Handles bag overflow via OverflowDelivery; refuses equip/unequip when it cannot safely deliver displaced gear (bags full and mail unavailable)."
      ],
      "path": "worldcore/items/equipmentOps.ts"
    },
    "items.grantRules": {
      "dependsOn": [
        "auth.staffRoles",
        "config.shardConfig",
        "items.types"
      ],
      "functions": [
        "canGrantItemToPlayer"
      ],
      "kind": "service",
      "notes": [
        "Enforces staff role and shard mode rules for granting items to players.",
        "Blocks low-ranked staff or dev-only items on live shards unless actor role is high enough."
      ],
      "path": "worldcore/items/ItemGrantRules.ts"
    },
    "items.inventoryConsume": {
      "dependsOn": [
        "characters.types"
      ],
      "functions": [
        "countItemInInventory",
        "consumeItemFromInventory",
        "canConsumeRecipe",
        "consumeRecipe"
      ],
      "kind": "utility",
      "notes": [
        "Counts and consumes items in inventory across all bags.",
        "Provides helpers to check and consume crafting recipe inputs for a given count."
      ],
      "path": "worldcore/items/inventoryConsume.ts"
    },
    "items.inventoryHelpers": {
      "dependsOn": [
        "characters.types"
      ],
      "functions": [
        "findFreeBagSlot",
        "addItemToInventory",
        "addItemToBags",
        "addCurrency",
        "getCurrency",
        "setCurrency",
        "getGold",
        "setGold"
      ],
      "kind": "utility",
      "notes": [
        "Core bag and currency helpers operating on InventoryState.",
        "addItemToBags performs stack-aware item addition; addItemToInventory is a deprecated simple helper."
      ],
      "path": "worldcore/items/InventoryHelpers.ts"
    },
    "items.inventoryRemove": {
      "dependsOn": [
        "characters.types"
      ],
      "functions": [
        "removeItemFromBags"
      ],
      "kind": "utility",
      "notes": [
        "Removes up to a given quantity of an item from all bags in-place.",
        "Returns how many were removed vs leftover."
      ],
      "path": "worldcore/items/InventoryRemove.ts"
    },
    "items.inventoryTest": {
      "kind": "dev_script",
      "notes": [
        "Standalone Node script to sanity-check ItemService + inventory add/remove behavior.",
        "Uses defaultInventory(), adds huge stacks, then removes items and logs bag state."
      ],
      "path": "worldcore/items/InventoryTest.ts"
    },
    "items.inventoryView": {
      "dependsOn": [
        "items.display"
      ],
      "functions": [
        "buildInventoryLines"
      ],
      "kind": "service",
      "notes": [
        "Builds text lines describing currency and bag contents using formatted item labels.",
        "Used by the 'inventory' command to render a readable inventory view."
      ],
      "path": "worldcore/items/inventoryView.ts"
    },
    "items.overflowPolicy": {
      "kind": "types",
      "notes": [
        "String union type for overflow behavior: 'drop', 'destroy', or 'mail'.",
        "Used by ItemService.addToInventory to decide how to handle leftover quantities."
      ],
      "path": "worldcore/items/OverflowPolicy.ts"
    },
    "items.resolve": {
      "dependsOn": [
        "items.service",
        "items.catalog",
        "items.types"
      ],
      "functions": [
        "resolveItem"
      ],
      "kind": "service",
      "notes": [
        "Resolves an itemId to a runtime template using DB-backed ItemService first, then static ItemCatalog.",
        "Normalizes category/baseValue fields when pulling from DB."
      ],
      "path": "worldcore/items/resolveItem.ts"
    },
    "items.resolvedItem": {
      "kind": "model",
      "notes": [
        "Unified runtime item type combining DB-backed definitions and static templates.",
        "Suitable for inventories, loot drops, and gameplay without caring about source."
      ],
      "path": "worldcore/items/ResolvedItem.ts"
    },
    "items.service": {
      "class": "ItemService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "items.types",
        "characters.types",
        "items.inventoryHelpers",
        "items.inventoryRemove",
        "items.config",
        "items.overflowPolicy"
      ],
      "functions": [
        "loadAll",
        "ensureLoaded",
        "get",
        "has",
        "findByIdOrName",
        "listAll",
        "listByCategory",
        "addToInventory",
        "removeFromInventory"
      ],
      "kind": "service",
      "notes": [
        "Postgres-backed item definition cache and inventory mutation helper.",
        "Adds items with stack logic and handles overflow via destroy/mail/drop policies."
      ],
      "path": "worldcore/items/ItemService.ts"
    },
    "items.types": {
      "functions": [
        "rowToItemDefinition"
      ],
      "kind": "model",
      "notes": [
        "Defines ItemTemplate, ItemDefinition, ItemRow, ItemRarity, and EQUIP_SLOTS/EquipSlot.",
        "rowToItemDefinition converts Postgres rows into runtime ItemDefinition objects."
      ],
      "path": "worldcore/items/ItemTypes.ts"
    },
    "loot.OverflowDelivery": {
      "functions": [
        "deliverItemToBagsOrMail",
        "deliverItemsToBagsOrMail"
      ],
      "kind": "helper",
      "notes": [
        "Central overflow delivery policy: bags-first, overflow-to-mail.",
        "Supports attachment meta + undeliveredPolicy ('drop'|'keep')",
        "Accepts a minimal mail sender surface (sendSystemMail) to support lightweight contexts (e.g., EquipContext)."
      ],
      "path": "worldcore/loot/OverflowDelivery.ts"
    },
    "loot.text": {
      "functions": [
        "describeLootLine"
      ],
      "kind": "service",
      "notes": [
        "Formats a single loot line like '2x Rat Tail' or 'Rat Tail' based on quantity and optional display name.",
        "Clamps qty to >= 0 and falls back to the itemId when itemName is not provided."
      ],
      "path": "worldcore/loot/lootText.ts"
    },
    "mail.postgres": {
      "class": "PostgresMailService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "mail.types",
        "mail.service",
        "economy.helpers"
      ],
      "kind": "service",
      "notes": [
        "Postgres-backed implementation of MailService using mailboxes, mails, and mail_items tables.",
        "Supports system mail with JSONB metadata and attachment claiming via giveItemsToCharacter."
      ],
      "path": "worldcore/mail/PostgresMailService.ts"
    },
    "mail.service": {
      "kind": "service_contract",
      "notes": [
        "MailService interface: getOrCreateMailbox, listMail, getMail, markRead, sendSystemMail, claimAttachments.",
        "claimAttachments uses ItemService.addToInventory; leftover can be handled by caller (or mailed via OverflowDelivery when appropriate)."
      ],
      "path": "worldcore/mail/MailService.ts"
    },
    "mail.types": {
      "kind": "model",
      "notes": [
        "Defines MailOwnerKind ('account'|'character'), MailAttachment, MailSummary, and MailDetail.",
        "MailSummary carries read/hasAttachments flags; MailDetail adds body and attachments."
      ],
      "path": "worldcore/mail/MailTypes.ts"
    },
    "movement.commands": {
      "dependsOn": [
        "world.manager"
      ],
      "functions": [
        "parseMoveDir",
        "tryMoveCharacter"
      ],
      "kind": "service",
      "notes": [
        "Parses movement directions like 'n', 'north', 'sw', 'southwest' into MoveDir.",
        "tryMoveCharacter applies server-authoritative X/Z movement and rejects steps that leave the world/region."
      ],
      "path": "worldcore/movement/MovementCommands.ts"
    },
    "movement.ops": {
      "dependsOn": [
        "movement.commands",
        "utils.logger",
        "core.entities",
        "characters.service?"
      ],
      "functions": [
        "moveCharacterAndSync"
      ],
      "kind": "service",
      "notes": [
        "High-level movement op that calls tryMoveCharacter, syncs the entity position, and best-effort persists the character position.",
        "Uses a MoveOpsContext with session/entities/characters to avoid hard coupling to full services."
      ],
      "path": "worldcore/movement/moveOps.ts"
    },
    "mud.abilities": {
      "kind": "service",
      "lifecycle": "stateless",
      "path": "worldcore/mud/MudAbilities.ts",
      "dependsOn": [
        "mud.context",
        "abilities.types",
        "abilities.unlocks",
        "abilities.learning",
        "resources.power",
        "combat.castingGates",
        "combat.statusEffects",
        "combat.serviceProtection",
        "targeting.resolver",
        "npc.types",
        "items.inventoryHelpers",
        "mud.actions.combat"
      ],
      "provides": [
        "handleAbilityCommand(ctx:MudContext, char:CharacterState, abilityName:string, targetName?:string):Promise<string>",
        "listKnownAbilitiesForChar(char:CharacterState):AbilityDefinition[]"
      ],
      "notes": [
        "Implements 'abilities' and 'ability <name> [target]'.",
        "Guarantee: deny-path gates (target validation + service protection + stealth requirements) happen BEFORE cost/cooldown gates.",
        "Cutthroat: stealth toggle + stealth-required abilities (pickpocket/backstab/mug) + breaks-stealth semantics."
      ]
    },
    "mud.actions": {
      "dependsOn": [
        "mud.actions.combat",
        "mud.actions.recovery",
        "mud.actions.world"
      ],
      "kind": "facade",
      "notes": [
        "Re-export hub for MUD actions.",
        "Older imports from '../MudActions' stay valid while we refactor call sites."
      ],
      "path": "worldcore/mud/MudActions.ts"
    },
    "mud.actions.combat": {
      "dependsOn": [
        "mud.context",
        "combat.npc",
        "mud.trainingDummy",
        "mud.progressionHooks",
        "progression.core",
        "combat.damagePolicy"
      ],
      "kind": "service",
      "lifecycle": "stateless",
      "notes": [
        "Preferred combat action module for 'attack' and shared action pipeline.",
        "Thin wrapper over shared NpcCombat module plus training dummy integration."
      ],
      "path": "worldcore/mud/actions/MudCombatActions.ts",
      "provides": [
        "performNpcAttack(ctx, char, selfEntity, npc, opts?):Promise<string>",
        "scheduleNpcCorpseAndRespawn(ctx, npcEntityId):void",
        "announceSpawnToRoom(ctx, roomId, text):void",
        "handleAttackAction(ctx, char, targetNameRaw):Promise<string>",
        "handleTauntAction(ctx, char, targetNameRaw):Promise<string>"
      ]
    },
    "mud.actions.legacy": {
      "dependsOn": [
        "mud.context",
        "core.entities",
        "core.rooms",
        "world.manager",
        "world.npcs?",
        "items.service?",
        "progression.core",
        "mud.progressionHooks",
        "mud.trainingDummy",
        "resources.power?",
        "skills.progression?",
        "world.respawns?"
      ],
      "kind": "legacy_service",
      "lifecycle": "stateless",
      "notes": [
        "Older monolithic MUD action set; being replaced by mud.actions.combat and mud.actions.world.",
        "Still referenced by some modules; refactor target once new actions are fully wired."
      ],
      "path": "worldcore/mud/MudActions.ts",
      "provides": [
        "performNpcAttack(ctx, char, selfEntity, npc, opts?)",
        "handleAttackAction(ctx, char, targetNameRaw)",
        "handleGatherAction(ctx, char, targetNameRaw, gatheringKind, resourceTag)",
        "scheduleNpcCorpseAndRespawn(ctx, npcEntityId)",
        "announceSpawnToRoom(ctx, roomId, text)"
      ]
    },
    "mud.actions.recovery": {
      "dependsOn": [],
      "kind": "service",
      "lifecycle": "stateless",
      "notes": [
        "Reserved for future rest/sleep/recovery commands; currently an empty module."
      ],
      "path": "worldcore/mud/actions/MudRecoveryActions.ts",
      "provides": []
    },
    "mud.actions.world": {
      "dependsOn": [
        "mud.context",
        "world.npcs",
        "core.entities",
        "world.manager",
        "items.service?",
        "progression.core",
        "mud.progressionHooks"
      ],
      "kind": "service",
      "lifecycle": "stateless",
      "notes": [
        "Implements 'harvest' actions (mining/herbalism/etc.).",
        "Handles node validation, loot rolls, depletion timestamps, and node/NPC despawn.",
        "Includes skinning fallback helper used by tests; real skinning loot will become DB-driven.",
        "Safety: harvest progression reactions are guarded (applyProgressionForEvent wrapped in try/catch) so gathering never hard-fails."
      ],
      "path": "worldcore/mud/actions/MudWorldActions.ts",
      "provides": [
        "handleGatherAction(ctx, char, targetNameRaw, gatheringKind, resourceTag):Promise<string>",
        "applyFallbackSkinLoot(protoId): { itemId, minQty, maxQty } | null"
      ]
    },
    "mud.autoattack": {
      "dependsOn": [
        "mud.context",
        "core.sessions",
        "core.entities",
        "characters.stats",
        "combat.entityCombat",
        "utils.logger"
      ],
      "functions": [
        "startTrainingDummyAutoAttack",
        "stopAutoAttack"
      ],
      "kind": "service",
      "notes": [
        "Manages per-session autoattack timers and interactions with the Training Dummy.",
        "Uses character effective attributes and entity health to simulate periodic swings."
      ],
      "path": "worldcore/mud/commands/combat/autoattack/trainingDummyAutoAttack.ts"
    },
    "mud.combatGates": {
      "dependsOn": [
        "pvp.duels",
        "pvp.rules",
        "world.regionFlags"
      ],
      "functions": [
        "gatePlayerDamageFromPlayerEntity(ctx:MudContext, attackerChar:CharacterState, roomId:string, playerTargetEntity:any):Promise<PlayerDamageGateResult>"
      ],
      "kind": "utility",
      "lifecycle": "stateless",
      "notes": [
        "Centralized PvP/duel gating for MUD entrypoints (attack, cast, etc.).",
        "Ticks DuelService time, checks region PvP enablement, then delegates final policy to canDamagePlayer."
      ],
      "path": "worldcore/mud/MudCombatGates.ts"
    },
    "mud.commands.bank": {
      "dependsOn": [
        "mud.context",
        "bank.ops",
        "items.service",
        "core.sessions?"
      ],
      "function": "handleBankCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Front-end for banking operations (deposit/withdraw/etc.).",
        "Chooses owner as account vs character based on session identity."
      ],
      "path": "worldcore/mud/commands/bankCommand.ts"
    },
    "mud.commands.combat.ability": {
      "dependsOn": [
        "mud.context",
        "mud.abilities",
        "mud.handles.nearbyHandles"
      ],
      "function": "handleAbilityMudCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'ability <name> [target]'.",
        "Delegates validation and execution to MudAbilities.handleAbilityCommand."
      ],
      "path": "worldcore/mud/commands/combat/abilityCommand.ts"
    },
    "mud.commands.combat.attack": {
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.combat"
      ],
      "function": "handleAttackCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'attack <target>'.",
        "Parses targetNameRaw and routes to handleAttackAction."
      ],
      "path": "worldcore/mud/commands/combat/attackCommand.ts"
    },
    "mud.commands.combat.autoattack": {
      "dependsOn": [
        "mud.context",
        "mud.autoattack",
        "mud.trainingDummy"
      ],
      "function": "handleAutoAttackCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'autoattack [on|off]'.",
        "Looks up TrainingDummyDeps from input.services.trainingDummy and toggles autoattack on/off."
      ],
      "path": "worldcore/mud/commands/combat/autoAttackCommand.ts"
    },
    "mud.commands.combat.cast": {
      "dependsOn": [
        "mud.context",
        "mud.spells"
      ],
      "function": "handleCastMudCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'cast <name> [target]'.",
        "Delegates to MudSpells.handleCastCommand for spell gating + effects."
      ],
      "path": "worldcore/mud/commands/combat/castCommand.ts"
    },
    "mud.commands.combat.taunt": {
      "dependsOn": [
        "mud.context",
        "mud.actions.combat",
        "npc.manager",
        "npc.threat"
      ],
      "function": "handleTauntCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'taunt [target]'.",
        "If no target is provided, taunt uses the player's engaged target (deny-by-default).",
        "Routes to handleTauntAction, which applies a temporary forced-target threat override on the NPC."
      ],
      "path": "worldcore/mud/commands/combat/tauntCommand.ts"
    },
    "mud.commands.craft": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "tradeskills.tradeRecipeService",
        "items.inventoryHelpers",
        "items.inventoryConsume",
        "mud.progression",
        "core.entityManager",
        "loot.OverflowDelivery"
      ],
      "kind": "mud_command",
      "lifecycle": "pure",
      "notes": [
        "Implements 'craft list' and 'craft <id|name> [count]'.",
        "DB-backed recipes (TradeRecipeService) with fallback to RecipeCatalog.",
        "Optional station enforcement via PW_CRAFT_STATIONS_REQUIRED=1.",
        "Station proximity currently checks entities in the room."
      ],
      "owns": [],
      "path": "worldcore/mud/commands/craftCommand.ts",
      "provides": [
        "mud.command.craft"
      ],
      "service": "mud.commands"
    },
    "mud.commands.debug.debugEffectsCommand": {
      "dependsOn": [
        "mud.context",
        "combat.statusEffects",
        "mud.handles.nearbyHandles"
      ],
      "functions": [
        "handleDebugEffects"
      ],
      "invokedBy": [
        "mud.commands.debug.debug_effects (via mud/commands/registry.ts)"
      ],
      "kind": "mud_command_group",
      "notes": [
        "Debug QoL: inspect active effects + (if available) computed combat snapshot for a target (entity id or nearby handle)."
      ],
      "path": "worldcore/mud/commands/debug/debugEffectsCommand.ts"
    },
    "mud.commands.debug.handlers": {
      "dependsOn": [
        "mud.context",
        "utils.logger",
        "auth.staffAudit",
        "auth.staffRole",
        "auth.debugGate?",
        "items.service",
        "characters.service",
        "mail.service",
        "npc.service",
        "npc.types",
        "npc.spawnController",
        "world.spawnPoints",
        "core.entities",
        "combat.entityCombat",
        "ai.npc.localBrain",
        "world.spawns",
        "db.Database",
        "world.RegionFlags",
        "loot.OverflowDelivery"
      ],
      "functions": [
        "handleDebugGive",
        "handleDebugXp",
        "handleDebugSpawnNpc",
        "handleDebugSpawnRat",
        "handleDebugSpawnOre",
        "handleDebugSpawnsHere",
        "handleEventGiveAny",
        "handleEventMailReward",
        "handleDebugGiveMat",
        "handleDebugResetLevel",
        "handleDebugHurt",
        "handleDebugHydrateHere"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command_group",
      "notes": [
        "Collection of staff/debug/event commands (debug_give, debug_xp, debug_spawn_npc, event_give_any, etc.).",
        "Many of these should be wrapped with withDebugGate before being exposed to normal command routing.",
        "Includes debug_hydrate_here to force region hydration from spawn_points for the current room.",
        "Item grant commands (debug_give/event_give_any/debug_give_mat...) route through OverflowDelivery (bags-first, overflow-to-mail).",
        "Item grants resolve DB items first, then fall back to ItemCatalog when an item is not present in the DB (dev convenience).",
        "event_mail_reward sends explicit system mail (mail as feature)."
      ],
      "path": "worldcore/mud/commands/debug/handlers.ts"
    },
    "mud.commands.debug.hydrateHere": {
      "dependsOn": [
        "auth.debugGate?",
        "mud.commands.debug.withDebugGate",
        "world.spawnPoints",
        "world.spawns",
        "npc.spawnController",
        "core.entities",
        "core.rooms"
      ],
      "function": "handleDebugHydrateHere",
      "invokedBy": [
        "mud.handler",
        "mud.commands.debug.handlers"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'debug_hydrate_here' (staff/dev) to force spawn hydration for the current room/region.",
        "Used to re-run spawn_points-based hydration after moving around without requiring reconnect.",
        "Should remain behind withDebugGate in production."
      ],
      "path": "worldcore/mud/commands/debug/hydrateHere.ts"
    },
    "mud.commands.debug.regionDanger": {
      "dependsOn": [
        "mud.context",
        "world.regionDanger",
        "characters.types"
      ],
      "functions": [
        "handleDebugRegionDanger",
        "handleDebugBumpRegionDanger"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command_group",
      "notes": [
        "Implements 'debug_region_danger [regionId]' for inspecting base tier, current score, sources, and lastUpdated.",
        "Implements 'debug_bump_region_danger <amount> [regionId]' for manually bumping danger score during testing.",
        "Commands are wrapped with withDebugGate in registry.ts and only exposed to dev-level accounts."
      ],
      "path": "worldcore/mud/commands/debug/regionDangerCommands.ts"
    },
    "mud.commands.debug.reload": {
      "dependsOn": [
        "dev.hotReloadService",
        "world.spawnHydrator?",
        "npc.spawnController?",
        "world.spawnPoints?",
        "core.entities?",
        "npc.service?"
      ],
      "function": "handleReloadCommand",
      "invokedBy": [
        "mud.commands.registry",
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Plain reload spawns (no flags) also reconciles personal nodes for the current session + region (despawn stale/moved, respawn from DB).",
        "--here/--region must not touch personal nodes/resources (NPC reconcile only).",
        "Suggested updated note bullets (copy/paste into that entry):",
        "On reload spawns, clears spawn caches and forces SpawnHydrator.rehydrateRoom(force=true) for the current room/region so POIs update immediately.",
        "On plain reload spawns (no flags), also live-reconciles personal nodes/resources for the current session + region (despawn stale/moved spawnPointId entities, respawn from DB) so placement edits apply without reconnect.",
        "--here[=radius] and --region reconcile shared NPC spawn_points only (spawnPointId present, no ownerSessionId); personal nodes/resources remain untouched by these flags."
      ],
      "path": "worldcore/mud/commands/debug/reloadCommand.ts"
    },
    "mud.commands.debug.vulnerability": {
      "dependsOn": [
        "mud.context",
        "combat.vulnerability",
        "characters.types"
      ],
      "function": "handleDebugVulnerability",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'debug_vuln [stacks]' for applying Exposed Weakness to the calling character.",
        "Useful for manually testing vulnerability stacking and damageTakenPct behavior via 'effects' and 'debug_hurt'."
      ],
      "path": "worldcore/mud/commands/debug/vulnerabilityCommands.ts"
    },
    "mud.commands.debug.withDebugGate": {
      "dependsOn": [
        "auth.debugGate"
      ],
      "function": "withDebugGate",
      "kind": "utility",
      "notes": [
        "Higher-order helper that wraps a debug handler and enforces requireDebug(ctx, minRole).",
        "Defaults to minRole='dev'; returns a handler with the same (ctx,char,input) signature."
      ],
      "path": "worldcore/mud/commands/debug/withDebugGate.ts"
    },
    "mud.commands.economy.auction": {
      "dependsOn": [
        "mud.context",
        "auction.service",
        "items.service",
        "characters.service",
        "mail.service",
        "economy.gold",
        "auction.auditLog",
        "auction.format",
        "loot.OverflowDelivery"
      ],
      "function": "handleAuctionCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'ah' / auction house commands: browse, sell, buy, my, claim, cancel, expire, reclaim.",
        "Handles bag removal, proceeds claim, and overflow via mail.",
        "Uses system mail for auction lifecycle delivery (preferred); overflow policy is separate (OverflowDelivery) for non-auction sources."
      ],
      "path": "worldcore/mud/commands/economy/auctionCommand.ts"
    },
    "mud.commands.economy.trade": {
      "dependsOn": [
        "mud.context",
        "trade.service",
        "economy.gold",
        "core.sessions",
        "mud.sessions.lookup"
      ],
      "function": "handleTradeCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'trade' flow: with/start, show/status, additem, addgold, clear, confirm, cancel.",
        "Uses tradeOps.finalizeTrade and sessionLookup helpers to find other player sessions."
      ],
      "path": "worldcore/mud/commands/economy/tradeCommand.ts"
    },
    "mud.commands.economy.vendor": {
      "dependsOn": [
        "mud.context",
        "vendor.service",
        "items.service",
        "characters.service",
        "mail.service",
        "economy.gold",
        "loot.OverflowDelivery",
        "mud.commands.world.serviceGates",
        "mud.handles.nearbyHandles"
      ],
      "function": "handleVendorCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "DB-backed vendor command layer (v0). DB vendor 'id' is authoritative; names/handles are display-only.",
        "Commands: vendor help | vendors | list [vendorId|handle] | buy [vendorId|handle] <index|rowId> [qty] | sell [vendorId|handle] <itemId|index|rowId> [qty].",
        "Quality-of-life: you can omit vendorId to infer the nearest vendor anchor in the current room; you can also pass an entity handle (e.g. alchemist.1).",
        "Proximity gated via requireTownService(ctx, char, 'vendor', ...) to prevent remote shopping; use walkto vendor to get into range.",
        "Buy/sell delegates to VendorTransactions; handles inventory overflow via system mail / OverflowDelivery policies."
      ],
      "path": "worldcore/mud/commands/economy/vendorCommand.ts"
    },
    "mud.commands.gathering.farming": {
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "function": "handleFarmingCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'farm <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, farming, resource_grain).",
        "Enforces farming only works on resource_grain nodes (no cross-tool gathering)."
      ],
      "path": "worldcore/mud/commands/gathering/farmingCommand.ts"
    },
    "mud.commands.gathering.fishing": {
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "function": "handleFishingCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'fish <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, fishing, resource_fish).",
        "Enforces fishing only works on resource_fish nodes."
      ],
      "path": "worldcore/mud/commands/gathering/fishingCommand.ts"
    },
    "mud.commands.gathering.lumbering": {
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "function": "handleLumberingCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'lumber <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, 'lumber', 'resource_wood').",
        "Enforces lumbering only works on resource_wood nodes (no cross-tool gathering)."
      ],
      "path": "worldcore/mud/commands/gathering/lumberingCommand.ts"
    },
    "mud.commands.gathering.mining": {
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "function": "handleMiningCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'mine <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, 'mining', 'resource_ore').",
        "Enforces mining only works on resource_ore nodes (no cross-tool gathering)."
      ],
      "path": "worldcore/mud/commands/gathering/miningCommand.ts"
    },
    "mud.commands.gathering.picking": {
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "function": "handlePickingCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'pick <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, 'herbalism', 'resource_herb').",
        "Enforces picking only works on resource_herb nodes (no cross-tool gathering)."
      ],
      "path": "worldcore/mud/commands/gathering/pickingCommand.ts"
    },
    "mud.commands.gathering.quarrying": {
      "dependsOn": [
        "mud.context",
        "mud.actions",
        "mud.actions.world"
      ],
      "function": "handleQuarryingCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'quarry <target>'.",
        "Delegates to handleGatherAction(ctx, char, targetNameRaw, 'quarry', 'resource_stone').",
        "Enforces quarrying only works on resource_stone nodes (no cross-tool gathering)."
      ],
      "path": "worldcore/mud/commands/gathering/quarryingCommand.ts"
    },
    "mud.commands.gathering.skinning": {
      "class": "(function) handleSkinningCommand",
      "ctorArgs": [],
      "dependsOn": [
        "combat.entityCombat",
        "combat.skinLootService",
        "mud.actions.world",
        "npc.types",
        "items.catalog",
        "items.inventory",
        "loot.OverflowDelivery",
        "mud.handles.nearbyHandles"
      ],
      "kind": "module",
      "lifecycle": "static",
      "owns": [],
      "path": "worldcore/mud/commands/gathering/skinningCommand.ts",
      "provides": [
        "skin <corpse>: validates corpse, resolves skin loot (DB-first, fallback), grants items, marks corpse skinned",
        "progression event emission + overflow-to-mail via OverflowDelivery"
      ],
      "service": "mud"
    },
    "mud.commands.guildBank": {
      "dependsOn": [
        "mud.context",
        "bank.ops",
        "items.service",
        "guilds.service?"
      ],
      "function": "handleGuildBankCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Front-end for guild bank operations.",
        "Uses bankOps.handleBankCommand with ownerKind='guild' based on char.guildId."
      ],
      "path": "worldcore/mud/commands/guildBankCommand.ts"
    },
    "mud.commands.meta.help": {
      "dependsOn": [
        "mud.help",
        "auth.staffRole"
      ],
      "function": "handleHelpCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Emits 'Available commands' list using HELP_ENTRIES.",
        "Includes debug-only commands only if staff role is owner/dev/gm."
      ],
      "path": "worldcore/mud/commands/meta/helpCommand.ts"
    },
    "mud.commands.player.abilities": {
      "dependsOn": [
        "mud.abilities"
      ],
      "function": "handleAbilitiesCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'abilities'.",
        "Lists known abilities for the current character via MudAbilities.listKnownAbilitiesForChar."
      ],
      "path": "worldcore/mud/commands/player/abilitiesCommand.ts"
    },
    "mud.commands.player.equipment": {
      "dependsOn": [
        "items.equipmentOps",
        "mud.context"
      ],
      "functions": [
        "handleEquipCommand",
        "handleUnequipCommand"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'equip <slot>' and 'unequip <slot>'.",
        "Uses equipFirstMatchingFromBags and unequipToBags."
      ],
      "path": "worldcore/mud/commands/player/equipmentCommand.ts"
    },
    "mud.commands.player.inventory": {
      "dependsOn": [
        "items.inventoryView",
        "mud.context"
      ],
      "function": "handleInventoryCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'inventory' / 'inv'.",
        "Renders inventory using buildInventoryLines and joins lines with newlines."
      ],
      "path": "worldcore/mud/commands/player/inventoryCommand.ts"
    },
    "mud.commands.player.itemInfo": {
      "dependsOn": [
        "items.display",
        "mud.context"
      ],
      "function": "handleItemInfoCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'iteminfo <token>'.",
        "Uses getItemTooltip to render item label, lines, and rarity, or reports no item found."
      ],
      "path": "worldcore/mud/commands/player/itemInfoCommand.ts"
    },
    "mud.commands.player.melody": {
      "dependsOn": [
        "mud.context",
        "songs.engine",
        "spells.table"
      ],
      "function": "handleMelodyCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'melody' meta-command for Virtuoso.",
        "Supports subcommands: add, remove, clear, start, stop; manages song queues via SongEngine."
      ],
      "path": "worldcore/mud/commands/player/melodyCommand.ts"
    },
    "mud.commands.player.recovery": {
      "dependsOn": [
        "mud.context",
        "world.respawns?",
        "core.entities",
        "systems.recovery",
        "mud.autoattack",
        "mud.trainingDummy",
        "resources.power"
      ],
      "functions": [
        "handleRespawnCommand",
        "handleRestCommand"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command_group",
      "notes": [
        "Implements 'respawn' and 'rest'.",
        "Respawn uses RespawnService when available, falling back to local respawnInPlace.",
        "Rest uses recoveryOps and also restores mana/fury via PowerResources."
      ],
      "path": "worldcore/mud/commands/player/recoveryCommand.ts"
    },
    "mud.commands.player.resources": {
      "dependsOn": [
        "resources.power"
      ],
      "function": "handleResourcesCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'resources'.",
        "Shows primary resource pool (Fury or Mana) and optional secondary pool for Adventurer."
      ],
      "path": "worldcore/mud/commands/player/resourcesCommand.ts"
    },
    "mud.commands.player.risk": {
      "dependsOn": [
        "mud.context",
        "combat.cowardice?",
        "world.regionDanger"
      ],
      "function": "handleRiskCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'risk' and 'cowardice' commands.",
        "Shows cowardice stacks, tier, and net damageTakenPct from cowardice.",
        "Also shows current RegionDanger tier label and indicates that tier >= 3 applies Region Peril (+5% incoming damage)."
      ],
      "path": "worldcore/mud/commands/player/riskCommand.ts"
    },
    "mud.commands.player.skills": {
      "dependsOn": [
        "mud.context",
        "skills.progression"
      ],
      "function": "handleSkillsCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'skills'.",
        "Shows weapon skills, spell schools (except for pure-song classes like Virtuoso), and song schools."
      ],
      "path": "worldcore/mud/commands/player/skillsCommand.ts"
    },
    "mud.commands.player.songs": {
      "dependsOn": [
        "mud.context",
        "spells.table"
      ],
      "function": "handleSongsCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'songs'.",
        "Lists non-hidden songs (isSong=true) that match class or 'any' and are <= character level."
      ],
      "path": "worldcore/mud/commands/player/songsCommand.ts"
    },
    "mud.commands.player.spells": {
      "dependsOn": [
        "mud.context",
        "spells.table"
      ],
      "function": "handleSpellsCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'spells'.",
        "Lists non-song spells for the character's class (or 'any') that meet min level."
      ],
      "path": "worldcore/mud/commands/player/spellsCommand.ts"
    },
    "mud.commands.player.stats": {
      "dependsOn": [
        "mud.context",
        "characters.sheet",
        "mud.progression",
        "characters.titles"
      ],
      "function": "handleStatsCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'stats'.",
        "Builds character sheet line including gear and active title using buildCharacterSheetLine."
      ],
      "path": "worldcore/mud/commands/player/statsCommand.ts"
    },
    "mud.commands.progression.progress": {
      "dependsOn": [
        "progression.progressText"
      ],
      "function": "handleProgressCommand",
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'progress'.",
        "Uses renderProgressText(char) to show progression counters."
      ],
      "path": "worldcore/mud/commands/progression/progressCommand.ts"
    },
    "mud.commands.progression.quests": {
      "dependsOn": [
        "mud.progression",
        "quests.turnIn"
      ],
      "functions": [
        "handleQuestsCommand",
        "handleQuestCommand"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command_group",
      "notes": [
        "Implements 'quests' and 'quest ...' commands.",
        "Default shows quest log; subcommand 'turnin'/'turn-in'/'complete' turns in a quest by target string.",
        "Provides board/accept/abandon",
        "Help text advertises warfront-friendly turn-in: 'quest turnin list|ready' and 'quest turnin <#|id|name>'."
      ],
      "path": "worldcore/mud/commands/progression/questsCommand.ts"
    },
    "mud.commands.progression.reward": {
      "dependsOn": [
        "mud.context",
        "progression.ProgressionCore",
        "rewards.RewardDelivery",
        "characters.service"
      ],
      "function": "handleRewardCommand",
      "invokedBy": [
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'reward list' and 'reward claim' for pendingRewards delivery."
      ],
      "path": "worldcore/mud/commands/progression/rewardCommand.ts"
    },
    "mud.commands.progression.titles": {
      "dependsOn": [
        "progression.titles.text",
        "progression.titles.setActive"
      ],
      "functions": [
        "handleTitleCommand",
        "handleTitlesCommand",
        "handleSetTitleCommand"
      ],
      "invokedBy": [
        "mud.handler"
      ],
      "kind": "mud_command_group",
      "notes": [
        "Implements 'title', 'titles', and 'settitle ...'.",
        "Renders current title, lists available titles, and sets active title based on fuzzy input."
      ],
      "path": "worldcore/mud/commands/progression/titlesCommand.ts"
    },
    "mud.commands.registry": {
      "dependsOn": [
        "mud.commands.bank",
        "mud.commands.guildBank",
        "mud.commands.economy.trade",
        "mud.commands.economy.vendor",
        "mud.commands.economy.auction",
        "mud.commands.social.mail",
        "mud.commands.craft",
        "mud.commands.world.look",
        "mud.commands.world.examine",
        "mud.commands.world.inspectRegion",
        "mud.commands.world.nearby",
        "mud.commands.world.map",
        "mud.commands.world.save",
        "mud.commands.world.move",
        "mud.commands.world.walkto",
        "mud.commands.world.interact",
        "mud.commands.world.talk",
        "mud.commands.social.chat",
        "mud.commands.social.guildChat",
        "mud.commands.social.who",
        "mud.commands.meta.help",
        "mud.commands.player.inventory",
        "mud.commands.player.itemInfo",
        "mud.commands.player.equipment",
        "mud.commands.player.stats",
        "mud.commands.player.recovery",
        "mud.commands.player.resources",
        "mud.commands.player.skills",
        "mud.commands.player.melody",
        "mud.commands.player.abilities",
        "mud.commands.player.songs",
        "mud.commands.player.spells",
        "mud.commands.combat.cast",
        "mud.commands.combat.ability",
        "mud.commands.combat.attack",
        "mud.commands.combat.autoattack",
        "mud.commands.gathering.picking",
        "mud.commands.gathering.mining",
        "mud.commands.gathering.quarrying",
        "mud.commands.progression.quests",
        "mud.commands.progression.progress",
        "mud.commands.progression.titles",
        "mud.commands.debug.handlers",
        "mud.commands.debug.withDebugGate",
        "rewards.RewardDelivery"
      ],
      "kind": "registry",
      "notes": [
        "Maps text commands (bank, move, cast, etc.) to specific handler functions.",
        "Central router used by MudCommandHandler to dispatch player commands."
      ],
      "path": "worldcore/mud/commands/registry.ts"
    },
    "mud.commands.sessionLookup": {
      "dependsOn": [
        "core.sessions"
      ],
      "functions": [
        "findSessionByCharacterNameInRoom",
        "findSessionByCharacterId"
      ],
      "kind": "utility",
      "notes": [
        "Helpers to resolve sessions by character id or name in a room.",
        "Used by commands that need to target other players."
      ],
      "path": "worldcore/mud/commands/sessionLookup.ts"
    },
    "mud.commands.social.chat": {
      "dependsOn": [
        "mud.context",
        "core.sessions",
        "core.rooms?"
      ],
      "functions": [
        "handleSayCommand",
        "handleTellCommand"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command_group",
      "notes": [
        "Implements 'say' and 'tell' chat commands.",
        "Broadcasts room chat via room.broadcast where possible, falls back to iterating sessions."
      ],
      "path": "worldcore/mud/commands/social/chatCommand.ts"
    },
    "mud.commands.social.guildChat": {
      "dependsOn": [
        "mud.context",
        "guilds.service",
        "core.sessions"
      ],
      "function": "handleGuildChatCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'gchat'.",
        "Fetches guild for character, hydrates char.guildId, and broadcasts messages to all guild members online."
      ],
      "path": "worldcore/mud/commands/social/guildChatCommand.ts"
    },
    "mud.commands.social.mail": {
      "dependsOn": [
        "mail.service",
        "items.service",
        "characters.service",
        "auth.staffRole",
        "auth.staffAudit"
      ],
      "function": "handleMailCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements player mailbox commands: mail list, mail read <id>, mail claim <id>.",
        "Also includes staff-only mail event_reward (explicit mail as a feature; not overflow policy)."
      ],
      "path": "worldcore/mud/commands/social/mailCommand.ts"
    },
    "mud.commands.social.who": {
      "dependsOn": [
        "core.sessions",
        "world.regionText"
      ],
      "functions": [
        "handleWhoCommand",
        "handleWhoAllCommand",
        "handleWhoIsCommand"
      ],
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command_group",
      "notes": [
        "Implements 'who', 'whoall', and 'whois'.",
        "Lists visible players in room, all online players, or detailed info for a single character."
      ],
      "path": "worldcore/mud/commands/social/whoCommand.ts"
    },
    "mud.commands.types": {
      "kind": "types",
      "notes": [
        "Defines MudCommandInput, MudServices, and MudCommandHandlerFn.",
        "Used by command modules and the central registry for typing."
      ],
      "path": "worldcore/mud/commands/types.ts"
    },
    "mud.commands.world.examine": {
      "dependsOn": [
        "mud.context",
        "core.entities",
        "npc.types",
        "npc.state",
        "target.finders"
      ],
      "function": "handleExamineCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'examine <target>'.",
        "Shows level, HP, and tags for NPCs/resources like ore veins and rats; falls back if nothing matches."
      ],
      "path": "worldcore/mud/commands/world/examineCommand.ts"
    },
    "mud.commands.world.examineRegion": {
      "kind": "alias",
      "notes": [
        "Alias entry kept separate in case you introduce alternate region inspection commands later."
      ],
      "path": "worldcore/mud/commands/world/inspectRegionCommand.ts"
    },
    "mud.commands.world.inspect": {
      "kind": "alias",
      "notes": [
        "Optional alias placeholder for future 'inspect' behavior."
      ],
      "path": "worldcore/mud/commands/world/examineCommand.ts"
    },
    "mud.commands.world.inspectRegion": {
      "dependsOn": [
        "world.manager",
        "world.spawnPoints"
      ],
      "function": "handleInspectRegionCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Developer-facing region inspector (supports optional 'inspect_region <x> <z>' / comma forms).",
        "Prints region identity + sampling info when available.",
        "Also queries DB spawn_points: counts spawns in the region and near the query point (radius=10), and prints a short list."
      ],
      "path": "worldcore/mud/commands/world/inspectRegionCommand.ts"
    },
    "mud.commands.world.interact": {
      "dependsOn": [
        "interaction.ops",
        "mud.progression"
      ],
      "function": "handleInteractCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'interact <what>' and 'use <what>'.",
        "Routes to interactInRoom with quest-log rendering for feedback."
      ],
      "path": "worldcore/mud/commands/world/interactCommand.ts"
    },
    "mud.commands.world.look": {
      "dependsOn": [
        "mud.context",
        "core.entities",
        "world.manager"
      ],
      "function": "handleLookCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'look'.",
        "Describes current region and nearby NPCs in the same room with HP readouts."
      ],
      "path": "worldcore/mud/commands/world/lookCommand.ts"
    },
    "mud.commands.world.map": {
      "dependsOn": [
        "mud.mapRenderer",
        "world.manager"
      ],
      "function": "handleMapCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'map [radius]'.",
        "Calls buildAsciiMap(world, char, radius) for ANSI map output."
      ],
      "path": "worldcore/mud/commands/world/mapCommand.ts"
    },
    "mud.commands.world.move": {
      "dependsOn": [
        "movement.ops",
        "movement.commands",
        "world.manager"
      ],
      "function": "handleMoveCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'move', 'walk', and 'go'.",
        "Parses direction, calls moveCharacterAndSync, and returns movement text or failure reason."
      ],
      "path": "worldcore/mud/commands/world/moveCommand.ts"
    },
    "mud.commands.world.nearby": {
      "dependsOn": [
        "mud.context",
        "core.entities",
        "npc.spawns",
        "mud.handles.nearbyHandles"
      ],
      "function": "handleNearbyCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'nearby'.",
        "Refreshes personal nodes, then lists nearby entities within radius with short handles like rat.1.",
        "filter/group/sort flags",
        "--limit / --max",
        "safe caps + \u201cUI-friendly output shaping"
      ],
      "path": "worldcore/mud/commands/world/nearbyCommand.ts"
    },
    "mud.commands.world.save": {
      "dependsOn": [
        "characters.service",
        "auth.identity",
        "utils.logger"
      ],
      "function": "handleSaveCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'save'.",
        "Patch-updates the character record with position, attributes, inventory, equipment, spellbook, abilities, and progression."
      ],
      "path": "worldcore/mud/commands/world/saveCommand.ts"
    },
    "mud.commands.world.serviceGates": {
      "dependsOn": [
        "mud.context",
        "core.entities",
        "core.sessions",
        "vendor.service"
      ],
      "functions": [
        "requireTownService(ctx:MudContext, char:CharacterState, service:\"bank\"|\"guildbank\"|\"vendor\"|\"auction\"|\"mail\", run:()=>Promise<T>|T):Promise<T|string>"
      ],
      "kind": "utility",
      "lifecycle": "stateless",
      "notes": [
        "Enforces proximity gating for town services (bank/guildbank/vendor/auction/mail) when session+entities context exists.",
        "Vendor gating is always enforced when proximity can be evaluated (prevents remote shopping even if PW_SERVICE_GATES is off).",
        "Test-friendly: if proximity cannot be evaluated, the call is not blocked.",
        "Admin/dev bypass via duck-typed session.auth (roles/scopes/permissions flags).",
        "Env: PW_SERVICE_GATES (enable non-vendor gates), PW_SERVICE_RADIUS (default 2.5), PW_SERVICE_GATES_STRICT (deny if no anchor exists)."
      ],
      "path": "worldcore/mud/commands/world/serviceGates.ts"
    },
    "mud.commands.world.talk": {
      "dependsOn": [
        "mud.context",
        "core.entities",
        "npc.types",
        "npc.state",
        "target.finders",
        "progression.core",
        "mud.progression",
        "mud.handles.nearbyHandles"
      ],
      "function": "handleTalkCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'talk <npc>'.",
        "Finds an NPC in the room, fires a talk_to progression event, runs hooks, and prints any progression snippets."
      ],
      "path": "worldcore/mud/commands/world/talkCommand.ts"
    },
    "mud.commands.world.walkto": {
      "dependsOn": [
        "movement.ops",
        "movement.commands",
        "core.entities",
        "core.rooms",
        "world.manager"
      ],
      "function": "handleWalkToCommand",
      "invokedBy": [
        "mud.handler",
        "mud.commands.registry"
      ],
      "kind": "mud_command",
      "notes": [
        "Implements 'walkto <handle|name|service>' auto-walk with per-step delay.",
        "Supports service keywords: bank/gbank/mail/ah/vendor by walking to nearest service anchor entity.",
        "Includes persistent risk-mode + coward toggle (stored on CharacterState progression.flags) to allow walking through combat with penalties.",
        "Walk interrupted on hit unless risk, and that it mirrors flags to entity fields (_pw_walkto*)",
        "Service targeting prefers service anchors (tags/serviceKind) and avoids ambiguous numeric-name matches (e.g. 'walkto 2' accidentally hitting guard.2)."
      ],
      "path": "worldcore/mud/commands/world/walktoCommand.ts"
    },
    "mud.context": {
      "dependsOn": [
        "core.sessions",
        "guilds.service",
        "world.manager?",
        "world.characters?",
        "core.entities?",
        "core.rooms?",
        "world.npcs?",
        "world.trades?",
        "world.vendors?",
        "world.bank?",
        "world.auctions?",
        "world.mail?",
        "world.respawns?"
      ],
      "kind": "model",
      "notes": [
        "Shared dependency bag for all MUD handlers (commands, actions, progression).",
        "Threaded from MessageRouter for each incoming 'mud' command."
      ],
      "path": "worldcore/mud/MudContext.ts",
      "types": [
        "MudContext"
      ]
    },
    "mud.handler": {
      "class": "MudCommandHandler",
      "dependsOn": [
        "mud.context",
        "mud.map",
        "mud.abilities",
        "mud.spells",
        "mud.actions.combat",
        "mud.actions.world",
        "mud.progression",
        "mud.progressionHooks",
        "mud.help",
        "mud.presence",
        "core.sessions",
        "core.rooms",
        "world.manager?",
        "world.query?",
        "world.events?"
      ],
      "handlesCommandsFromHelp": true,
      "kind": "gateway",
      "lifecycle": "stateless",
      "notes": [
        "Parses MUD command lines and routes them to the appropriate action/utility.",
        "Commands roughly correspond 1:1 to HELP_ENTRIES in MudHelpMenu.ts."
      ],
      "path": "worldcore/mud/MudCommandHandler.ts"
    },
    "mud.handles.nearbyHandles": {
      "dependsOn": [],
      "functions": [
        "distanceXZ",
        "getEntityXZ",
        "isDeadNpcLike",
        "makeShortHandleBase",
        "makeShortHandleBaseFromEntity",
        "parseHandleToken",
        "classifyNearbyEntityForViewer",
        "buildNearbyTargetSnapshot",
        "resolveNearbyHandleInRoom",
        "isWorldSpawnsEnabled",
        "getPlayerXZ"
      ],
      "kind": "utility",
      "notes": [
        "Shared nearby-handle + snapshot utilities for MUD commands (e.g. rat.1, alchemist.1).",
        "Centralizes handle parsing, short-handle base derivation, dead/alive classification, and distance sorting.",
        "Provides resolveNearbyHandleInRoom(...) for commands that accept nearby handles; uses last-write-wins on same handle and stable indexing by sorted snapshot.",
        "Exports getPlayerXZ(...) and isWorldSpawnsEnabled() helpers used by nearby/vendor workflows."
      ],
      "path": "worldcore/mud/handles/NearbyHandles.ts"
    },
    "mud.help": {
      "dependsOn": [],
      "kind": "utility",
      "notes": [
        "Source of truth for the MUD help text and visible commands."
      ],
      "path": "worldcore/mud/MudHelpMenu.ts",
      "provides": [
        "HELP_ENTRIES: { cmd:string, desc:string, debug?:boolean }[]"
      ],
      "symbol": "HELP_ENTRIES"
    },
    "mud.map": {
      "dependsOn": [
        "world.manager"
      ],
      "function": "buildAsciiMap",
      "kind": "utility",
      "notes": [
        "Builds ANSI-friendly minimap strings using RegionMap biomes.",
        "Used by 'map [radius]' command."
      ],
      "path": "worldcore/mud/MapRenderer.ts",
      "provides": [
        "buildAsciiMap(world:ServerWorldManager|undefined, char:CharacterState, radius?:number):string"
      ]
    },
    "mud.presence": {
      "dependsOn": [
        "core.sessions",
        "guilds.service"
      ],
      "functions": [
        "who(sessions:SessionManager):Promise<string>",
        "nearby(sessions:SessionManager, regionId:string|null):Promise<string>"
      ],
      "kind": "utility",
      "notes": [
        "Implements 'who' and 'nearby' using SessionManager + GuildService."
      ],
      "path": "worldcore/mud/PresenceCommands.ts"
    },
    "mud.progression": {
      "dependsOn": [
        "progression.core",
        "progression.tasks",
        "progression.titles",
        "progression.quests"
      ],
      "kind": "facade",
      "lifecycle": "stateless",
      "notes": [
        "Thin adapter between core progression modules and MUD-facing code.",
        "Keeps MUD imports stable even if progression internals move."
      ],
      "path": "worldcore/mud/MudProgression.ts",
      "provides": [
        "ensureProgression(char)",
        "incrementProgressionCounter(char, category, key, amount?)",
        "recordActionProgress(char, key, amount?)",
        "ensureTaskList(char)",
        "updateTasksFromProgress(char)",
        "ensureTitlesContainer(char)",
        "updateTitlesFromProgress(char)",
        "ensureQuestState(char)",
        "updateQuestsFromProgress(char)",
        "renderQuestLog(char)"
      ]
    },
    "mud.progressionHooks": {
      "class": "MudProgressionHooks",
      "dependsOn": [
        "mud.progression",
        "characters.service",
        "characters.titles",
        "progression.rewards"
      ],
      "kind": "service",
      "lifecycle": "stateless",
      "notes": [
        "Handles kill/harvest progression reactions: tasks, titles, quests, rewards, and DB patch.",
        "Does NOT increment counters itself; action handlers fire applyProgressionEvent in ProgressionCore directly."
      ],
      "path": "worldcore/mud/MudProgressionHooks.ts",
      "provides": [
        "applyProgressionForEvent(ctx:MudContext, char:CharacterState, category:'kills'|'harvests', key:string):Promise<{snippets:string[]}>"
      ]
    },
    "mud.resources": {
      "dependsOn": [],
      "kind": "legacy_facade",
      "lifecycle": "stateless",
      "notes": [
        "Older MUD-local resource helpers; new code prefers '../resources/PowerResources'.",
        "Safe to treat as compatibility layer while refactoring."
      ],
      "path": "worldcore/mud/MudResources.ts",
      "provides": [
        "ensurePowerResourceMap(char)",
        "getOrInitPowerResource(char, kind)",
        "trySpendPowerResource(char, kind, cost)",
        "gainPowerResource(char, kind, amount)",
        "getPrimaryPowerResourceForClass(classId)"
      ]
    },
    "mud.runtime": {
      "dependsOn": [
        "mud.context",
        "core.entities"
      ],
      "functions": [
        "getSelfEntity"
      ],
      "kind": "utility",
      "notes": [
        "Helper to resolve the world entity owned by the current session.",
        "Used by talk and other world-interaction commands that need the player entity."
      ],
      "path": "worldcore/mud/runtime/mudRuntime.ts"
    },
    "mud.spells": {
      "dependsOn": [
        "mud.context",
        "spells.table",
        "resources.power",
        "combat.cooldowns",
        "mud.actions.combat",
        "skills.progression",
        "combat.damagePolicy",
        "characters.stats",
        "songs.songScaling",
        "items.catalog"
      ],
      "kind": "service",
      "lifecycle": "stateless",
      "notes": [
        "Implements 'spells' and 'cast <name> [target]'.",
        "Supports damage_single_npc and heal_self kinds.",
        "Supports Virtuoso song casts (isSong + songSchool) including melody-driven auto-casts via SongEngine.",
        "Applies song scaling from song school skill and an optional equipped instrument bonus (instrumentPct / instrumentPctBySchool) for deterministic song tuning.",
        "Tracks cooldowns and power resource costs via CastingGates / PowerResources; trains song schools on successful song casts."
      ],
      "path": "worldcore/mud/MudSpells.ts",
      "provides": [
        "listKnownSpellsForChar(char):SpellDefinition[]",
        "castSpellForCharacter(ctx, char, spell, targetNameRaw?):Promise<string>",
        "handleCastCommand(ctx, char, spellNameRaw, targetNameRaw?):Promise<string>"
      ]
    },
    "mud.trainingDummy": {
      "dependsOn": [
        "mud.context",
        "core.sessions"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Provides per-room immortal training dummies and their simple AI loop.",
        "Used by attack/dummy flows and autoattack toggling."
      ],
      "path": "worldcore/mud/MudTrainingDummy.ts",
      "provides": [
        "getTrainingDummyForRoom(roomId):TrainingDummyState",
        "computeTrainingDummyDamage(attrs):number",
        "startTrainingDummyAi(ctx, sessionId, roomId):void",
        "stopTrainingDummyAi(sessionId):void"
      ]
    },
    "npc.crime": {
      "dependsOn": [
        "npc.types",
        "utils.logger"
      ],
      "functions": [
        "isProtectedNpc",
        "recordNpcCrimeAgainst",
        "resolveGuardCallRadius"
      ],
      "kind": "service",
      "notes": [
        "Determines which NPCs are 'protected' (civilian, vendor, questgiver, protected_town, etc.) and records crimes against them on the attacker.",
        "Sets recentCrimeUntil and recentCrimeSeverity (minor|severe) on characters to drive guard response.",
        "law_exempt > law_protected > legacy tags precedence",
        "guards/resources are never \u201cprotected\u201d for crime purposes"
      ],
      "path": "worldcore/npc/NpcCrime.ts"
    },
    "npc.manager": {
      "class": "NpcManager",
      "dependsOn": [
        "core.entities",
        "core.sessions",
        "npc.types",
        "npc.threat",
        "npc.crime",
        "ai.localSimpleBrain",
        "combat.entityCombat",
        "classes.definitions",
        "utils.logger",
        "combat.damagePolicy"
      ],
      "kind": "service",
      "notes": [
        "Owns runtime NPC state, per-room maps, threat tables, and bridges EntityManager \u2194 AI brain \u2194 sessions/chat.",
        "Spawns/Despawns NPCs, applies damage, records threat, coordinates guard/pack help, coward fleeing, gating, and drives AI decisions each tick.",
        "On lethal damage and before despawn, clears combat status effects so corpses don't keep ticking DOTs or carry modifiers."
      ],
      "path": "worldcore/npc/NpcManager.ts"
    },
    "npc.postgres": {
      "class": "PostgresNpcService",
      "dependsOn": [
        "db.main",
        "npc.types"
      ],
      "kind": "service",
      "notes": [
        "Loads NPC prototypes and loot tables from npcs and npc_loot tables.",
        "Maps DB rows into NpcPrototype and NpcLootEntry arrays suitable for setNpcPrototypes."
      ],
      "path": "worldcore/npc/PostgresNpcService.ts"
    },
    "npc.spawnController": {
      "class": "NpcSpawnController",
      "dependsOn": [
        "npc.manager",
        "world.spawnPoints",
        "core.entities",
        "progression.core",
        "utils.logger"
      ],
      "kind": "service",
      "notes": [
        "Controls NPC and resource/node spawning from DB-backed SpawnPointService.",
        "Spawns shared NPCs per room and personal resource nodes per player, respecting per-character depletion via isNodeAvailable and deduping spawn points per scope."
      ],
      "path": "worldcore/npc/NpcSpawnController.ts"
    },
    "npc.threat": {
      "functions": [
        "updateThreatFromDamage",
        "applyTauntToThreat",
        "getTopThreatTarget",
        "getThreatValue",
        "getLastAttackerFromThreat"
      ],
      "kind": "service",
      "notes": [
        "Threat bookkeeping for NPC AI targeting.",
        "Back-compat fields: lastAttackerEntityId + lastAggroAt.",
        "v2 adds a lightweight threat table (threatByEntityId) plus a taunt/forced-target window."
      ],
      "path": "worldcore/npc/NpcThreat.ts"
    },
    "npc.types": {
      "kind": "model",
      "notes": [
        "Defines NpcId, GuardProfile, NpcBehavior, NpcLootEntry, NpcPrototype, and NpcRuntimeState.",
        "Includes DEFAULT_NPC_PROTOTYPES (training_dummy, town_rat, coward_rat, ore_vein_small, town_guard, rat_pack_raider, bandit_caster, starter_alchemist) plus guard call radius helpers and a live prototype registry."
      ],
      "path": "worldcore/npc/NpcTypes.ts"
    },
    "progression.core": {
      "dependsOn": [
        "characters.types",
        "progression.events.raw"
      ],
      "functions": [
        "ensureProgression",
        "incrementProgressionCounter",
        "recordActionProgress",
        "applyProgressionEvent",
        "getNodeDepletedUntil",
        "isNodeAvailable",
        "setNodeDepletedUntil"
      ],
      "kind": "service",
      "notes": [
        "Canonical per-character progression blob and event application logic.",
        "Tracks kills, harvests, actions, collects, flags, exploration, gathering, quests, tasks, and titles.",
        "Also encodes personal node depletion using progression flags."
      ],
      "path": "worldcore/progression/ProgressionCore.ts"
    },
    "progression.eventSink": {
      "dependsOn": [
        "progression.core"
      ],
      "functions": [
        "recordEvent"
      ],
      "kind": "service_contract",
      "notes": [
        "Async sink interface for streaming ProgressionEvent records to external stores.",
        "Extends events with userId, characterId, shardId, roomId, and occurredAt."
      ],
      "path": "worldcore/progression/ProgressionEventSink.ts"
    },
    "progression.events.highLevel": {
      "kind": "model",
      "notes": [
        "Older high-level ProgressEvent model with kinds kill_npc, harvest_node, item_turnin, talk_to_npc, visit_room.",
        "Kept for compatibility with any legacy progression/quest triggers that still use this shape."
      ],
      "path": "worldcore/progression/ProgressionEvents.ts"
    },
    "progression.events.raw": {
      "kind": "model",
      "notes": [
        "Low-level immutable ProgressEvent log shape used for analytics or external sinks.",
        "Defines ProgressEventKind, GatheringKind, GatheringStats, and ProgressEvent payload."
      ],
      "path": "worldcore/progression/ProgressEvents.ts"
    },
    "progression.helpers": {
      "dependsOn": [
        "progression.types"
      ],
      "functions": [
        "normalizeProgression",
        "getOrInitPowerResource",
        "modifyPowerResource",
        "getCooldowns",
        "isAbilityOnCooldown",
        "setAbilityCooldown",
        "getSkills",
        "getOrInitSkillBucket",
        "getGathering",
        "getOrInitGatherDiscipline"
      ],
      "kind": "service",
      "notes": [
        "Utility helpers to normalize and manipulate CharacterProgression.",
        "Covers power pools, cooldowns, generic skill buckets, and gathering disciplines."
      ],
      "path": "worldcore/progression/ProgressionHelpers.ts"
    },
    "progression.progressText": {
      "dependsOn": [
        "progression.tasks.types"
      ],
      "functions": [
        "renderProgressText"
      ],
      "kind": "service",
      "notes": [
        "Renders a 'Progress:' text block showing kills, harvests, and simple tasks with [ ]/[x] markers.",
        "Used by the 'progress' MUD command."
      ],
      "path": "worldcore/progression/progressText.ts"
    },
    "progression.rewards.grantTaskRewards": {
      "dependsOn": [
        "utils.logger",
        "economy.EconomyHelpers",
        "progression.ProgressionCore",
        "loot.OverflowDelivery",
        "rewards.RewardDelivery",
        "characters.service?"
      ],
      "functions": [
        "grantTaskRewards"
      ],
      "kind": "module",
      "notes": [
        "Aggregates task reward XP/gold/items across completed tasks.",
        "XP is granted via CharacterService.grantXp; gold applied via EconomyHelpers.",
        "Item delivery uses RewardDelivery (bags-first, overflow-to-mail if available; otherwise queues to progression.pendingRewards).",
        "When items are queued, players can retrieve them later via 'reward claim'."
      ],
      "path": "worldcore/progression/rewards/grantTaskRewards.ts"
    },
    "progression.rewards.tasks": {
      "dependsOn": [
        "utils.logger",
        "characters.service?",
        "economy.helpers",
        "rewards.RewardDelivery"
      ],
      "functions": [
        "grantTaskRewards"
      ],
      "kind": "service",
      "notes": [
        "Aggregates XP, gold, and item rewards from completed tasks and applies them to the character.",
        "Uses characters.grantXp and EconomyHelpers.grantReward, with optional patchCharacter to persist inventory."
      ],
      "path": "worldcore/progression/rewards/grantTaskRewards.ts"
    },
    "progression.tasks.engine": {
      "dependsOn": [
        "progression.core",
        "progression.tasks.types",
        "characters.types"
      ],
      "functions": [
        "ensureTaskList",
        "updateTasksFromProgress"
      ],
      "kind": "service",
      "notes": [
        "Maintains prog.tasks as SimpleTask[] and updates completion based on kills/harvests counters.",
        "Returns a list of newly completed tasks for reward processing."
      ],
      "path": "worldcore/progression/tasks/taskEngine.ts"
    },
    "progression.tasks.types": {
      "kind": "model",
      "notes": [
        "Defines SimpleTask with id, type ('kill'|'harvest'), target, required count, completion flag, and optional reward.",
        "Used by taskEngine, progress text, and reward logic."
      ],
      "path": "worldcore/progression/tasks/taskTypes.ts"
    },
    "progression.titles.setActive": {
      "dependsOn": [
        "utils.logger",
        "mud.progression",
        "characters.titles"
      ],
      "functions": [
        "setActiveTitle"
      ],
      "kind": "service",
      "notes": [
        "Parses user input from 'settitle', fuzzy-matches to an unlocked title id, and sets it active.",
        "Persists updated progression via ctx.characters.patchCharacter when available."
      ],
      "path": "worldcore/progression/titles/setActiveTitle.ts"
    },
    "progression.titles.state": {
      "dependsOn": [
        "characters.types",
        "progression.core",
        "characters.titles"
      ],
      "functions": [
        "ensureTitlesContainer",
        "updateTitlesFromProgress"
      ],
      "kind": "service",
      "notes": [
        "Ensures prog.titles exists and is well-formed, with unlocked[] and active.",
        "Computes newly unlocked titles from kills/harvests using TITLES unlock rules."
      ],
      "path": "worldcore/progression/titles/titleState.ts"
    },
    "progression.titles.text": {
      "dependsOn": [
        "progression.titles.state",
        "characters.titles"
      ],
      "functions": [
        "renderCurrentTitle",
        "renderTitlesList"
      ],
      "kind": "service",
      "notes": [
        "Renders 'Current title: ...' and 'Titles:' lists using TITLES definitions.",
        "Used by 'title' and 'titles' MUD commands."
      ],
      "path": "worldcore/progression/titles/titleText.ts"
    },
    "progression.types": {
      "kind": "model",
      "notes": [
        "Defines PowerResourceState, CooldownsState, SkillsState, TitlesState, GatheringState, CountersState, and FlagsState.",
        "Represents the canonical character.progression JSON layout."
      ],
      "path": "worldcore/progression/ProgressionTypes.ts"
    },
    "protocol.objects": {
      "dependsOn": [
        "shards.worldBlueprint"
      ],
      "kind": "model",
      "notes": [
        "Defines ClientObjectRequestPayload and ObjectChunkPayload for static world objects and spawn points.",
        "Used by ObjectStream and any client that wants shared types for blueprint objects and spawns."
      ],
      "path": "worldcore/protocol/ObjectMessages.ts"
    },
    "protocol.terrain": {
      "kind": "model",
      "notes": [
        "Single source of truth for WGEv3 terrain streaming protocol.",
        "Defines TerrainChunkCoord, TerrainChunkId, TerrainBlueprintMeta, TerrainChunkDataWire, and client/server terrain message envelopes and unions.",
        "Provides type guards isClientTerrainMessage and isServerTerrainMessage."
      ],
      "path": "worldcore/protocol/WGEv3ChunkProtocol.ts"
    },
    "pvp.duels": {
      "dependsOn": [],
      "functions": [
        "DuelService",
        "DUEL_SERVICE",
        "requestDuel",
        "acceptDuel",
        "acceptAny",
        "declineDuel",
        "endDuelFor",
        "isActiveBetween",
        "getActiveDuel",
        "getOpponentId",
        "tick"
      ],
      "kind": "service",
      "notes": [
        "Ephemeral state only (resets on server restart).",
        "Requests expire quickly to avoid stale challenges.",
        "Used by MudCommandHandler (duel/accept/decline/yield) and MudCombatActions (duel-gated player attack)."
      ],
      "path": "worldcore/pvp/DuelService.ts",
      "provides": [
        "In-memory duel handshake + active duel pairing",
        "Duel-gated PvP enablement hook (mode: 'duel')"
      ]
    },
    "pvp.rules": {
      "dependsOn": [
        "characters.types"
      ],
      "functions": [
        "areAllies",
        "canDamagePlayer",
        "resolvePlayerDamageMode"
      ],
      "kind": "utility",
      "notes": [
        "Centralized PvP gating rules (v1). Fail-closed by default; duel allows; open PvP region allows unless allies (same guild)."
      ],
      "path": "worldcore/pvp/PvpRules.ts"
    },
    "quests.TownQuestBoard": {
      "dependsOn": [
        "quests.QuestGenerator",
        "quests.QuestRegistry",
        "quests.QuestState",
        "progression.core",
        "characters.service",
        "core.EntityManager",
        "core.RoomManager"
      ],
      "functions": [
        "renderTownQuestBoard(ctx, char)",
        "acceptTownQuest(ctx, char, idOrIndex)",
        "abandonQuest(ctx, char, idOrIndex)",
        "resolveQuestDefinitionFromStateId(questId, entry)"
      ],
      "kind": "service",
      "notes": [
        "Quest Board v0: lists deterministic generated quests for current town context (region/town key + tier + epoch).",
        "Acceptance creates QuestState entries (quests are no longer implicitly active just because they exist in the registry).",
        "resolveQuestDefinitionFromStateId enables QuestEngine/QuestText/turnInQuest to resolve generated quests without needing live ctx."
      ],
      "path": "worldcore/quests/TownQuestBoard.ts",
      "provides": [
        "Town-scoped deterministic quest board output",
        "Accept/abandon writes QuestState entries",
        "Quest definition resolution for generated quests via QuestSource metadata"
      ]
    },
    "quests.engine": {
      "dependsOn": [
        "progression.core",
        "quests.state",
        "quests.registry",
        "items.inventoryHelpers",
        "characters.types",
        "quests.TownQuestBoard"
      ],
      "functions": [
        "updateQuestsFromProgress"
      ],
      "kind": "service",
      "notes": [
        "Scans all quests against kills, harvests, actions, flags, and inventory to update completion state.",
        "Marks active quests as completed when all objectives are satisfied and returns the completed list.",
        "No auto-activation",
        "Evaluates accepted quest state entries (not only registry-known quests)",
        "Supports generated TownQuestBoard quest IDs"
      ],
      "path": "worldcore/quests/QuestEngine.ts"
    },
    "quests.generator": {
      "class": "(module) QuestGenerator",
      "ctorArgs": [],
      "dependsOn": [
        "quests.types"
      ],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Quest Generator v0: deterministic per (townId, tier, epoch).",
        "Uses conservative objective pools (ids already present in QuestTypes examples) so generated quests are completable with current content.",
        "Introduces small deterministic jitter on required counts and XP/gold rewards."
      ],
      "path": "worldcore/quests/QuestGenerator.ts",
      "provides": [
        "stableQuestGenSeed({townId,tier,epoch}): stable 32-bit seed",
        "generateTownQuests({townId,tier,epoch,...}): deterministic town quest set",
        "mergeRewards(a,b): helper to sum QuestReward bags"
      ],
      "service": "quests"
    },
    "quests.postgres": {
      "class": "PostgresQuestService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "quests.service",
        "quests.types"
      ],
      "kind": "service",
      "notes": [
        "Loads quest definitions, objectives, and rewards from Postgres quests, quest_objectives, and quest_rewards tables.",
        "Aggregates reward rows into QuestReward (xp, gold, items, titles) and maps objective rows into QuestObjective.",
        "Implements listQuests and getQuest with filtering on is_enabled and repeatable/maxCompletions mapping."
      ],
      "path": "worldcore/quests/PostgresQuestService.ts"
    },
    "quests.registry": {
      "dependsOn": [
        "quests.types"
      ],
      "functions": [
        "setQuestDefinitions",
        "getQuestById",
        "getAllQuests"
      ],
      "kind": "service",
      "notes": [
        "Wraps QUESTS in a mutable registry so quests can be loaded from DB.",
        "setQuestDefinitions replaces questMap with provided definitions."
      ],
      "path": "worldcore/quests/QuestRegistry.ts"
    },
    "quests.service": {
      "kind": "service_contract",
      "notes": [
        "QuestService interface: getQuest, listQuests, and optional admin-style createOrUpdateQuest/deleteQuest.",
        "Implemented by PostgresQuestService."
      ],
      "path": "worldcore/quests/QuestService.ts"
    },
    "quests.state": {
      "dependsOn": [
        "progression.core",
        "characters.types"
      ],
      "functions": [
        "ensureQuestState"
      ],
      "kind": "service",
      "notes": [
        "Defines QuestStateEntry (state and completions) and QuestStateMap.",
        "ensureQuestState attaches quest state to char.progression.quests."
      ],
      "path": "worldcore/quests/QuestState.ts"
    },
    "quests.text": {
      "dependsOn": [
        "progression.core",
        "quests.state",
        "quests.registry",
        "items.inventoryHelpers",
        "characters.types"
      ],
      "functions": [
        "renderQuestLog"
      ],
      "kind": "service",
      "notes": [
        "Renders textual quest log including status marks [ ], [C], [T] and repeatable completion counters.",
        "Prints per-objective progress lines for kill, harvest, collect_item, craft, city, and talk_to objectives.",
        "No auto-activation."
      ],
      "path": "worldcore/quests/QuestText.ts"
    },
    "quests.turnInQuest": {
      "dependsOn": [
        "mud.context",
        "characters.types",
        "quests.registry",
        "quests.state",
        "progression.core",
        "items.inventoryHelpers",
        "economy.helpers",
        "rewards.RewardDelivery"
      ],
      "functions": [
        "turnInQuest"
      ],
      "kind": "service",
      "notes": [
        "Handles quest turn-in: resolves quest by id/name, checks completion and repeatable caps, and revalidates objectives.",
        "Consumes collect_item requirements from inventory, applies XP via ctx.characters.grantXp, and grants gold/items via grantReward.",
        "Unlocks title rewards, updates quest completions and state (active/turned_in), and patches character progression + inventory.",
        "Warfront-friendly: supports 'turnin list'/'ready' and numeric index turn-in (1-based) using stable quest log ordering (sorted ids)."
      ],
      "path": "worldcore/quests/turnInQuest.ts"
    },
    "quests.types": {
      "functions": [
        "listAllQuests"
      ],
      "kind": "model",
      "notes": [
        "Defines QuestObjectiveKind (kill, harvest, collect_item, craft, city, talk_to) and their concrete interfaces.",
        "Defines QuestReward and QuestDefinition with repeatable/maxCompletions fields.",
        "Provides QUESTS hardcoded map including rat_culling, ore_sampling, rat_tail_collection, greet_quartermaster."
      ],
      "path": "worldcore/quests/QuestTypes.ts"
    },
    "resources.power": {
      "dependsOn": [
        "characters.types",
        "utils.logger"
      ],
      "functions": [
        "ensurePowerResourceMap",
        "getOrInitPowerResource",
        "trySpendPowerResource",
        "gainPowerResource",
        "getPrimaryPowerResourceForClass"
      ],
      "kind": "service",
      "notes": [
        "Manages Mana/Fury/Runic Power/Chi pools stored under char.progression.powerResources.",
        "Provides class\u2192primary resource mapping and helpers to spend/gain power (including post-success builders)."
      ],
      "path": "worldcore/resources/PowerResources.ts"
    },
    "rewards.RewardDelivery": {
      "dependsOn": [
        "progression.ProgressionCore",
        "loot.OverflowDelivery"
      ],
      "functions": [
        "deliverRewardItems",
        "claimPendingRewards"
      ],
      "kind": "helper",
      "notes": [
        "Central reward item delivery: uses OverflowDelivery (bags-first, overflow-to-mail).",
        "Queues undelivered reward items into progression.pendingRewards so rewards are never lost.",
        "Supports strict preflight mode for quest turn-ins when mail is unavailable."
      ],
      "path": "worldcore/rewards/RewardDelivery.ts"
    },
    "shards.worldBlueprint": {
      "dependsOn": [
        "terrain.regionTypes"
      ],
      "functions": [
        "buildDemoPrimeWorld"
      ],
      "kind": "model",
      "notes": [
        "Defines WorldBoundary, BlueprintObject, SpawnPoint, and WorldBlueprint for shards.",
        "buildDemoPrimeWorld() creates the current demo Prime Shard blueprint used by ServerWorldManager."
      ],
      "path": "worldcore/shards/WorldBlueprint.ts"
    },
    "shared.entities": {
      "kind": "model",
      "notes": [
        "Defines Entity: id, type, roomId, ownerSessionId, position, facing, HP, labels, spawn metadata, and targetId.",
        "Used by EntityManager, combat, NPC systems, and MUD commands."
      ],
      "path": "worldcore/shared/Entity.ts"
    },
    "shared.messages": {
      "kind": "model",
      "notes": [
        "Defines ClientOpcode, ServerOpcode, ClientMessage, ServerMessage, WhereAmI* messages, and MudResultPayload.",
        "Shared envelope protocol for MMO/MUD/Web clients over WebSocket."
      ],
      "path": "worldcore/shared/messages.ts"
    },
    "shared.region": {
      "dependsOn": [
        "terrain.regionTypes"
      ],
      "kind": "alias",
      "notes": [
        "Re-exports RegionId, Region, and RegionSample from terrain/regions/RegionTypes.",
        "Convenience alias to avoid deep import paths in callers."
      ],
      "path": "worldcore/shared/region.ts"
    },
    "shared.session": {
      "kind": "model",
      "notes": [
        "Defines Session: id, displayName, WebSocket, roomId, lastSeen, shardId, identity, and attached CharacterState.",
        "Used by SessionManager and MUD/sessionLookup helpers."
      ],
      "path": "worldcore/shared/Session.ts"
    },
    "shared.wgev3ChunkProtocol": {
      "kind": "alias",
      "notes": [
        "Re-exports the canonical WGEv3ChunkProtocol from worldcore/protocol.",
        "Kept for backward compatibility with older imports."
      ],
      "path": "worldcore/shared/WGEv3ChunkProtocol.ts"
    },
    "shared.worldCoreContext": {
      "kind": "types",
      "notes": [
        "Defines lightweight SessionLike, SessionsManagerLike, and EntitiesManagerLike interfaces.",
        "Used where full SessionManager/EntityManager are not desired as hard deps."
      ],
      "path": "worldcore/shared/WorldCoreContext.ts"
    },
    "sim.brainActions": {
      "kind": "types",
      "notes": [
        "Types for Mother-Brain style planning outputs (audit \u2192 plan actions \u2192 apply).",
        "Includes PlaceSpawnAction used by SettlementPlanner + simBrain apply."
      ],
      "path": "worldcore/sim/BrainActions.ts"
    },
    "sim.gapFiller": {
      "dependsOn": [
        "sim.grid",
        "sim.respawnCoverage"
      ],
      "kind": "utility",
      "notes": [
        "Gap filling planner for respawn coverage: adds checkpoints/graveyards only where gaps exist.",
        "Deterministic spawnId per cell (`checkpoint_gap_<cx>_<cz>` etc.) so reruns update rather than duplicate."
      ],
      "path": "worldcore/sim/GapFiller.ts",
      "provides": [
        "planGapFillSpawns(existingSpawns, cfg) -> GapFillSpawn[]",
        "Worst-gap-first loop; places at cell center; enforces minDistance from graveyard/checkpoint blockers."
      ]
    },
    "sim.grid": {
      "kind": "utility",
      "notes": [
        "Grid primitives for simulation and world tooling (cell bounds, region ids, cell center math).",
        "Shared by settlement planner, respawn coverage report, and gap filler."
      ],
      "path": "worldcore/sim/SimGrid.ts",
      "provides": [
        "cellCenter(cell, cellSize)",
        "cellBounds(cell, cellSize)",
        "makeRegionId(shardId, cell) -> `${shardId}:${cx},${cz}`",
        "parseBounds(spec) -> Bounds",
        "other grid helpers"
      ]
    },
    "sim.motherBrainWaveOps": {
      "class": "(functions)",
      "ctorArgs": [],
      "dependsOn": [
        "sim.motherBrainWavePlanner"
      ],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Pure helper utilities for reasoning about Mother Brain wave idempotence/replace behavior and wipe selection without DB access.",
        "Used primarily by tests; safe to import anywhere."
      ],
      "owns": [],
      "path": "worldcore/sim/MotherBrainWaveOps.ts",
      "provides": [
        "computeBrainWaveApplyPlan",
        "computeBrainWipePlan",
        "parseBrainSpawnIdLoose"
      ],
      "service": "sim"
    },
    "sim.motherBrainWavePlanner": {
      "class": "(functions)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Deterministic planner for Mother Brain \"brain-owned\" spawn_points waves (preview/commit pipeline).",
        "Used by tools.simBrain (mother-wave/mother-status) and web admin spawnpoints route."
      ],
      "owns": [],
      "path": "worldcore/sim/MotherBrainWavePlanner.ts",
      "provides": [
        "planBrainWave",
        "mother-wipe: delete brain-owned spawn_points within bounds (filterable by --theme/--epoch), dry-run vs --commit",
        "CLI: mother-wipe"
      ],
      "service": "sim"
    },
    "sim.respawnCoverage": {
      "dependsOn": [
        "sim.grid"
      ],
      "kind": "utility",
      "notes": [
        "Respawn coverage auditing utilities for the Dev Simulation Harness.",
        "Scans a cell bounds box and marks each cell center covered if within respawnRadius of an eligible respawn source."
      ],
      "path": "worldcore/sim/RespawnCoverage.ts",
      "provides": [
        "computeRespawnCoverage(spawns, cfg) -> { rows, summary }",
        "Eligibility: graveyard/checkpoint always; settlement-ish types unless variantId === 'kos'"
      ]
    },
    "sim.rng": {
      "class": "SimRng",
      "ctorArgs": [
        "seed"
      ],
      "dependsOn": [],
      "kind": "utility",
      "lifecycle": "factory",
      "notes": [
        "Deterministic RNG utilities for repeatable world planning."
      ],
      "path": "worldcore/sim/SimRng.ts",
      "provides": [
        "shuffle(array) -> newArray",
        "hash32(string) -> uint32",
        "other deterministic RNG helpers"
      ]
    },
    "sim.settlementPlanner": {
      "dependsOn": [
        "sim.grid",
        "sim.rng",
        "sim.brainActions"
      ],
      "kind": "utility",
      "notes": [
        "Deterministic outpost placement with spacing constraints inside cell bounds.",
        "SpawnId format: outpost_<factionKey>_<index>_<cx>_<cz>.",
        "Supports FactionSeedSpec.startIndex to avoid spawnId collisions in append-only (safe) runs.",
        "Adds deterministic jitter within a cell border margin."
      ],
      "path": "worldcore/sim/SettlementPlanner.ts",
      "provides": [
        "planInitialOutposts(factions, cfg) -> BrainAction[]"
      ]
    },
    "sim.townBaselinePlanner": {
      "class": "(functions)",
      "ctorArgs": [],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Plans baseline services around towns (mailboxes/rest/guards/dummies/stations/vendors).",
        "TownLikeSpawnRow now accepts townTier (DB) so station seeding can be tier-gated per town.",
        "Supports spawnIdMode: \"seed\" (seed:* spawnIds suitable for web placement ownership) vs \"legacy\" (svc_* ids for backwards compatibility).",
        "Made bounds typing structural so backend-provided bounds typechecks cleanly",
        "Made polarOffset() accept optional radius to avoid number | undefined TS errors"
      ],
      "owns": [],
      "path": "worldcore/sim/TownBaselinePlanner.ts",
      "provides": [
        "planTownBaselines",
        "TownBaselinePlanOptions",
        "TownBaselinePlan",
        "TownLikeSpawnRow",
        "TownBaselineSpawnIdMode",
        "spawnIdMode: legacy | seed",
        "seedBase namespace (default seed:town_baseline)"
      ],
      "service": "sim"
    },
    "sim.townTierSeeding": {
      "class": "(functions)",
      "ctorArgs": [],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Provides tier assignment helpers."
      ],
      "owns": [],
      "path": "worldcore/sim/TownTierSeeding.ts",
      "provides": [],
      "service": "sim"
    },
    "skills.progression": {
      "dependsOn": [
        "characters.types",
        "combat.engine"
      ],
      "functions": [
        "getWeaponSkill",
        "gainWeaponSkill",
        "getSpellSchoolSkill",
        "gainSpellSchoolSkill",
        "getSongSchoolSkill",
        "gainSongSchoolSkill",
        "getDefenseSkill",
        "gainDefenseSkill"
      ],
      "kind": "service",
      "notes": [
        "Stores weapon, spell, and song instrument skills under char.progression.skills.",
        "Skills are capped at level * 10 and default to 0 if missing.",
        "v1 adds defense skill storage under progression.skills.defense for physical avoidance scaling."
      ],
      "path": "worldcore/skills/SkillProgression.ts"
    },
    "songs.engine": {
      "dependsOn": [
        "characters.types",
        "mud.context",
        "spells.types",
        "mud.spells",
        "utils.logger",
        "core.entities",
        "songs.melodyScheduler"
      ],
      "functions": [
        "getSongsState",
        "getMelody",
        "setMelody",
        "addSongToMelody",
        "removeSongFromMelody",
        "clearMelody",
        "setMelodyActive",
        "tickSongsForCharacter"
      ],
      "kind": "service",
      "notes": [
        "Manages Virtuoso song state and melodies stored under char.progression.songs.",
        "tickSongsForCharacter auto-casts a rotating list of Virtuoso songs on a timer using the normal spell pipeline."
      ],
      "path": "worldcore/songs/SongEngine.ts"
    },
    "songs.melodyScheduler": {
      "dependsOn": [],
      "functions": [
        "normalizeMelody",
        "getPlaylist",
        "currentSpellId",
        "advanceAndSchedule"
      ],
      "kind": "service",
      "notes": [
        "Pure melody state machine helpers extracted from SongEngine.",
        "Guarantee: advanceAndSchedule always advances index and schedules next tick even on cast failure.",
        "Keeps spellIds and legacy songIds mirrored for back-compat."
      ],
      "owns": [],
      "path": "worldcore/songs/MelodyScheduler.ts",
      "provides": []
    },
    "songs.songScaling": {
      "dependsOn": [
        "skills.skillProgression"
      ],
      "functions": [
        "computeSongScalar",
        "scaleSongHealFloor"
      ],
      "kind": "service",
      "notes": [
        "Central song scaling math to prevent drift across MudSpells/CombatEngine/SongEngine.",
        "Baseline scalar rule: 1 + (songSkill/100).",
        "Supports an additional multiplicative instrument bonus (from equipped gear stats) so songs can scale with instruments without touching core attributes."
      ],
      "owns": [],
      "path": "worldcore/songs/SongScaling.ts",
      "provides": []
    },
    "spells.catalog": {
      "dependsOn": [],
      "kind": "service",
      "notes": [
        "Used by spells.types to hydrate the runtime SPELLS map from DB.",
        "Small loader module; safe to keep dumb and predictable."
      ],
      "path": "worldcore/spells/SpellCatalog.ts",
      "summary": "Loads spell/song definitions + aliases from Postgres (spells + spell_aliases tables)."
    },
    "spells.learning": {
      "class": "(module) SpellLearning",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Spell learning/autogrant engine; computes which spells/songs a character should know at a given level.",
        "Backed by DB table spell_unlocks; keeps characters.spellbook consistent with unlock policy."
      ],
      "owns": [],
      "path": "worldcore/spells/SpellLearning.ts",
      "provides": [
        "getSpellsToAutograntAtLevel",
        "applySpellAutogrants"
      ]
    },
    "spells.referenceKits": {
      "class": "(module) ReferenceKits",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Reference class kits L1\u201310 (MVP) used for deterministic starter spell/ability unlock expectations and tests.",
        "Seeded into DB via 050/051 migrations and used by SpellLearning/AbilityLearning contract tests."
      ],
      "owns": [],
      "path": "worldcore/spells/ReferenceKits.ts",
      "provides": [
        "REFERENCE_CLASS_KITS_L1_10",
        "getReferenceKitForClass"
      ]
    },
    "spells.types": {
      "dependsOn": [
        "combat.engine",
        "resources.power",
        "skills.progression",
        "spells.catalog",
        "utils.logger",
        "spells.unlockRules"
      ],
      "functions": [
        "findSpellByNameOrId"
      ],
      "kind": "model",
      "notes": [
        "Defines SpellDefinition and SpellKind plus the SPELLS registry.",
        "Includes debug_arcane_bolt, mage_fire_bolt, cleric_minor_heal, and Virtuoso song spells.",
        "SpellKind includes buff/debuff/DOT kinds (buff_self, buff_single_ally, debuff_single_npc, damage_dot_single_npc).",
        "SpellStatusEffect payloads define status effect id/modifiers/duration/maxStacks for buff/debuff/DOT spells.",
        "Current wiring: buff_self and buff_single_ally are implemented in MudSpells; NPC debuffs/DOTs remain a TODO until NPC statusEffects + ticking lands."
      ],
      "path": "worldcore/spells/SpellTypes.ts"
    },
    "spells.unlocks": {
      "dependsOn": [
        "spells.types"
      ],
      "functions": [
        "getSpellUnlockSource",
        "getAllSpellUnlockRules",
        "getAutoGrantUnlocksFor",
        "initSpellUnlocksFromDbOnce",
        "__setSpellUnlocksForTest",
        "__resetSpellUnlocksForTest"
      ],
      "kind": "helper",
      "notes": [
        "DB-driven spell/song unlock rules that feed spellbook auto-grants.",
        "Supports test overrides and a one-time DB hydration step.",
        "If the spell_unlocks table is missing, the system falls back to the code unlock list; creating the table/migrations is planned once class progression is stabilized."
      ],
      "path": "worldcore/spells/SpellUnlocks.ts"
    },
    "strategy.regionService": {
      "class": "RegionService",
      "dependsOn": [
        "shards.worldBlueprint",
        "terrain.regionTypes"
      ],
      "kind": "service",
      "notes": [
        "Query helper over WorldBlueprint for city-builder/strategy layer.",
        "Can list all shards, all regions, regions per shard, and filter by biome or tag."
      ],
      "path": "worldcore/strategy/api/RegionService.ts"
    },
    "strategy.world": {
      "dependsOn": [
        "shards.worldBlueprint"
      ],
      "functions": [
        "seedWorld"
      ],
      "kind": "service",
      "notes": [
        "Defines domain-level World and WorldShard types for the strategy layer.",
        "seedWorld() builds the demo Prime Shard world from buildDemoPrimeWorld with biome-based danger ratings."
      ],
      "path": "worldcore/strategy/domain/world.ts"
    },
    "systems.recovery": {
      "dependsOn": [
        "combat.entityCombat"
      ],
      "functions": [
        "restoreEntityToFull",
        "respawnInPlace",
        "restOrSleep"
      ],
      "kind": "service",
      "notes": [
        "Recovery helpers operating on entities via a RecoveryContext with session and entities provider.",
        "respawnInPlace and restOrSleep resurrect or fully restore the player entity and shut down autoattack/training dummy hooks."
      ],
      "path": "worldcore/systems/recovery/recoveryOps.ts"
    },
    "systems.regen": {
      "dependsOn": [
        "core.sessions",
        "core.entities",
        "combat.entityCombat"
      ],
      "functions": [
        "ensureRegenLoop"
      ],
      "kind": "service",
      "notes": [
        "Starts a global HP regen loop once, ticking every 5 seconds.",
        "Iterates all sessions and heals non-dead, out-of-combat entities by a fixed amount up to maxHp."
      ],
      "path": "worldcore/systems/regen/ensureRegenLoop.ts"
    },
    "targeting.finders": {
      "dependsOn": [
        "core.sessions",
        "core.entities",
        "shared.entities"
      ],
      "functions": [
        "findTargetPlayerEntityByName",
        "findNearestNpcByName",
        "findNpcTargetByName"
      ],
      "kind": "utility",
      "notes": [
        "High-level helpers for resolving player and NPC targets by name within a room.",
        "Supports numbered syntax like 'guard.2' and pure index-based targeting for NPCs."
      ],
      "path": "worldcore/targeting/targetFinders.ts"
    },
    "targeting.resolver": {
      "dependsOn": [
        "shared.entities"
      ],
      "functions": [
        "resolveTargetInRoom"
      ],
      "kind": "utility",
      "notes": [
        "Resolves a target entity in a room by index ('2'), short handle ('rat.1'), or partial name.",
        "Normalizes names and filters by a caller-provided predicate."
      ],
      "path": "worldcore/targeting/TargetResolver.ts"
    },
    "terrain.biomeRules": {
      "dependsOn": [
        "backend.worldDimensions?"
      ],
      "function": "computeBiome",
      "kind": "utility",
      "notes": [
        "Scale-aware simple biome classifier used by older pipelines.",
        "Currently imports WorldDimensions from planarwar-backend; treat as optional bridge."
      ],
      "path": "worldcore/terrain/biomes/BiomeRules.ts",
      "provides": [
        "computeBiome(x:number, z:number, height:number, slope:number, dim:WorldDimensions):BiomeResult"
      ]
    },
    "terrain.heightmap": {
      "class": "Heightmap",
      "ctorArgs": [
        "seed:number"
      ],
      "dependsOn": [],
      "kind": "utility",
      "lifecycle": "factory",
      "notes": [
        "Deterministic 2D noise heightfield used by ServerWorldManager and RegionMap.",
        "Biome hint tweaks terrain shape slightly for roads/rivers/hills/farms/etc."
      ],
      "path": "worldcore/terrain/height/Heightmap.ts",
      "provides": [
        "setNoiseScale(scale:number)",
        "sample(x:number, z:number, biome?:string):number",
        "sampleSlope(x:number, z:number, biomeHint?:string):number"
      ]
    },
    "terrain.index": {
      "kind": "barrel",
      "path": "worldcore/terrain/index.ts",
      "reexports": [
        "terrain.heightmap",
        "terrain.regionTypes",
        "terrain.regionSampler",
        "terrain.regionMap",
        "worldgen.scaled"
      ]
    },
    "terrain.regionDifficulty": {
      "dependsOn": [
        "terrain.regionTypes"
      ],
      "function": "getRegionTier",
      "kind": "utility",
      "notes": [
        "Computes difficulty tier by radial distance from world center.",
        "Uses max world radius \u2248 2048 units for current prime shard."
      ],
      "path": "worldcore/terrain/regions/RegionDifficulty.ts",
      "provides": [
        "getRegionTier(region:Region):1|2|3|4|5"
      ]
    },
    "terrain.regionDisplay": {
      "dependsOn": [
        "terrain.regionTypes",
        "terrain.regionNaming",
        "factions.types?"
      ],
      "function": "getRegionDisplayName",
      "kind": "utility",
      "notes": [
        "UI helper that decorates region name with 'Domain of <faction>'."
      ],
      "path": "worldcore/terrain/regions/RegionDisplay.ts",
      "provides": [
        "getRegionDisplayName(region:Region, controllingFaction?):string"
      ]
    },
    "terrain.regionMap": {
      "class": "RegionMap",
      "ctorArgs": [
        "terrain.heightmap",
        "{ worldId, seed, worldRadius, cellSize? }"
      ],
      "dependsOn": [
        "terrain.heightmap"
      ],
      "kind": "service",
      "lifecycle": "factory",
      "notes": [
        "Lazy LRU-cached region grid over a circular world disk.",
        "Used by ServerWorldManager for region lookup and overview generation."
      ],
      "path": "worldcore/terrain/regions/RegionMap.ts",
      "provides": [
        "getRegionAt(x:number, z:number):Region|undefined",
        "getBiomeAt(x:number, z:number):string",
        "sampleAt(x:number, z:number):RegionSample|undefined",
        "toOverviewGrid(overviewSize?:number):Region[]"
      ]
    },
    "terrain.regionNaming": {
      "dependsOn": [
        "terrain.regionTypes"
      ],
      "function": "generateRegionName",
      "kind": "utility",
      "notes": [
        "Deterministic procedural names based on biome and position.",
        "Uses internal RNG seeded by worldId + region.id so names are stable."
      ],
      "path": "worldcore/terrain/regions/RegionNaming.ts",
      "provides": [
        "generateRegionName(region:Region):string"
      ]
    },
    "terrain.regionSampler": {
      "class": "RegionSampler",
      "ctorArgs": [
        "worldId:string",
        "seed:number",
        "terrain.heightmap"
      ],
      "dependsOn": [
        "terrain.heightmap"
      ],
      "kind": "utility",
      "lifecycle": "factory",
      "notes": [
        "Older helper: random (non-deterministic) sampling of avg height/slope in a disk.",
        "Safe to treat as legacy; RegionMap is the main runtime authority."
      ],
      "path": "worldcore/terrain/regions/RegionSampler.ts",
      "provides": [
        "sampleRegion(cx:number, cz:number, radius:number):Region"
      ]
    },
    "terrain.regionTypes": {
      "kind": "model",
      "notes": [
        "Shared region data model for MMO, strategy layer, and tools."
      ],
      "path": "worldcore/terrain/regions/RegionTypes.ts",
      "types": [
        "RegionId",
        "Region",
        "RegionSample"
      ]
    },
    "test.behaviorReloadSpawnsHereReconcilesSharedNpcs": {
      "dependsOn": [
        "mud.commands.debug.reload",
        "npc.spawnController",
        "core.entities"
      ],
      "kind": "test",
      "notes": [
        "Behavior: 'reload spawns --here=<r>' reconciles only spawn_points-driven shared NPCs in radius.",
        "Ensures nodes/personal spawns (ownerSessionId) are never despawned by reconcile."
      ],
      "path": "worldcore/test/behavior_reloadSpawnsHereReconcilesSharedNpcs.test.ts"
    },
    "test.behaviorReloadSpawnsRegionReconcilesSharedNpcs": {
      "dependsOn": [
        "mud.commands.debug.reload",
        "npc.spawnController",
        "core.entities",
        "world.spawnPoints"
      ],
      "kind": "test",
      "notes": [
        "Behavior: 'reload spawns --region' reconciles spawn_points-driven shared NPCs for the current region.",
        "Locks down epoch swap flows (MotherBrain waves replacing themes) without requiring relog."
      ],
      "path": "worldcore/test/behavior_reloadSpawnsRegionReconcilesSharedNpcs.test.ts"
    },
    "test.combatEngineContract": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: CombatEngine invariants"
      ],
      "owns": [],
      "path": "worldcore/test/combatEngine.contract.test.ts",
      "provides": []
    },
    "test.contractAdminAbilitiesRoutes": {
      "dependsOn": [
        "web-backend.routes.adminAbilities",
        "web-frontend.pages.AdminAbilitiesPage"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: AdminAbilities editor wiring is present (route + UI endpoint references).",
        "Regex-based assertions to avoid brittleness during UI refactors."
      ],
      "path": "worldcore/test/contract_adminAbilitiesRoutes.test.ts",
      "provides": [
        "Guards /api/admin/abilities GET+POST endpoints from accidental removal/renaming",
        "Guards AdminAbilitiesPage fetch wiring (catalog)"
      ]
    },
    "test.contractAdminAbilitiesSchemaColumns": {
      "dependsOn": [
        "infra.schema"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: abilities table schema includes columns required by the admin abilities editor.",
        "Structural scan of worldcore/infra/schema/*.sql (no DB needed)."
      ],
      "path": "worldcore/test/contract_adminAbilitiesSchemaColumns.test.ts",
      "provides": [
        "Guards abilities schema columns used by AdminAbilities editor"
      ]
    },
    "test.contractAdminAbilityUnlocksRoutes": {
      "dependsOn": [
        "web-backend.routes.adminAbilityUnlocks",
        "web-frontend.pages.AdminAbilitiesPage"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: Admin ability_unlocks editor wiring is present (route + UI endpoint references).",
        "Regex-based assertions to avoid brittleness during UI refactors."
      ],
      "path": "worldcore/test/contract_adminAbilityUnlocksRoutes.test.ts",
      "provides": [
        "Guards /api/admin/ability_unlocks GET+POST endpoints from accidental removal/renaming",
        "Guards AdminAbilitiesPage fetch wiring (unlock rules)"
      ]
    },
    "test.contractAdminAbilityUnlocksSchemaColumns": {
      "dependsOn": [
        "infra.schema"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: ability_unlocks table schema includes columns required by the admin unlock rules editor.",
        "Structural scan of worldcore/infra/schema/*.sql (no DB needed)."
      ],
      "path": "worldcore/test/contract_adminAbilityUnlocksSchemaColumns.test.ts",
      "provides": [
        "Guards ability_unlocks schema columns used by AdminAbilities editor"
      ]
    },
    "test.contractAdminHardeningRoutesAndAuth": {
      "dependsOn": [
        "web-backend.middleware.adminAuth",
        "web-backend.index"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: /api/admin/* routes are mounted with maybeRequireAdmin(...) and adminAuth contains required RBAC semantics.",
        "Guards against accidental removal/renaming of admin gating and root-only restrictions.",
        "Structural/regex-based; does not spin up Express or require a live database."
      ],
      "path": "worldcore/test/contract_adminHardeningRoutesAndAuth.test.ts",
      "provides": [
        "Guards admin route mounts are gated by middleware",
        "Guards adminAuth error codes and role mapping",
        "Guards root-only spawn_points destructive endpoints remain protected"
      ]
    },
    "test.contractAdminItemsRoutes": {
      "dependsOn": [
        "web-backend.routes.adminItems",
        "web-frontend.pages.adminItems"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: AdminItems editor wiring is present (route + UI endpoints).",
        "Ensures core API verbs stay stable while the editor iterates.",
        "Assertions are regex-based to avoid brittleness during refactors."
      ],
      "path": "worldcore/test/contract_adminItemsRoutes.test.ts",
      "provides": [
        "Guards /api/admin/items GET+POST endpoints from accidental removal/renaming",
        "Guards /api/admin/items/options typeahead endpoint for ItemPicker",
        "Guards AdminItemsPage + ItemPicker fetch wiring"
      ]
    },
    "test.contractAdminItemsSchemaColumns": {
      "dependsOn": [],
      "kind": "test.contract",
      "notes": [
        "Contract: items catalog schema includes minimum columns required by the admin items editor.",
        "Keeps this conservative while item schema naming settles (no hard-coded kind/tags/enabled assumptions)."
      ],
      "path": "worldcore/test/contract_adminItemsSchemaColumns.test.ts",
      "provides": [
        "Fails fast if minimum columns are removed or renamed in infra/schema SQL"
      ]
    },
    "test.contractAdminNpcsRoutes": {
      "dependsOn": [
        "web-backend.routes.adminNpcs",
        "web-frontend.pages.adminNpcs"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: Admin NPC editor wiring is present (route + UI endpoints).",
        "Guards /api/admin/npcs GET+POST endpoints from accidental removal/renaming.",
        "Regex-based assertions to avoid brittleness during refactors."
      ],
      "path": "worldcore/test/contract_adminNpcsRoutes.test.ts",
      "provides": [
        "Guards /api/admin/npcs mount + basic verbs",
        "Guards AdminNpcsPage fetch wiring"
      ]
    },
    "test.contractAdminNpcsSchemaColumns": {
      "dependsOn": [],
      "kind": "test.contract",
      "notes": [
        "Contract: npcs table schema includes required columns for the admin NPC editor.",
        "Scans all schema migrations (CREATE TABLE + ALTER TABLE ADD COLUMN)."
      ],
      "path": "worldcore/test/contract_adminNpcsSchemaColumns.test.ts",
      "provides": [
        "Fails fast if npc columns are removed or renamed in infra/schema SQL"
      ]
    },
    "test.contractAdminQuestsRoutes": {
      "dependsOn": [
        "web-backend.routes.adminQuests",
        "web-frontend.pages.adminQuests"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: Admin Quests editor wiring is present (route + UI endpoints).",
        "Guards /api/admin/quests GET+POST endpoints from accidental removal/renaming.",
        "Also asserts reward UX uses /api/admin/items/options (current editor behavior)."
      ],
      "path": "worldcore/test/contract_adminQuestsRoutes.test.ts",
      "provides": [
        "Guards /api/admin/quests mount + basic verbs",
        "Guards AdminQuestsPage fetch wiring",
        "Guards reward item picker dependency on /api/admin/items/options"
      ]
    },
    "test.contractAdminQuestsSchemaColumns": {
      "dependsOn": [],
      "kind": "test.contract",
      "notes": [
        "Contract: quests, quest_objectives, quest_rewards schema include required columns for the admin quests editor.",
        "Scans all schema migrations (CREATE TABLE + ALTER TABLE ADD COLUMN)."
      ],
      "path": "worldcore/test/contract_adminQuestsSchemaColumns.test.ts",
      "provides": [
        "Fails fast if quest columns are removed or renamed in infra/schema SQL"
      ]
    },
    "test.contractAdminSpawnPointsConfirmRequiredUi": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "web-frontend.pages.adminSpawnPoints"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: AdminSpawnPointsPage must handle Mother Brain destructive confirm_required (HTTP 409) flow.",
        "Static scan: expects UI to reference confirm_required + expectedConfirmToken and show a Confirm token input."
      ],
      "owns": [],
      "path": "worldcore/test/contract_adminSpawnPointsConfirmRequiredUi.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractAdminSpawnPointsSnapshotRestoreRoutes": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "web-backend.routes.adminSpawnPoints",
        "web-frontend.pages.adminSpawnPoints"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: admin spawn points must expose snapshot/restore endpoints and UI must call them.",
        "Static scan only (no DB)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_adminSpawnPointsSnapshotRestoreRoutes.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractAdminSpellsRoutes": {
      "dependsOn": [
        "web-backend.routes.adminSpells",
        "web-frontend.pages.adminSpells"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: AdminSpells editor wiring is present (route + UI endpoints).",
        "Ensures core API verbs stay stable while the editor iterates.",
        "Assertions are regex-based to avoid brittleness during refactors."
      ],
      "path": "worldcore/test/contract_adminSpellsRoutes.test.ts",
      "provides": [
        "Guards /api/admin/spells GET+POST endpoints from accidental removal/renaming",
        "Guards AdminSpellsPage fetch wiring (list + save)"
      ]
    },
    "test.contractAdminSpellsSchemaColumns": {
      "dependsOn": [
        "tools.seedSpellsColumnsAudit"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: spells catalog schema includes the columns required by the admin spell editor + seed files.",
        "Prevents drift between infra/schema SQL and editor/runtime expectations."
      ],
      "path": "worldcore/test/contract_adminSpellsSchemaColumns.test.ts",
      "provides": [
        "Fails fast if required columns are removed or renamed in 040_create_spells_table.sql"
      ]
    },
    "test.contractAttackAutoSwingEngagedTargetRequired": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.commands.combat.attack",
        "characters.types"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: attack with no target is deny-by-default unless the attacker has an engagedTargetId in the room.",
        "Also asserts auto-swing only hits the engaged target (no room-wide damage regression)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_attack_autoSwing_engagedTargetRequired.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractAttackNoSuchTargetMessage": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "mud.handler",
        "mud.commands.combat.attack",
        "mud.actions.combat",
        "targeting.resolver"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: attack invalid target token emits standardized message: [world] No such target: '<token>'."
      ],
      "path": "worldcore/test/contract_attack_noSuchTargetMessage.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractCastSpellPreGatesNoLeak": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.spells",
        "mud.combatGates",
        "combat.damagePolicy",
        "pvp.duels",
        "combat.castingGates",
        "test.utils"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: castSpell must consult denial gates (region combat disabled, PvP/duel denial) BEFORE spending resources or starting cooldowns.",
        "Also asserts duels end when a spell kill occurs."
      ],
      "owns": [],
      "path": "worldcore/test/contract_castSpell_preGates_noLeak.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractCastingDeniedDoesNotConsumeCostOrCooldown": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.spells",
        "mud.abilities",
        "spells.types",
        "abilities.types",
        "combat.cooldowns",
        "resources.powerResources",
        "combat.serviceProtection"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: if casting is denied after resolving a valid target (e.g. service-protected NPC), do not consume resource cost and do not start cooldowns."
      ],
      "path": "worldcore/test/contract_castingDeniedDoesNotConsumeCostOrCooldown.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractCastingGatesCostCooldown": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "combat.castingGates"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: action cost+cooldown gates must never start cooldowns on resource failure.",
        "Contract: cooldown blocks must not spend resource.",
        "Contract: success spends resource and starts cooldown deterministically (with injected now)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_castingGates_costCooldown.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractCombatEngine": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: CombatEngine behavior surface"
      ],
      "owns": [],
      "path": "worldcore/test/contract_combatEngine.test.ts",
      "provides": []
    },
    "test.contractCombatLogDirectSpellDamageConsistent": {
      "dependsOn": [
        "combat.combatLog"
      ],
      "kind": "test",
      "notes": [
        "Locks CombatLog direct spell damage formatting to match DOT/HOT tick style and canonical prefix."
      ],
      "path": "worldcore/test/contract_combatLog_directSpellDamage_consistent.test.ts"
    },
    "test.contractCommonClassKitsL1_10": {
      "dependsOn": [
        "infra.seed.054_seed_common_class_kits_L1_10"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: ensures the repo always contains an idempotent seed granting a minimal L1\u201310 kit to classes without bespoke kits yet.",
        "Regex/text assertions only (intentionally not DB-coupled)."
      ],
      "path": "worldcore/test/contract_commonClassKits_L1_10.test.ts",
      "provides": [
        "Guards existence of common L1\u201310 kit seed file",
        "Guards that missing classes remain covered by basic unlocks"
      ]
    },
    "test.contractCraftingRequiresStations": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.commands.craft",
        "test.utils"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: when PW_CRAFT_STATIONS_REQUIRED=1, crafting requires the correct station in the room.",
        "Prevents regressions where station checks silently stop seeing room entities."
      ],
      "owns": [],
      "path": "worldcore/test/contract_craftingRequiresStations.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractCrusaderKitL1_10": {
      "dependsOn": [
        "worldcore.reference.ReferenceKits",
        "worldcore.spells.SpellTypes",
        "worldcore.classes.ClassDefinitions"
      ],
      "kind": "test",
      "lifecycle": "contract",
      "path": "worldcore/test/contract_crusaderKit_L1_10.test.ts",
      "provides": [
        "Guards Crusader reference kit presence + spell IDs exist in SpellTypes + mana resource exists"
      ],
      "service": "worldcore"
    },
    "test.contractCutthroatStealthPickpocketBackstabMug": {
      "kind": "test.contract",
      "path": "worldcore/test/contract_cutthroat_stealth_pickpocket_backstab_mug.test.ts",
      "dependsOn": [
        "mud.abilities",
        "abilities.types",
        "combat.statusEffects",
        "mud.actions.combat",
        "items.inventoryHelpers"
      ],
      "notes": [
        "Contract: stealth toggles on/off and is represented as a status-effect tag.",
        "Contract: stealth-required abilities deny BEFORE cost/cooldown gates when not stealthed.",
        "Contract: pickpocket and mug both break stealth; mug deals damage + steals gold deterministically under fixed RNG."
      ],
      "provides": [
        "Guards stealth state storage semantics (progression.statusEffects.active)",
        "Guards deny-path ordering for stealth-gated abilities",
        "Guards mug = damage + steal behavior"
      ]
    },
    "test.contractDebugEffectsCommand": {
      "dependsOn": [
        "mud.commands.debug.debugEffectsCommand",
        "test.utils"
      ],
      "kind": "test",
      "notes": [
        "Ensures debug_effects resolves nearby handles and can emit valid JSON."
      ],
      "path": "worldcore/test/contract_debugEffectsCommand.test.ts",
      "service": "test.contract"
    },
    "test.contractDotKillRewardsAttributionPipeline": {
      "class": "(test) contract_dotKillRewards_attributionPipeline",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/npc/NpcManager.ts",
        "worldcore/combat/NpcDeathPipeline.ts",
        "worldcore/combat/StatusEffects.ts"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Ensures DOT killing blows award XP+loot via canonical NPC death pipeline (NpcManager.applyDotDamage -> handleNpcDeath)."
      ],
      "owns": [
        "test:dotKillRewardsAttributionPipeline"
      ],
      "path": "worldcore/test/contract_dotKillRewards_attributionPipeline.test.ts",
      "provides": [
        "contract:dotKillRewardsAttributionPipeline"
      ]
    },
    "test.contractDotStackingPerCaster": {
      "class": "(test) contract_dotStacking_versionedByApplier_perCaster",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/StatusEffects.ts"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Locks DOT default stacking policy to versioned_by_applier and prevents multi-caster overwrite."
      ],
      "owns": [
        "test:dotStackingPerCaster"
      ],
      "path": "worldcore/test/contract_dotStacking_versionedByApplier_perCaster.test.ts",
      "provides": [
        "contract:dotStackingPerCaster"
      ]
    },
    "test.contractDotTickEngineRoutesDeathPipeline": {
      "class": "(test) contract_dotTickEngineRoutesThroughNpcManagerDeathPipeline",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/core/TickEngine.ts",
        "worldcore/npc/NpcManager.ts",
        "worldcore/combat/StatusEffects.ts",
        "worldcore/combat/NpcDeathPipeline.ts"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Ensures TickEngine DOT ticks route through NpcManager.applyDotDamage so fatal ticks grant XP/loot and produce corpses/respawns."
      ],
      "owns": [
        "test:dotTickEngineDeathPipeline"
      ],
      "path": "worldcore/test/contract_dotTickEngineRoutesThroughNpcManagerDeathPipeline.test.ts",
      "provides": [
        "contract:dotTickEngineDeathPipeline"
      ]
    },
    "test.contractGatheringCommandsResourceTags": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: gathering commands must pass correct gatheringKind and resource_tag.",
        "Ensures fish/farm/quarry do not accidentally use resource_ore."
      ],
      "owns": [],
      "path": "worldcore/test/contract_gatheringCommandsResourceTags.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractHarvestProgressionHookWired": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: MudWorldActions wires harvest progression reactions and guards hook failures.",
        "Ensures applyProgressionEvent(kind:'harvest') + applyProgressionForEvent(...,'harvests',...) remain present and non-fatal."
      ],
      "owns": [],
      "path": "worldcore/test/contract_harvestProgressionHookWired.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractMelodyScheduler": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "songs.melodyScheduler"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: melody normalization supports legacy songIds and mirrors spellIds.",
        "Contract: index clamps safely and advanceAndSchedule always advances + schedules next cast."
      ],
      "owns": [],
      "path": "worldcore/test/contract_melodyScheduler.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractMotherBrainDryRunNoMutation": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "web-backend.routes.adminSpawnPoints"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: Mother Brain admin endpoints must use transaction ROLLBACK for dry-run (no DB mutation).",
        "Static scan of web-backend/routes/adminSpawnPoints.ts for BEGIN/ROLLBACK in mother_brain/wave + mother_brain/wipe."
      ],
      "owns": [],
      "path": "worldcore/test/contract_motherBrainDryRunNoMutation.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractMotherBrainToolHasStatusCommand": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: compiled motherBrain CLI tool must support a 'status' command (dispatch present).",
        "Test reads dist/worldcore/tools/motherBrain.js built from the corresponding worldcore/tools source."
      ],
      "owns": [],
      "path": "worldcore/test/contract_motherBrainToolHasStatusCommand.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractMotherBrainWaveIdempotence": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "web-backend.routes.adminSpawnPoints"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: mother_brain/wave must guard against duplicate spawn_id inserts (ON CONFLICT DO NOTHING or pre-filter existing)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_motherBrainWaveIdempotence.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractMotherBrainWaveReplaceTreatsDeletedAsNew": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "web-backend.routes.adminSpawnPoints"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: replace-mode (append=false) must not skip re-inserting spawn_ids that will be deleted inside the wave box."
      ],
      "owns": [],
      "path": "worldcore/test/contract_motherBrainWaveReplaceTreatsDeletedAsNew.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractNpcCombatAssistRadiusPolicy": {
      "class": "(test) contract_npcCombat_assist_radiusPolicy",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/NpcCombat.ts",
        "worldcore/npc/NpcThreat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcCombat_assist_radiusPolicy"
      ],
      "path": "worldcore/test/contract_npcCombat_assist_radiusPolicy.test.ts",
      "provides": [
        "contract:npcCombatAssistRadiusPolicy"
      ]
    },
    "test.contractNpcCombatAssistSameRoom": {
      "class": "(test) contract_npcCombat_assist_sameRoom",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/NpcCombat.ts",
        "worldcore/npc/NpcThreat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcCombat_assist_sameRoom"
      ],
      "path": "worldcore/test/contract_npcCombat_assist_sameRoom.test.ts",
      "provides": [
        "contract:npcCombatAssistSameRoom"
      ]
    },
    "test.contractNpcCombatAssistStrengthScaling": {
      "class": "(test) contract_npcCombat_assist_strengthScaling",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/NpcCombat.ts",
        "worldcore/npc/NpcThreat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcCombat_assist_strengthScaling"
      ],
      "path": "worldcore/test/contract_npcCombat_assist_strengthScaling.test.ts",
      "provides": [
        "contract:npcCombatAssistStrengthScaling"
      ]
    },
    "test.contractNpcCombatAssistThrottle": {
      "class": "(test) contract_npcCombat_assist_throttle",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/NpcCombat.ts",
        "worldcore/npc/NpcThreat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcCombat_assist_throttle"
      ],
      "path": "worldcore/test/contract_npcCombat_assist_throttle.test.ts",
      "provides": [
        "contract:npcCombatAssistThrottle"
      ]
    },
    "test.contractNpcCombatGateForHelp": {
      "class": "(test) contract_npcCombat_gateForHelp",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/NpcCombat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcCombat_gateForHelp"
      ],
      "path": "worldcore/test/contract_npcCombat_gateForHelp.test.ts",
      "provides": [
        "contract:npcCombatGateForHelp"
      ],
      "notes": [
        "Contract: gater NPC begins a long cast then pulls social allies from an expanded assist radius (train behavior).",
        "Uses npc tags (eg: 'gater') and env knobs PW_GATE_FOR_HELP_* to tune cast time, radius, cooldown, and trigger HP% threshold."
      ]
    },
    "test.contractNpcCombatCounterattackBlockMitigation": {
      "kind": "test",
      "lifecycle": "test",
      "class": "(test)",
      "path": "worldcore/test/contract_npcCombat_counterattack_blockMitigation.test.ts",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: NPC counter-attack treats block as partial mitigation (reduced damage), not a full avoid, and can be tested deterministically via injected RNG."
      ]
    },
    "test.contractNpcCombatNpcRiposteRealDamage": {
      "class": "(test) contract_npcCombat_npcRiposte_realDamage",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/NpcCombat.ts",
        "worldcore/combat/CombatEngine.ts",
        "worldcore/combat/PhysicalHitResolver.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcCombat_npcRiposte_realDamage"
      ],
      "path": "worldcore/test/contract_npcCombat_npcRiposte_realDamage.test.ts",
      "provides": [
        "contract:npcCombatNpcRiposteRealDamage"
      ]
    },
    "test.contractNpcCombatPlayerRiposteOnParry": {
      "kind": "test",
      "lifecycle": "test",
      "class": "(test)",
      "path": "worldcore/test/contract_npcCombat_playerRiposte_onParry.test.ts",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: When the player parries an NPC counter-attack, NpcCombat performs a single immediate player riposte counter-swing (non-lethal in v1.1.x)."
      ]
    },
    "test.contractNpcThreatDecayAssist": {
      "class": "(test) contract_npcThreat_decay_assist",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/npc/NpcThreat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcThreat_decay_assist"
      ],
      "path": "worldcore/test/contract_npcThreat_decay_assist.test.ts",
      "provides": [
        "contract:npcThreatDecayAssist"
      ]
    },
    "test.contractNpcThreatDecayIntegration": {
      "class": "(test) contract_npcThreat_decay_integration",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/npc/NpcThreat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcThreat_decay_integration"
      ],
      "path": "worldcore/test/contract_npcThreat_decay_integration.test.ts",
      "provides": [
        "contract:npcThreatDecayIntegration"
      ]
    },
    "test.contractNpcThreatTauntOverridesTopThreat": {
      "kind": "test",
      "notes": [
        "Contract: taunt forces the current target briefly, then threat resumes to top threat after expiry."
      ],
      "path": "worldcore/test/contract_npcThreat_tauntOverridesTopThreat.test.ts",
      "service": "npc.threat"
    },
    "test.contractPhysicalHitResolverBlockAndRiposteFlags": {
      "kind": "test",
      "lifecycle": "test",
      "class": "(test)",
      "path": "worldcore/test/contract_physicalHitResolver_block_and_riposteFlags.test.ts",
      "dependsOn": [],
      "provides": [],
      "owns": [],
      "notes": [
        "Contract: PhysicalHitResolver surfaces blockMultiplier (<1) on block outcome and riposte flag on parry when allowRiposte is enabled."
      ]
    },
    "test.contractPhysicalHitResolverCritMultiRiposte": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: resolver can deterministically produce parry->riposte and crit+triple outcomes (foundation for class proc systems)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_physicalHitResolver_crit_multi_riposte.test.ts",
      "provides": []
    },
    "test.contractPhysicalHitResolverDefenseSkillInfluence": {
      "kind": "test",
      "notes": [
        "Contract: defenderDefenseSkillPoints increases avoidance deterministically in resolvePhysicalHit."
      ],
      "path": "worldcore/test/contract_physicalHitResolver_defenseSkillInfluence.test.ts",
      "service": "combat.physicalHitResolver"
    },
    "test.contractPhysicalHitResolverWeaponSkillScaling": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: weapon skill + level influence hit outcomes; low-level familiarity floor allows L1 to hit L1\u2013L3 with untrained weapons; high-level untrained misses more."
      ],
      "owns": [],
      "path": "worldcore/test/contract_physicalHitResolver_weaponSkillScaling.test.ts",
      "provides": []
    },
    "test.contractQuestsCommandHelpMentionsTurninListIndex": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: questsCommand help text mentions 'quest turnin list|ready' and index-based turn-in '<#|id|name>'.",
        "Prevents UX regressions where command help stops advertising key turn-in shortcuts."
      ],
      "owns": [],
      "path": "worldcore/test/contract_questsCommandHelpMentionsTurninListIndex.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractReloadSpawnsForcesHydration": {
      "dependsOn": [
        "mud.commands.debug.reload",
        "world.spawnHydrator"
      ],
      "kind": "test",
      "notes": [
        "Contract: 'reload spawns' must force SpawnHydrator.rehydrateRoom(force=true) for the current room/region.",
        "Prevents regressions where spawns only refresh indirectly via 'nearby' or movement."
      ],
      "path": "worldcore/test/contract_reloadSpawnsForcesHydration.test.ts"
    },
    "test.contractSeedAbilityUnlocksReferToSeededAbilities": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "tools.seedAbilityIdAudit"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: schema seeds must ensure ability_unlocks.ability_id values are represented in the abilities catalog seeding flow.",
        "Models the bootstrap seed that populates abilities from ability_unlocks; fails if unlocks occur after the last bootstrap without explicit abilities inserts."
      ],
      "owns": [],
      "path": "worldcore/test/contract_seedAbilityUnlocksReferToSeededAbilities.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractSeedCrusaderKitL1_10": {
      "dependsOn": [
        "worldcore.infra.schema"
      ],
      "kind": "test",
      "lifecycle": "contract",
      "path": "worldcore/test/contract_seedCrusaderKit_L1_10.test.ts",
      "provides": [
        "Guards schema seed file 056 exists + contains expected spell IDs + unlock insert"
      ],
      "service": "worldcore"
    },
    "test.contractSeedNpcLawTagsAreCorrect": {
      "class": "(test)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "static",
      "notes": [
        "Contract: NPC seed law tags preserve training dummy safety (law_exempt) and protected town civilians (law_protected)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_seedNpcLawTagsAreCorrect.test.ts",
      "provides": []
    },
    "test.contractSeedSkinLootItemIdsExist": {
      "class": "(test)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "static",
      "notes": [
        "Contract: skin_loot seed item_id references must exist in seeded items (items table seeds)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_seedSkinLootItemIdsExist.test.ts",
      "provides": []
    },
    "test.contractSeedSpellUnlocksReferToSeededSpells": {
      "class": "(test)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "static",
      "notes": [
        "Contract: seed integrity \u2014 any spell_id referenced in seed spell_unlocks must exist in seeded spells."
      ],
      "owns": [],
      "path": "worldcore/test/contract_seedSpellUnlocksReferToSeededSpells.test.ts",
      "provides": []
    },
    "test.contractShieldOverwriteOtherCasterReplaces": {
      "dependsOn": [
        "combat.statusEffects"
      ],
      "kind": "test",
      "notes": [
        "Contract: Same shield id from another caster overwrites (global last-write-wins).",
        "Prevents multi-caster absorb stacking exploits for identical shield effects."
      ],
      "path": "worldcore/test/contract_shieldOverwrite_otherCaster_replaces.test.ts"
    },
    "test.contractShieldRefreshSameCasterReplaces": {
      "dependsOn": [
        "combat.statusEffects"
      ],
      "kind": "test",
      "notes": [
        "Contract: Shield recast by same caster replaces remaining absorb (no stacking).",
        "Model A: global last-write-wins per shield id."
      ],
      "path": "worldcore/test/contract_shieldRefresh_sameCaster_replaces.test.ts"
    },
    "test.contractSongEngineMelodyThrowAdvance": {
      "dependsOn": [
        "test.utils",
        "songs.engine"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: SongEngine must advance melody index and schedule next tick even if cast path throws.",
        "Prevents regressions where melody stalls due to exceptions."
      ],
      "path": "worldcore/test/contract_songEngine_melodyAdvanceOnThrow.test.ts",
      "service": "test.contract"
    },
    "test.contractSongInstrumentGearBonus": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "mud.spells",
        "songs.songScaling",
        "items.catalog"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: equipped instrument bonus increases song healing deterministically (no RNG).",
        "Protects the instrument scaling seam so future refactors of MudSpells/SongScaling cannot silently drop gear bonuses."
      ],
      "owns": [],
      "path": "worldcore/test/contract_songInstrumentGearBonus.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractSongScaling": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "songs.songScaling"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: song scalar math is deterministic (v0: 1 + skill/100).",
        "Contract: safe behavior when progression blob is missing."
      ],
      "owns": [],
      "path": "worldcore/test/contract_songScaling.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractSpellBuffSelfStatusEffect": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: self buff status effect applies correctly"
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellBuffSelfStatusEffect.test.ts",
      "provides": []
    },
    "test.contractSpellBuffSingleAllyStatusEffect": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: single ally buff status effect applies correctly"
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellBuffSingleAllyStatusEffect.test.ts",
      "provides": []
    },
    "test.contractSpellCleanseSelfRemovesDebuff": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: cleanse_self removes tagged debuffs from caster"
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellCleanseSelfRemovesDebuff.test.ts",
      "provides": []
    },
    "test.contractSpellCleanseSingleAllyDenyPathNoCostNoCooldown": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.spells",
        "combat.cooldowns",
        "resources.powerResources"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: cleanse_single_ally must resolve/deny invalid targets BEFORE spending mana or starting cooldown."
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellCleanseSingleAlly_denyPath_noCostNoCooldown.test.ts",
      "provides": []
    },
    "test.contractSpellCleanseSingleAllyRemovesDebuffNotBuff": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: cleanse_single_ally removes tagged debuffs from ally but does not remove unrelated buffs"
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellCleanseSingleAllyRemovesDebuffNotBuff.test.ts",
      "provides": []
    },
    "test.contractSpellHotDoesNotTickPastExpiry": {
      "class": "(test)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: HOT must not tick beyond expiry boundary (duration clamp)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellHotDoesNotTickPastExpiry.test.ts",
      "provides": []
    },
    "test.contractSpellHotRefreshDoesNotDoubleTick": {
      "class": "(test)",
      "ctorArgs": [],
      "dependsOn": [
        "mud.mudSpells",
        "combat.statusEffects"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: HOT recast refreshes/extends duration without creating a second active instance and without double-ticking; cadence restarts from recast time."
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellHotRefreshDoesNotDoubleTick.test.ts",
      "provides": []
    },
    "test.contractSpellHotSelfTicks": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: heal_hot_self applies HOT and ticks deterministically"
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellHotSelfTicks.test.ts",
      "provides": []
    },
    "test.contractSpellHotSingleAllyTicks": {
      "kind": "test",
      "notes": "[contract] heal_hot_single_ally applies HOT to ally and ticks healing deterministically",
      "path": "worldcore/test/contract_spellHotSingleAllyTicks.test.ts"
    },
    "test.contractSpellShieldAbsorbsDamage": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: shield_self absorbs incoming player damage (can reduce to 0)"
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellShieldAbsorbsDamage.test.ts",
      "provides": []
    },
    "test.contractSpellShieldSingleAllyAbsorbsDamage": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: shield_single_ally applies absorb shield to ally and depletes/removes on damage"
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellShieldSingleAllyAbsorbsDamage.test.ts",
      "provides": []
    },
    "test.contractSpellShieldSingleAllyDenyPathNoCostNoCooldown": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.spells",
        "combat.cooldowns",
        "resources.powerResources"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: shield_single_ally must resolve/deny invalid targets BEFORE spending mana or starting cooldown."
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellShieldSingleAlly_denyPath_noCostNoCooldown.test.ts",
      "provides": []
    },
    "test.contractStatusEffects": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: status effects apply/expire/stack invariants"
      ],
      "owns": [],
      "path": "worldcore/test/contract_statusEffects.test.ts",
      "provides": []
    },
    "test.contractTargetFindersNpc": {
      "dependsOn": [
        "test.utils",
        "targeting.finders"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: findNpcTargetByName provides stable ordering and supports index-only and name.# syntax."
      ],
      "path": "worldcore/test/contract_targetFinders_npcSelection.test.ts",
      "service": "test.contract"
    },
    "test.contractTargetFindersPlayer": {
      "dependsOn": [
        "test.utils",
        "targeting.finders"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: findTargetPlayerEntityByName resolves by session character name (case-insensitive) and requires same-room."
      ],
      "path": "worldcore/test/contract_targetFinders_playerSelection.test.ts",
      "service": "test.contract"
    },
    "test.contractTargetResolver": {
      "dependsOn": [
        "test.utils",
        "targeting.resolver"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: TargetResolver.resolveTargetInRoom supports index-only and name.# syntax.",
        "Contract: filter predicate is authoritative and selfId is excluded."
      ],
      "path": "worldcore/test/contract_targetResolver_inRoomSelection.test.ts",
      "service": "test.contract"
    },
    "test.contractTargetResolverNearbyHandles": {
      "dependsOn": [
        "test.utils",
        "targeting.resolver",
        "mud.handles.nearbyHandles"
      ],
      "kind": "test",
      "notes": [
        "Contract: TargetResolver resolves NPC targets consistently with NearbyHandles ordering (index '2' == snapshot index, handle 'rat.1' == same entity).",
        "Contract: exact entity id wins over index/handle/name matching."
      ],
      "path": "worldcore/test/contract_targetResolver_nearbyHandles.test.ts"
    },
    "test.contractTownBaselineOpsPreviewExposed": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "web-backend.routes.adminSpawnPoints"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: town_baseline plan/apply endpoints must expose opsPreview payload for AdminSpawnPointsPage diff preview.",
        "Static scan of web-backend/routes/adminSpawnPoints.ts for opsPreview builder usage within town_baseline routes."
      ],
      "owns": [],
      "path": "worldcore/test/contract_townBaselineOpsPreviewExposed.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractTurnInQuestWarfrontFriendly": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: turnInQuest is warfront-friendly (list/ready + numeric index) and keeps legacy blank prompt.",
        "Prevents regressions where turn-in UX loses discoverability or stable ordering."
      ],
      "owns": [],
      "path": "worldcore/test/contract_turnInQuestWarfrontFriendly.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractVendorAuditBuySell": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.commands.economy.vendor",
        "vendors.auditLog",
        "vendors.transactions",
        "items.inventoryHelpers",
        "economy.helpers",
        "characters.types"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: successful vendor buy/sell emits audit events (capture mode) and deny paths do not emit audit."
      ],
      "owns": [],
      "path": "worldcore/test/contract_vendorAudit_buySell.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractVendorBuyBagsFullNoSpend": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.commands.economy.vendor",
        "vendors.auditLog",
        "vendors.transactions",
        "items.inventoryHelpers",
        "characters.types"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: bag-full vendor buy must not spend gold and must not emit audit."
      ],
      "owns": [],
      "path": "worldcore/test/contract_vendorBuy_bagsFull_noSpend.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractVendorEconomyPriceCurve": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "vendors.types"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: vendor economy price curve is monotonic with scarcity; invalid stockMax disables dynamic pricing."
      ],
      "owns": [],
      "path": "worldcore/test/contract_vendorEconomyPriceCurve.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractVendorEconomyTierPolicy": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "world.townTierRules"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: vendor economy tier policy clamps tiers and provides monotonic supply/restock knobs; tier token inference works for vendor ids."
      ],
      "owns": [],
      "path": "worldcore/test/contract_vendorEconomyTierPolicy.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractVendorRestockCadenceTicks": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "vendors.types"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: vendor restock cadence tick math stays stable (ticks are floored, stock caps, and lastRestock advances by whole ticks).",
        "Includes the 'full stock still advances lastRestock' rule to prevent perpetual DUE states and time drift."
      ],
      "owns": [],
      "path": "worldcore/test/contract_vendorRestockCadenceTicks.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractVendorSellNotEnoughNoMutation": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.commands.economy.vendor",
        "vendors.auditLog",
        "vendors.transactions",
        "items.inventoryHelpers",
        "economy.helpers",
        "characters.types"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: selling without enough quantity must not mutate inventory/gold and must not emit audit."
      ],
      "owns": [],
      "path": "worldcore/test/contract_vendorSell_notEnough_noMutation.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contractWave1ClassKitMappingsL1_10": {
      "dependsOn": [
        "infra.seed.055_seed_wave1_class_kit_mappings_L1_10"
      ],
      "kind": "test.contract",
      "notes": [
        "Text/regex contract (not DB-coupled). Ensures mapped classes remain covered while bespoke kits are authored later."
      ],
      "path": "worldcore/test/contract_wave1ClassKitMappings_L1_10.test.ts",
      "provides": [
        "Guards Wave 1 class kit mapping seed presence",
        "Guards coverage of mapped classes so kits don't silently vanish"
      ]
    },
    "test.contractWeaponSkillProgressionCapAndEffect": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "combat.physicalHitResolver",
        "combat.combatScaling",
        "skills.progression",
        "combat.npc"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: non-trivial swing attempts train weapon skills; trivial mobs do not; cap enforced (level*5); training materially improves hit chance deterministically."
      ],
      "owns": [],
      "path": "worldcore/test/contract_weaponSkill_progression_cap_and_effect.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contract_abilityLearningRules": {
      "class": "(test)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "static",
      "notes": [
        "Contract: ability learning rules (autogrant <= level, deterministic)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_abilityLearningRules.test.ts",
      "provides": []
    },
    "test.contract_nearbyHandles_resolution": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "mud.handles.nearbyHandles"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: nearby-handle snapshot prefers alive entities over corpses when distance ties (corpse should sort last).",
        "Contract: nearby-handle snapshot hides personal nodes owned by other sessions (no cross-player leakage)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_nearbyHandles_resolution.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contract_npcDebuffsAndDots": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "mud.spells",
        "spells.types",
        "combat.statusEffects",
        "combat.npc",
        "core.tickEngine"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: NPC debuffs + DOT vertical slice works end-to-end (cast \u2192 status apply \u2192 tick \u2192 damage).",
        "Guards the DOT tick + defender snapshot seam so damageTakenPct modifiers influence both direct hits and DOT ticks."
      ],
      "owns": [],
      "path": "worldcore/test/contract_npcDebuffsAndDots.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contract_referenceKits_L1_10": {
      "class": "(test)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "static",
      "notes": [
        "Contract: reference kits L1\u201310 are consistent and autogrant works in test mode."
      ],
      "owns": [],
      "path": "worldcore/test/contract_referenceKits_L1_10.test.ts",
      "provides": []
    },
    "test.contract_reloadSpawnsInvalidatesHydratorCache": {
      "dependsOn": [
        "mud.commands.debug.reload",
        "dev.hotReloadService",
        "world.spawnHydrator"
      ],
      "kind": "test",
      "notes": [
        "Guards against stale POI hydration when spawn_points change at runtime."
      ],
      "path": "worldcore/test/contract_reloadSpawnsInvalidatesHydratorCache.test.ts",
      "provides": [
        "[contract] reload spawns invalidates SpawnHydrator hydration cache before POI rehydrate",
        "Asserts hot reload report includes SpawnHydrator=cleared"
      ],
      "service": "test"
    },
    "test.contract_spellLearningRules": {
      "class": "(test)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "static",
      "notes": [
        "Contract: spell learning rules (autogrant <= level, deterministic)."
      ],
      "owns": [],
      "path": "worldcore/test/contract_spellLearningRules.test.ts",
      "provides": []
    },
    "test.contract_statusEffects_clearOnDeath": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "combat.statusEffects"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: death clears combat status effects (DOTs, debuffs, etc.).",
        "Guards that corpses do not keep ticking DOTs, and ticking stops immediately when lethal DOT damage is applied."
      ],
      "owns": [],
      "path": "worldcore/test/contract_statusEffects_clearOnDeath.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contract_statusStackingPolicy_versionedByApplier": {
      "class": null,
      "ctorArgs": [],
      "dependsOn": [
        "test.utils",
        "combat.statusEffects",
        "combat.statusStackingPolicy"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: versioned_by_applier stacks distinct versions by distinct appliers (cap enforced).",
        "Same applier upgrades their slot (no duplicate stacks). Same version does not stack; refresh/replace semantics are last-write-wins."
      ],
      "owns": [],
      "path": "worldcore/test/contract_statusStackingPolicy_versionedByApplier.test.ts",
      "provides": [],
      "service": "test.contract"
    },
    "test.contract_templar_L1_10_kit_spellFlavor": {
      "class": "(test)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "static",
      "notes": [
        "Contract: templar L1\u201310 reference kit is playable in WORLDCORE_TEST mode; spells exist in SPELLS and have non-placeholder flavor; autogrant by level 10."
      ],
      "owns": [],
      "path": "worldcore/test/contract_templar_L1_10_kit_spellFlavor.test.ts",
      "provides": []
    },
    "test.contract_townQuestBoardAcceptAndAbandon": {
      "dependsOn": [
        "quests.TownQuestBoard",
        "quests.text",
        "mud.commands.progression.quests"
      ],
      "kind": "test",
      "notes": [
        "Covers the minimal quest runtime loop: board -> accept -> questlog -> abandon."
      ],
      "path": "worldcore/test/contract_townQuestBoardAcceptAndAbandon.test.ts",
      "provides": [
        "[contract] town quest board accept adds quest to questlog",
        "[contract] quest abandon removes quest from questlog"
      ],
      "service": "test"
    },
    "test.contract_townQuestGeneratorDeterminism": {
      "dependsOn": [
        "quests.generator"
      ],
      "kind": "test",
      "notes": [
        "Guards reproducibility for generated quest sets so server restarts and tooling yield identical results."
      ],
      "path": "worldcore/test/contract_townQuestGeneratorDeterminism.test.ts",
      "provides": [
        "[contract] town quest generator is deterministic for identical inputs",
        "[contract] different epoch changes output (seeded variance)"
      ],
      "service": "test"
    },
    "test.contract_townQuestGeneratorObjectivePool": {
      "dependsOn": [
        "quests.generator",
        "quests.types"
      ],
      "kind": "test",
      "notes": [
        "Prevents the generator from emitting impossible objectives until content pools expand intentionally."
      ],
      "path": "worldcore/test/contract_townQuestGeneratorObjectivePool.test.ts",
      "provides": [
        "[contract] generated quest objectives only use safe ids from the current content set",
        "[contract] generated quest ids are unique and town-prefixed"
      ],
      "service": "test"
    },
    "test.contract_trainingDummySafety": {
      "class": "(test) contract_trainingDummySafety",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/npc/NpcTypes.ts",
        "worldcore/npc/NpcCrime.ts",
        "worldcore/combat/NpcCombat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_trainingDummySafety"
      ],
      "path": "worldcore/test/contract_trainingDummySafety.test.ts",
      "provides": [
        "contract:trainingDummySafety"
      ]
    },
    "test.duelService": {
      "dependsOn": [
        "combat.duelService",
        "core.sessions?",
        "core.entities?"
      ],
      "kind": "test",
      "notes": [
        "Regression: duel lifecycle (challenge/accept/decline/yield) and state transitions."
      ],
      "path": "worldcore/test/duelService.test.ts"
    },
    "test.gapTableAuditLib": {
      "dependsOn": [
        "tools.gapTableAuditLib"
      ],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Regression tests for SQL table-name extraction (CREATE/ALTER; ONLY; quoted identifiers)."
      ],
      "path": "worldcore/test/gapTableAuditLib.test.ts",
      "service": "test.contract"
    },
    "test.motherBrainSpawnIdParsing": {
      "dependsOn": [
        "sim.motherBrainWaveOps"
      ],
      "kind": "test",
      "notes": [
        "Unit: loose parsing of brain:* spawnId tokens for theme/epoch selection + wipe tooling."
      ],
      "path": "worldcore/test/motherBrain_spawnIdParsing.test.ts"
    },
    "test.motherBrainWaveBudgetOps": {
      "dependsOn": [
        "sim.motherBrainWaveOps"
      ],
      "kind": "test",
      "notes": [
        "Unit: budgeting + caps for Mother Brain wave planning (allowedNewInserts + limiting caps)."
      ],
      "path": "worldcore/test/motherBrainWaveBudgetOps.test.ts"
    },
    "test.motherBrainWaveOps": {
      "dependsOn": [
        "sim.motherBrainWavePlanner",
        "sim.motherBrainWaveOps"
      ],
      "kind": "test",
      "notes": [
        "Unit: computeBrainWaveApplyPlan + computeBrainWipePlan invariants and filtering semantics."
      ],
      "path": "worldcore/test/motherBrainWaveOps.test.ts"
    },
    "test.motherBrainWavePlanner": {
      "dependsOn": [
        "sim.motherBrainWavePlanner"
      ],
      "kind": "test",
      "notes": [
        "Unit: deterministic planning for Mother Brain waves (stable spawnIds, bounds parsing)."
      ],
      "path": "worldcore/test/motherBrainWavePlanner.test.ts"
    },
    "test.pvpFriendlyFireGuild": {
      "dependsOn": [
        "combat.pvpRules",
        "guilds.service?"
      ],
      "kind": "test",
      "notes": [
        "Regression: friendly-fire prevention for same-guild participants when configured."
      ],
      "path": "worldcore/test/pvpFriendlyFireGuild.test.ts"
    },
    "test.pvpRules": {
      "dependsOn": [
        "combat.pvpRules"
      ],
      "kind": "test",
      "notes": [
        "Regression: PvP gating rules (duel vs open vs warfront) behave as expected.",
        "Foundation for future faction/party friendly-fire rules."
      ],
      "path": "worldcore/test/pvpRules.test.ts"
    },
    "test.regionDangerScalar": {
      "dependsOn": [
        "combat.regionDangerAuras",
        "world.regionDanger",
        "combat.statusEffects"
      ],
      "kind": "test",
      "notes": [
        "Regression: region danger scalar influences the Region Peril aura / danger scaling behavior."
      ],
      "path": "worldcore/test/regionDangerScalar.test.ts"
    },
    "test.skinningFallbackLoot": {
      "dependsOn": [
        "mud.actions.world"
      ],
      "kind": "test",
      "notes": [
        "Smoke test for applyFallbackSkinLoot(protoId).",
        "Ensures starter skinning fallback returns hide_scraps with sane qty bounds."
      ],
      "path": "worldcore/test/skinningFallbackLoot.test.ts"
    },
    "test.smokeChecklist": {
      "dependsOn": [
        "test.utils",
        "combat.engine",
        "combat.statusEffects"
      ],
      "kind": "test",
      "notes": [
        "High-level smoke checklist for combat math invariants.",
        "Catches regressions when CombatEngine / StatusEffects ordering changes."
      ],
      "path": "worldcore/test/smokeChecklist.test.ts"
    },
    "test.songEngineMelody": {
      "dependsOn": [
        "test.utils",
        "core.entityManager",
        "mud.context",
        "songs.songEngine",
        "characters.types"
      ],
      "kind": "test",
      "notes": [
        "Ensures melody lists are normalized and stable.",
        "Protects against alias IDs and duplicates causing playlist inflation."
      ],
      "path": "worldcore/test/SongEngine.melody.test.ts",
      "summary": "Contract tests for melody normalization + alias/duplicate safety in SongEngine."
    },
    "test.spawnAuthority": {
      "dependsOn": [
        "world.spawnAuthority"
      ],
      "kind": "test",
      "notes": [
        "Unit: spawnAuthority and editability rules (anchor/seed/manual/brain)."
      ],
      "path": "worldcore/test/spawnAuthority.test.ts"
    },
    "test.statusDamageDealt": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Status: outgoing damage modifiers"
      ],
      "owns": [],
      "path": "worldcore/test/statusDamageDealt.test.ts",
      "provides": []
    },
    "test.statusDamageDealtBySchool": {
      "dependsOn": [
        "test.utils",
        "combat.engine",
        "combat.statusEffects"
      ],
      "kind": "test",
      "notes": [
        "Regression: outgoing per-school damage dealt modifiers apply only to matching school.",
        "Regression: stacks additively with global damageDealtPct."
      ],
      "path": "worldcore/test/statusDamageDealtBySchool.test.ts"
    },
    "test.statusDamageTaken": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Status: incoming damage modifiers"
      ],
      "owns": [],
      "path": "worldcore/test/statusDamageTaken.test.ts",
      "provides": []
    },
    "test.statusDamageTakenBySchool": {
      "dependsOn": [
        "test.utils",
        "combat.engine",
        "combat.statusEffects",
        "combat.mitigation",
        "combat.resists"
      ],
      "kind": "test",
      "notes": [
        "Regression: incoming per-school damage taken modifiers apply only to matching school.",
        "Regression: stacks additively with global damageTakenPct.",
        "Verifies ordering remains: mitigation (armor/resist) then incoming multipliers."
      ],
      "path": "worldcore/test/statusDamageTakenBySchool.test.ts"
    },
    "test.statusEffectsContract": {
      "class": "(test)",
      "dependsOn": [],
      "kind": "test",
      "lifecycle": "test",
      "notes": [
        "Contract: status effect snapshot math + modifiers"
      ],
      "owns": [],
      "path": "worldcore/test/statusEffects.contract.test.ts",
      "provides": []
    },
    "test.contractNpcCombatGateForHelpInterrupt": {
      "class": "(test) contract_npcCombat_gateForHelp_interrupt",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/NpcCombat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcCombat_gateForHelp_interrupt"
      ],
      "path": "worldcore/test/contract_npcCombat_gateForHelp_interrupt.test.ts",
      "provides": [
        "contract:npcCombatGateForHelpInterrupt"
      ]
    },
    "test.contractNpcCombatGateForHelpMultiWave": {
      "class": "(test) contract_npcCombat_gateForHelp_multiWave",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/NpcCombat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcCombat_gateForHelp_multiWave"
      ],
      "path": "worldcore/test/contract_npcCombat_gateForHelp_multiWave.test.ts",
      "provides": [
        "contract:npcCombatGateForHelpMultiWave"
      ],
      "notes": [
        "Contract: gate-for-help can fire multiple pulses (waves), each capped, pulling additional social allies deterministically."
      ]
    },
    "test.contractNpcCombatGateForHelpEscalation": {
      "class": "(test) contract_npcCombat_gateForHelp_escalation",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/combat/NpcCombat.ts"
      ],
      "kind": "test",
      "lifecycle": "active",
      "owns": [
        "test:contract_npcCombat_gateForHelp_escalation"
      ],
      "path": "worldcore/test/contract_npcCombat_gateForHelp_escalation.test.ts",
      "provides": [
        "contract:npcCombatGateForHelpEscalation"
      ],
      "notes": [
        "Contract: repeated successful gates escalate assist radius (train severity grows if players ignore gaters)."
      ]
    },
    "test.contractNpcCombatGateForHelpPushbackInterrupt": {
      "dependsOn": [
        "combat.npcCombat"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: gate-for-help cast can be delayed by pushback (damage slows casting without canceling).",
        "Guards deterministic timing: gate completion must not fire early when pushback is applied."
      ],
      "path": "worldcore/test/contract_npcCombat_gateForHelp_pushbackInterrupt.test.ts",
      "provides": [
        "Guards gate pushback timing invariants"
      ]
    },
    "test.contractNpcCombatGateForHelpCcInterrupt": {
      "dependsOn": [
        "combat.npcCombat",
        "combat.statusEffects"
      ],
      "kind": "test.contract",
      "notes": [
        "Contract: crowd control (stun/silence/root/knockdown) interrupts gate-for-help casting immediately.",
        "Guards that interrupted casts do not later fire assist waves."
      ],
      "path": "worldcore/test/contract_npcCombat_gateForHelp_ccInterrupt.test.ts",
      "provides": [
        "Guards gate CC interruption semantics"
      ]
    },
    "test.utils": {
      "dependsOn": [],
      "functions": [
        "withRandomSequence",
        "/* other deterministic RNG helpers */"
      ],
      "kind": "test_utility",
      "notes": [
        "Shared helpers for deterministic Math.random sequences in tests.",
        "Used by smokeChecklist and damage-by-school regression tests."
      ],
      "path": "worldcore/test/testUtils.ts"
    },
    "tools.applySchema": {
      "class": "ToolScript",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts",
        "utils.logger"
      ],
      "kind": "service",
      "lifecycle": "tool",
      "notes": [
        "This tool is required now that DB-backed recipes are authoritative.",
        "Without a runner, new schema/seed files rely on manual psql execution."
      ],
      "owns": [
        "Migration ordering",
        "Idempotency tracking",
        "Safe logging + failure visibility"
      ],
      "path": "worldcore/tools/applySchema.ts",
      "provides": [
        "Applies SQL files under worldcore/infra/schema in numeric order",
        "Tracks applied migrations in schema_migrations",
        "Supports --dry-run"
      ]
    },
    "tools.auditNpcLawTags": {
      "class": "ToolScript",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts",
        "utils.logger"
      ],
      "kind": "service",
      "lifecycle": "tool",
      "notes": [],
      "owns": [],
      "path": "worldcore/tools/auditNpcLawTags.ts",
      "provides": [
        "audits + optionally cleans npcs.tags law/protection contradictions",
        "Supports --dry-run"
      ]
    },
    "tools.auditVendorTags": {
      "class": "ToolScript",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "tool",
      "notes": [],
      "owns": [],
      "path": "worldcore/tools/auditVendorTags.ts",
      "provides": [
        "Audits + migrates public.npcs.tags vendor tagging (canonical 'vendor', legacy 'service_vendor')",
        "Supports --apply, --removeLegacy, --limit=N"
      ]
    },
    "tools.gapTableAudit": {
      "bin": "dist/worldcore/tools/gapTableAudit.js",
      "dependsOn": [
        "tools.gapTableAuditLib"
      ],
      "kind": "tool",
      "notes": [
        "Milestone B: compares expected tables (migrations) vs existing tables (schema dump).",
        "Outputs missing/orphan tables; supports --json and --strict."
      ],
      "path": "worldcore/tools/gapTableAudit.ts"
    },
    "tools.gapTableAuditLib": {
      "dependsOn": [],
      "functions": [
        "stripSqlComments",
        "extractTableRefsFromSql",
        "extractTableNamesFromSql"
      ],
      "kind": "helper",
      "notes": [
        "Milestone B: heuristic SQL table-name extraction for CREATE/ALTER statements.",
        "Used by gapTableAudit tool and its unit tests."
      ],
      "path": "worldcore/tools/gapTableAuditLib.ts"
    },
    "tools.motherBrain": {
      "dependsOn": [
        "sim.motherBrainWavePlanner",
        "db.Database",
        "infra.schema"
      ],
      "kind": "dev_script",
      "notes": [
        "Mother Brain (v0) DB writer + status CLI for brain-owned spawn_points.",
        "Designed to be safe to import in tests (no DB/pool at module load; no auto-run main()).",
        "Tooling entrypoint (like simBrain), not the long-running Mother Brain service process."
      ],
      "path": "worldcore/tools/motherBrain.ts",
      "provides": [
        "wave: plan/apply deterministic Mother Brain wave directly to spawn_points (dry-run by default; --commit to write; --append to preserve existing brain:* in-bounds)",
        "status: summarize existing brain:* spawn_points within bounds (counts by theme/epoch/type/proto; optional --list; optional --json)",
        "Safety: refuses --commit unless --bounds is explicitly provided",
        "DB access is lazy-imported so unit tests can import without holding open pools"
      ]
    },
    "tools.resourceBaseline": {
      "dependsOn": [
        "db.main",
        "world.spawnPoints",
        "worldgen.v2.resources"
      ],
      "kind": "dev_script",
      "notes": [
        "Baseline seeding tool for v1 gathering; complements tools.simBrain town-baseline + coverage workflows.",
        "Writes to spawn_points (authoritative spawn metadata). Safe by default (dry-run) unless --commit.",
        "Keep seed inputs stable for reproducible dev environments and deterministic tests."
      ],
      "path": "worldcore/tools/resourceBaseline.ts",
      "provides": [
        "plan/commit: deterministic baseline resource spawn_points (ore/herb/wood/fish/rare) within --bounds",
        "dry-run preview: prints planned inserts/updates with seed + density controls (use --commit to write)",
        "audit mode: summarize resource node coverage by bounds / proto kinds"
      ]
    },
    "tools.seedAbilityIdAudit": {
      "bin": "dist/worldcore/tools/seedAbilityIdAudit.js",
      "dependsOn": [],
      "kind": "tool",
      "notes": [
        "Audits schema seed SQL: ensures ability_unlocks.ability_id is covered by the abilities catalog seeding flow.",
        "Models seed order: explicit INSERTs into abilities and/or 'seed abilities from unlocks' bootstrap scripts.",
        "Prevents UI/catalog drift when new ability_unlocks are added without catalog seeding."
      ],
      "path": "worldcore/tools/seedAbilityIdAudit.ts"
    },
    "tools.seedNpcLawTagsAudit": {
      "bin": "dist/worldcore/tools/seedNpcLawTagsAudit.js",
      "dependsOn": [],
      "kind": "tool",
      "notes": [
        "Audits worldcore/infra/schema seed SQL: training dummies must be law_exempt; protected civilians should be law_protected.",
        "Prevents guard/crime regressions caused by seed tag drift.",
        "Supports --schemaDir and --json."
      ],
      "path": "worldcore/tools/seedNpcLawTagsAudit.ts"
    },
    "tools.seedNpcLootItemIdAudit": {
      "bin": "dist/worldcore/tools/seedNpcLootItemIdAudit.js",
      "dependsOn": [],
      "kind": "tool",
      "notes": [
        "Audits worldcore/infra/schema seed SQL: npc_loot.item_id must refer to an item seeded in items.",
        "Prevents seed drift where loot tables reference non-existent item ids.",
        "Supports --schemaDir and --json."
      ],
      "path": "worldcore/tools/seedNpcLootItemIdAudit.ts"
    },
    "tools.seedSkinLootItemIdAudit": {
      "bin": "dist/worldcore/tools/seedSkinLootItemIdAudit.js",
      "dependsOn": [],
      "kind": "tool",
      "notes": [
        "Audits worldcore/infra/schema seed SQL: skin_loot.item_id must refer to an item seeded in items.",
        "Prevents seed drift where skin loot references non-existent item ids.",
        "Supports --schemaDir and --json."
      ],
      "path": "worldcore/tools/seedSkinLootItemIdAudit.ts"
    },
    "tools.seedSpellIdAudit": {
      "bin": "dist/worldcore/tools/seedSpellIdAudit.js",
      "dependsOn": [],
      "kind": "tool",
      "notes": [
        "Audits worldcore/infra/schema seed SQL: spell_unlocks.spell_id must exist in spells.id (seeded).",
        "Prevents FK failures during applySchema / seed runs.",
        "Supports --schemaDir, --json, and --allowMissing for temporary exceptions."
      ],
      "path": "worldcore/tools/seedSpellIdAudit.ts"
    },
    "tools.seedSpellsColumnsAudit": {
      "bin": "dist/worldcore/tools/seedSpellsColumnsAudit.js",
      "dependsOn": [],
      "kind": "tool",
      "notes": [
        "Audits worldcore/infra/schema: spells table columns cover the admin editor + seed SQL expectations.",
        "Prevents runtime/editor regressions when schema drifts.",
        "Supports --schemaFile and --json."
      ],
      "path": "worldcore/tools/seedSpellsColumnsAudit.ts"
    },
    "tools.seedSqlParse": {
      "class": "(module) seedSqlParse",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Small, dependency-free helpers for parsing seed SQL files in worldcore/infra/schema.",
        "Used by seed integrity audits (contract tests) to avoid pulling a full SQL parser dependency.",
        "Conservative parsing: only supports the INSERT/VALUES patterns used by this repo's seed migrations."
      ],
      "owns": [],
      "path": "worldcore/tools/seedSqlParse.ts",
      "provides": [
        "resolveSchemaDir",
        "listSqlFiles",
        "readSqlFile",
        "extractInsertStatementsForTable",
        "parseInsertColumnList",
        "parseInsertValuesRegion",
        "parseValuesTuples",
        "splitTopLevelCommaList",
        "unquoteSqlString",
        "extractFromValuesBlocks",
        "SeedSqlSource",
        "ResolveSchemaDirResult"
      ]
    },
    "tools.simBrain": {
      "dependsOn": [
        "db.Database",
        "infra.schema",
        "sim.SimWorld",
        "sim.SimGrid",
        "sim.SimRng",
        "sim.BrainActions",
        "sim.townBaselinePlanner",
        "sim.motherBrainWavePlanner",
        "world.spawnPointService",
        "world.spawnHydrator"
      ],
      "kind": "dev_script",
      "notes": [
        "Dev Simulation Harness CLI entrypoint.",
        "Includes Mother Brain wave planning commands (mother-wave/mother-status) for brain-owned spawn_points pipelines.",
        "Follows audit \u2192 plan \u2192 apply pattern with safe default rollback unless --commit.",
        "Safety rails: refuses literal '...' arg; refuses --commit without explicit --bounds (unless --allowDefaultBounds).",
        "Artifacts are dev-only outputs; keep them gitignored.",
        "Town vendor wiring: by default, `simBrain era` AND `simBrain mother-wave` seed vendor anchors for town-like spawns (disable with --noTownVendors)."
      ],
      "owns": [
        "artifacts/brain/*"
      ],
      "path": "worldcore/tools/simBrain.ts",
      "provides": [
        "preview/apply: deterministic outpost planning (dry-run vs --commit)",
        "report/status: respawn coverage audit across bounds (status supports --topGaps)",
        "fill-gaps: place checkpoints/graveyards to patch coverage gaps (dry-run vs --commit)",
        "era: orchestrated outposts + gapfill run with safe-mode caps + artifact output (optionally seeds baseline town vendors; default enabled)",
        "mother-wave: plan/apply deterministic Mother Brain wave (dry-run vs --commit), with --append/--theme/--epoch controls (also seeds baseline town vendors by default; disable with --noTownVendors)",
        "mother-status: summarize Mother Brain (brain-owned) spawn_points within bounds (optionally list)",
        "mother-wipe: delete Mother Brain (brain-owned) spawn_points within bounds (optional theme/epoch filters; dry-run vs --commit)",
        "trim-outposts: enforce per-faction cap by deleting extras within bounds",
        "snapshot-spawns/restore-spawns: export + reapply spawn_points slices",
        "wipe-placements: delete spawn_points of selected types within bounds",
        "town-baseline command: seed town/outpost baseline spawn_points (mailbox/rest/stations/vendors/guards/dummies) into spawn_points table",
        "CLI: town-baseline",
        "CLI: mother-status",
        "CLI: mother-wave",
        "CLI: mother-wipe",
        "Flag: --stations",
        "Flag: --respectTierStations / --tierStations",
        "Flag: --townTier <1..5>",
        "DB seeding: town services + stations + vendors + guards + dummies"
      ]
    },
    "trade.auditLog": {
      "dependsOn": [
        "db.main",
        "utils.logger",
        "trade.types"
      ],
      "functions": [
        "logCompletedTrade"
      ],
      "kind": "service",
      "notes": [
        "Persists completed trades into trade_log table including gold before/after and JSON-encoded item lists.",
        "Errors are caught and logged without breaking the trade flow."
      ],
      "path": "worldcore/trade/TradeAuditLog.ts"
    },
    "trade.memory": {
      "class": "InMemoryTradeService",
      "dependsOn": [
        "auth.types",
        "trade.types",
        "trade.service"
      ],
      "kind": "service",
      "notes": [
        "In-memory implementation of TradeService using Maps keyed by session id and character id.",
        "Supports one active trade per character and manages status transitions including both_confirmed."
      ],
      "path": "worldcore/trade/InMemoryTradeService.ts"
    },
    "trade.ops": {
      "dependsOn": [
        "trade.types",
        "trade.auditLog",
        "characters.types",
        "items.inventoryHelpers",
        "economy.helpers"
      ],
      "functions": [
        "formatTradeSessionView",
        "finalizeTrade"
      ],
      "kind": "utility",
      "notes": [
        "Pure trade finalization logic operating on inventories and gold amounts.",
        "Validates that offered items and gold still exist, moves items between inventories, updates gold, logs the trade, notifies both sessions, and marks the session as completed."
      ],
      "path": "worldcore/trade/tradeOps.ts"
    },
    "trade.service": {
      "kind": "service_contract",
      "notes": [
        "TradeService interface: createSession, getSessionFor, cancelFor, clearOffers, setOfferGold, addOfferItem, setAccepted.",
        "Implemented by InMemoryTradeService and used by trade commands."
      ],
      "path": "worldcore/trade/TradeService.ts"
    },
    "trade.types": {
      "kind": "model",
      "notes": [
        "Defines TradeStatus, TradeItemOffer, TradeSide, and TradeSession.",
        "Shared between trade service, audit log, and tradeOps."
      ],
      "path": "worldcore/trade/TradeTypes.ts"
    },
    "tradeskills.recipes": {
      "dependsOn": [
        "tradeskills.types"
      ],
      "functions": [
        "listAllRecipes",
        "getRecipe",
        "findRecipeByIdOrName"
      ],
      "kind": "service",
      "notes": [
        "Static v1 recipe catalog for smelting and alchemy test recipes (e.g., smelt_iron_ingot, brew_minor_heal).",
        "Provides lookup helpers by id and by case-insensitive name."
      ],
      "path": "worldcore/tradeskills/RecipeCatalog.ts"
    },
    "tradeskills.recipes.db": {
      "class": "TradeRecipeService",
      "ctorArgs": [],
      "dependsOn": [
        "tradeskills.types",
        "tradeskills.recipes",
        "worldcore/db/Database.ts",
        "utils.logger"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "DB-backed recipe service (authoritative).",
        "Safely falls back to static RecipeCatalog while DB tables or rows are missing.",
        "Designed for incremental migration: DB overrides code; code fills gaps."
      ],
      "owns": [
        "DB-first recipe resolution (trade_recipes / trade_recipe_inputs / trade_recipe_outputs)",
        "Static fallback merge with RecipeCatalog during migration",
        "In-memory cache of merged recipes"
      ],
      "path": "worldcore/tradeskills/TradeRecipeService.ts",
      "provides": [
        "ensureLoaded()",
        "listAll()",
        "get(id)",
        "findByIdOrName(token)",
        "hasDbRecipes()",
        "getTradeRecipeService()"
      ]
    },
    "tradeskills.types": {
      "kind": "model",
      "notes": [
        "Defines TradeskillCategory, RecipeIngredient, RecipeOutput, TradeRecipe, and RecipeMap.",
        "Used by RecipeCatalog and crafting commands."
      ],
      "path": "worldcore/tradeskills/RecipeTypes.ts"
    },
    "types.shims": {
      "kind": "types",
      "notes": [
        "Ambient declarations for Node/third-party modules (uuid, ws, pg, redis, dotenv, jsonwebtoken, crypto, node:test, assert).",
        "Also declares process, console, timers, and NodeJS.Timeout so TS can compile in bare JS runtimes."
      ],
      "path": "worldcore/types/shims.d.ts"
    },
    "utils.colors": {
      "dependsOn": [],
      "exports": [
        "Colors",
        "colorize"
      ],
      "kind": "utility",
      "notes": [
        "ANSI color codes and colorize(text,color) helper for Node console output.",
        "Used by the logger and can be reused by any CLI tools."
      ],
      "path": "worldcore/utils/colors.ts"
    },
    "utils.logger": {
      "class": "Logger",
      "dependsOn": [
        "utils.colors",
        "config.logconfig"
      ],
      "kind": "utility",
      "notes": [
        "Scope-based logger with timestamp, level coloring, and logEnabled(scope,level) filtering.",
        "Provides debug/info/warn/error/success methods and a static scope(scope) factory."
      ],
      "path": "worldcore/utils/logger.ts"
    },
    "utils.random": {
      "dependsOn": [
        "utils.logger"
      ],
      "functions": [
        "rollInt"
      ],
      "kind": "utility",
      "notes": [
        "Simple random integer helper: rollInt(min,max) using Math.random().",
        "Keeps a scoped logger for future debugging, though current implementation does not log."
      ],
      "path": "worldcore/utils/random.ts"
    },
    "utils.rng": {
      "class": "Rng",
      "dependsOn": [],
      "kind": "utility",
      "notes": [
        "Deterministic RNG based on a hashed seed (mulberry32-style).",
        "Provides next(), range(min,max), int(min,maxInclusive), and pick(list)."
      ],
      "path": "worldcore/utils/Rng.ts"
    },
    "utils.uuid": {
      "dependsOn": [],
      "functions": [
        "uuidv4"
      ],
      "kind": "utility",
      "notes": [
        "Wrapper around crypto.randomUUID() with a fallback fixed v4-like UUID if unavailable.",
        "Used anywhere a stable UUIDv4 string is needed without pulling extra deps."
      ],
      "path": "worldcore/utils/uuid.ts"
    },
    "vendors.auditLog": {
      "dependsOn": [
        "db.database",
        "utils.logger"
      ],
      "functions": [
        "logVendorEvent",
        "__resetCapturedVendorEvents",
        "__getCapturedVendorEvents"
      ],
      "kind": "utility",
      "notes": [
        "Best-effort vendor transaction audit logging.",
        "Never blocks gameplay if DB insert fails.",
        "Under WORLDCORE_TEST=1, DB writes are skipped; capture mode (PW_TEST_CAPTURE_VENDOR_AUDIT=1) collects events for unit tests."
      ],
      "path": "worldcore/vendors/VendorAuditLog.ts"
    },
    "vendors.postgres": {
      "class": "PostgresVendorService",
      "dependsOn": [
        "db.main",
        "utils.logger",
        "vendors.types",
        "vendors.service"
      ],
      "kind": "service",
      "notes": [
        "Postgres-backed implementation of VendorService.",
        "Queries vendors and vendor_items tables and maps rows to VendorDefinition and VendorItem."
      ],
      "path": "worldcore/vendors/PostgresVendorService.ts"
    },
    "vendors.service": {
      "kind": "service_contract",
      "notes": [
        "VendorService interface: getVendor(id) and listVendors().",
        "Implemented by PostgresVendorService and used by vendor commands."
      ],
      "path": "worldcore/vendors/VendorService.ts"
    },
    "vendors.transactions": {
      "dependsOn": [
        "characters.types",
        "economy.helpers",
        "vendors.types"
      ],
      "functions": [
        "resolveVendorItem",
        "buyFromVendor",
        "sellToVendor"
      ],
      "kind": "utility",
      "notes": [
        "Pure transaction logic for buying and selling with vendors.",
        "buyFromVendor checks gold, tries to add items, then spends gold only for successfully added quantity.",
        "sellToVendor finds vendor price reference and pays 50% per unit, consuming items atomically.",
        "Sell/Buy rules live here"
      ],
      "path": "worldcore/vendors/VendorTransactions.ts"
    },
    "vendors.types": {
      "kind": "model",
      "notes": [
        "Defines VendorItem (id,itemId,priceGold) and VendorDefinition (id,name,items).",
        "Shared shape for vendor services, economy helpers, admin tooling, and MUD commands.",
        "Includes pure helper computeVendorRestockCadence(...) that mirrors PostgresVendorService cadence tick semantics (ticks, stock cap, lastRestock advancement)."
      ],
      "path": "worldcore/vendors/VendorTypes.ts"
    },
    "world.boundary": {
      "class": "DomeBoundary",
      "ctorArgs": [
        "centerX",
        "centerZ",
        "radius",
        "softRadius"
      ],
      "dependsOn": [],
      "kind": "utility",
      "lifecycle": "factory",
      "notes": [
        "Pure math helper for circular play-area checks and soft edges.",
        "Currently not wired into ServerWorldManager; kept as reusable utility."
      ],
      "path": "worldcore/world/Boundary.ts",
      "provides": [
        "isInside(x, z)",
        "clampPosition(x, z) -> { x, z, clamped, distance }",
        "falloff(x, z) -> 0..1",
        "toState()",
        "fromState(DomeBoundaryState)"
      ]
    },
    "world.events": {
      "class": "WorldEventBus",
      "ctorArgs": [],
      "dependsOn": [],
      "eventDomain": "world",
      "events": [
        "entity.spawned",
        "entity.despawned",
        "entity.moved",
        "region.changed",
        "room.entered",
        "room.exited",
        "npc.aggressed",
        "npc.died",
        "player.connected",
        "player.disconnected",
        "law.crime",
        "weather.changed"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Typed pub/sub bus for world-layer events.",
        "Goal: future systems (AI, law, weather, crime) hang off this instead of directly calling each other."
      ],
      "path": "worldcore/world/WorldEventBus.ts",
      "provides": [
        "on(event, handler)",
        "off(event, handler)",
        "emit(event, payload)",
        "emitAsync(event, payload)",
        "clear()"
      ]
    },
    "world.manager": {
      "class": "ServerWorldManager",
      "ctorArgs": [
        "seed?"
      ],
      "dependsOn": [
        "spells.types",
        "db.Database"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Owns Heightmap + RegionMap for the prime shard.",
        "Builds a WorldBlueprint via ScaledWorldgen.",
        "Implements WorldBlueprintProvider for RoomManager."
      ],
      "path": "worldcore/world/ServerWorldManager.ts",
      "provides": [
        "getWorldBlueprintForRoom(roomId)",
        "getWorldBlueprint()",
        "getHeightmap()",
        "getRegionMap()",
        "getRegionAt(x, z)",
        "isInsideWorld(x, z)"
      ]
    },
    "world.navGrid": {
      "class": "NavGridManager",
      "ctorArgs": [
        "world.manager"
      ],
      "dependsOn": [
        "world.manager"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Stub v1; just logs init.",
        "Intended to own navmesh/pathing data keyed off ServerWorldManager."
      ],
      "path": "worldcore/world/NavGridManager.ts",
      "provides": [
        "init()"
      ]
    },
    "world.query": {
      "class": "WorldQueryService",
      "ctorArgs": [],
      "dependsOn": [
        "db.main"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "DB-only read model: useful for admin tools, MUD look/inspect, etc.",
        "Does not mutate world state."
      ],
      "path": "worldcore/world/WorldQueryService.ts",
      "provides": [
        "look(shardId, regionId)",
        "inspectRegion(shardId, regionId)"
      ]
    },
    "world.regionDanger": {
      "dependsOn": [
        "characters.types"
      ],
      "functions": [
        "getRegionDangerForRegionId(regionId, nowMs?)",
        "getRegionDangerSnapshotForRegionId(regionId, nowMs?)",
        "getRegionDangerForCharacter(char, nowMs?)",
        "bumpRegionDanger(regionId, delta, source, nowMs?)",
        "setRegionDangerScore(regionId, score, source, nowMs?)"
      ],
      "kind": "utility",
      "notes": [
        "Tracks per-region dynamic danger score and effective tier (1\u20135) based on base distance ring + recent activity.",
        "Applies exponential-style decay over time so regions cool down naturally.",
        "Used by cowardice, Region Peril aura, debug_region_danger, and debug_bump_region_danger."
      ],
      "path": "worldcore/world/RegionDanger.ts"
    },
    "world.regionFlags": {
      "dependsOn": [
        "characters.types",
        "characters.db",
        "utils.logger"
      ],
      "functions": [
        "normalizeRegionIdForDb",
        "getRegionFlags",
        "isPvpEnabledForRegion",
        "isCombatEnabledForRegion",
        "isEventEnabledForRegion",
        "getDangerScalarForRegion",
        "clearRegionFlagsCache",
        "setRegionFlagsTestOverrides(overrides | null)"
      ],
      "kind": "service",
      "notes": [
        "DB-backed region flags lookup (jsonb) with cache.",
        "combatEnabled defaults to true when unset; safe hubs can set combatEnabled=false."
      ],
      "path": "worldcore/world/RegionFlags.ts"
    },
    "world.regions": {
      "class": "RegionManager",
      "ctorArgs": [
        "core.entities",
        "core.rooms",
        "world.respawns?",
        "mmo.shardService?"
      ],
      "dependsOn": [
        "core.entities",
        "core.rooms",
        "world.respawns?",
        "mmo.shardService?"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Authoritative registry of regions and their room ownership.",
        "Bridges entity/room world-space with MMO concepts like shards and respawns."
      ],
      "path": "worldcore/world/RegionManager.ts",
      "provides": [
        "initialize(regions: RegionDefinition[])",
        "getRegion(id)",
        "getAllRegions()",
        "assignEntityToRegion(entityId, regionId)",
        "handleEntityTransfer(entityId, fromRoomId, toRoomId)",
        "findRegionByRoom(roomId)",
        "getRespawnPoint(regionId)",
        "handleRespawnRequest(entityId)",
        "registerShardLink(shardService)",
        "getShardForRegion(regionId)"
      ]
    },
    "world.respawns": {
      "class": "RespawnService",
      "ctorArgs": [
        "world.manager",
        "world.spawnPoints",
        "world.characters",
        "core.entities"
      ],
      "dependsOn": [
        "world.manager",
        "world.spawnPoints",
        "world.characters",
        "core.entities"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Central respawn logic: chooses spawn, heals entity, saves CharacterState.",
        "v3 behavior: respawn prefers a closer eligible settlement spawn over a graveyard; otherwise uses nearest graveyard (then nearest any).",
        "Settlement eligibility placeholder: variantId 'kos' or 'hostile' makes a settlement ineligible."
      ],
      "path": "worldcore/world/RespawnService.ts",
      "provides": [
        "respawnCharacter(session, char)",
        "/* internal */ pickSpawnPointFor(char)"
      ]
    },
    "world.services": {
      "dependsOn": [
        "world.events",
        "core.sessions",
        "core.entities",
        "core.rooms",
        "world.manager",
        "world.regions",
        "world.spawns",
        "world.respawns",
        "world.navGrid",
        "world.boundary?",
        "world.spawnPoints",
        "world.query?",
        "world.navGrid?",
        "core.movement",
        "core.combat",
        "core.objectStream",
        "core.terrainStream",
        "core.tickEngine",
        "npc.manager?"
      ],
      "factory": "createWorldServices",
      "kind": "composition_root",
      "lifecycle": "per-shard",
      "notes": [
        "Intended to construct and wire all world + core services for a shard.",
        "Current implementation in codebase has mismatched constructor calls; registry should be treated as the target shape for the eventual fixed WorldServices.ts."
      ],
      "path": "worldcore/world/WorldServices.ts"
    },
    "world.spawnAuthority": {
      "class": "(module) spawnAuthority",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "module",
      "lifecycle": "static",
      "owns": [],
      "path": "worldcore/world/spawnAuthority.ts",
      "provides": [
        "SpawnAuthority: anchor|seed|brain|manual",
        "getSpawnAuthority(spawnId): infer authority from spawnId prefix",
        "isSpawnEditable(spawnId): false for brain-owned points",
        "isSpawnAnchor/isSpawnSeed/isSpawnBrain helpers"
      ],
      "service": "world"
    },
    "world.spawnHydrator": {
      "class": "SpawnHydrator",
      "ctorArgs": [
        "spawnPoints",
        "entities"
      ],
      "dependsOn": [
        "core.entities",
        "world.spawnPoints",
        "world.townBaselines"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Caches hydration per (shardId, regionId) to avoid redundant DB reads; invalidate* clears that cache only (no despawns)."
      ],
      "owns": [],
      "path": "worldcore/world/SpawnHydrator.ts",
      "provides": [
        "SpawnHydrator.invalidateAll(): clears per-region hydration cache (for hot reload + tests)",
        "SpawnHydrator.invalidateRegion(shardId, regionId): clears hydration cache for a single region",
        "SpawnHydrator.rehydrateRoom({ shardId, regionId, roomId, force?, dryRun? }): materializes POI-like spawn_points into inert entities (never mobs/resources)",
        "Respects WORLD_SPAWNS_ENABLED and WORLD_SPAWNS_TYPES; optional town baselines via PW_TOWN_BASELINES / WORLD_TOWN_BASELINES"
      ],
      "service": "world"
    },
    "world.spawnPointCache": {
      "class": "(module) SpawnPointCache",
      "ctorArgs": [],
      "dependsOn": [
        "world.spawnPoints"
      ],
      "kind": "module",
      "lifecycle": "static",
      "owns": [],
      "path": "worldcore/world/SpawnPointCache.ts",
      "provides": [
        "upsertSpawnPoint(p): cache/refresh a single DbSpawnPoint row",
        "upsertSpawnPoints(points): batch cache refresh",
        "getSpawnPoint(spawnPointId): read cached entry",
        "setSpawnPointCoords(spawnPointId, coords): dev/test override of cached coords",
        "clearSpawnPointCache(): drop all cached entries"
      ],
      "service": "world"
    },
    "world.spawnPoints": {
      "class": "SpawnPointService",
      "ctorArgs": [],
      "dependsOn": [
        "db.main"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Reads spawn_points from Postgres with test-safe lazy DB import.",
        "Now also reads spawn_points.town_tier into DbSpawnPoint.townTier for town-tier aware planning."
      ],
      "path": "worldcore/world/SpawnPointService.ts",
      "provides": [
        "DbSpawnPoint",
        "SpawnPointRow",
        "SpawnPointService.getSpawnPointsInBounds",
        "SpawnPointService.getSpawnPointsNear",
        "SpawnPointService.getSpawnPointsForRegion"
      ]
    },
    "world.spawns": {
      "class": "SpawnService",
      "ctorArgs": [
        "core.entities",
        "core.rooms",
        "world.regions?",
        "world.respawns?"
      ],
      "dependsOn": [
        "core.entities",
        "core.rooms",
        "world.regions?",
        "world.respawns?"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Controls spawning and despawning of entities with optional region + respawn integration.",
        "Some called methods (createEntity, unregister, placeEntityInRoom, removeEntityFromRoom) are aspirational and will need to be aligned with EntityManager/RoomManager."
      ],
      "path": "worldcore/world/SpawnService.ts",
      "provides": [
        "spawnEntity(SpawnOptions)",
        "despawnEntity(DespawnOptions)"
      ]
    },
    "world.storage": {
      "class": "ServerWorldStorage",
      "ctorArgs": [
        "shardId",
        "db.shardStorage",
        "worldGeneratorFn",
        "options?"
      ],
      "dependsOn": [
        "db.shardStorage"
      ],
      "kind": "service",
      "lifecycle": "per-shard",
      "notes": [
        "Bridges worldgen pipeline and shard storage.",
        "Not currently invoked in the runtime core; used when building/loading shards."
      ],
      "path": "worldcore/world/ServerWorldStorage.ts",
      "provides": [
        "loadOrGenerate()"
      ]
    },
    "world.townBaselines": {
      "class": "TownBaselines",
      "ctorArgs": [
        "entities"
      ],
      "dependsOn": [
        "core.entities"
      ],
      "kind": "module",
      "lifecycle": "singleton",
      "owns": [],
      "path": "worldcore/world/TownBaselines.ts",
      "provides": [
        "ensureTownBaseline(spawnPoint, roomId): ensures service anchors exist around town-like POIs (runtime fallback)"
      ],
      "service": "world"
    },
    "world.townTierRules": {
      "class": "(functions)",
      "ctorArgs": [],
      "dependsOn": [
        "world.spawnPoints"
      ],
      "kind": "module",
      "lifecycle": "static",
      "notes": [
        "Centralized design-time rules for town tiers and which service anchors each tier should provide.",
        "Tier 1 = rest + mailbox + guards (current baseline). Higher tiers add vendor / bank / auction / guildbank once service gating is wired."
      ],
      "owns": [],
      "path": "worldcore/world/TownTierRules.ts",
      "provides": [
        "TownTierId",
        "TownServiceId",
        "TownStationProtoId",
        "getTownTierRule(tier)",
        "getServicesForTier(tier)",
        "getStationProtoIdsForTier(tier)",
        "tryInferTownTierFromSpawn(spawn)",
        "inferTownTierFromSpawn(spawn)",
        "getServicesForTownSpawn(spawn)",
        "getStationProtoIdsForTownSpawn(spawn)"
      ],
      "service": "world"
    },
    "worldcore/data/items/ItemDatabase.ts": {
      "class": "ItemDatabase",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/data/items/ItemTypes.ts"
      ],
      "kind": "data_table",
      "lifecycle": "static",
      "notes": [
        "Shared in-memory item database for basic herbs, ores, lumber, tools and magical resources; used for drops, rewards and simple inventories across MMO, webend and MUD."
      ],
      "owns": [],
      "path": "worldcore/data/items/ItemDatabase.ts",
      "provides": [
        "ItemDatabase"
      ]
    },
    "worldcore/data/items/ItemTypes.ts": {
      "class": "(exports)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "types",
      "lifecycle": "static",
      "notes": [
        "Canonical item model (categories, rarities, resource tags, base ItemDef) shared across all frontends and backends."
      ],
      "owns": [],
      "path": "worldcore/data/items/ItemTypes.ts",
      "provides": [
        "ItemCategory",
        "ItemRarity",
        "ResourceTag",
        "ItemDef"
      ]
    },
    "worldcore/db/ChunkCache.ts": {
      "class": "(exports)",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts",
        "worldcore/utils/logger.ts"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Redis-backed generic chunk cache used by future terrain/worldgen streaming (WGEv3, TerrainStream v3) to store arbitrary per-chunk payloads."
      ],
      "owns": [],
      "path": "worldcore/db/ChunkCache.ts",
      "provides": [
        "ChunkPayload",
        "ChunkCacheOptions",
        "ChunkCache"
      ]
    },
    "worldcore/db/Database.ts": {
      "class": "(exports)",
      "ctorArgs": [],
      "dependsOn": [
        "pg",
        "redis",
        "dotenv",
        "worldcore/utils/logger.ts"
      ],
      "kind": "infra",
      "lifecycle": "singleton",
      "notes": [
        "Central Postgres and Redis connection layer with pooled DB access and lazy Redis connection; currently parked for when shard storage and other DB-backed systems go live."
      ],
      "owns": [],
      "path": "worldcore/db/Database.ts",
      "provides": [
        "db",
        "redis",
        "testDbConnection",
        "ensureRedisConnected"
      ]
    },
    "worldcore/db/ShardStorage.ts": {
      "class": "ShardStorage",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts",
        "worldcore/utils/logger.ts",
        "worldcore/shards/WorldBlueprint.ts"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "Shard-level persistence helper for loading world blueprints (boundary, regions, objects, spawns) from the shards table into WorldBlueprint structures."
      ],
      "owns": [],
      "path": "worldcore/db/ShardStorage.ts",
      "provides": [
        "ShardStorage"
      ]
    },
    "worldcore/economy/EconomyHelpers.ts": {
      "class": "(exports)",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/characters/CharacterTypes.ts",
        "worldcore/items/InventoryHelpers.ts"
      ],
      "kind": "helpers",
      "lifecycle": "static",
      "notes": [
        "High-level gold and item helpers for characters: give/take gold, add/remove item quantities, cost checks and reward application for shops, quests and other systems."
      ],
      "owns": [],
      "path": "worldcore/economy/EconomyHelpers.ts",
      "provides": [
        "SimpleItemStack",
        "ItemApplyResult",
        "getCharacterInventory",
        "getCharacterGold",
        "setCharacterGold",
        "giveGold",
        "trySpendGold",
        "removeItemQuantityFromInventory",
        "addItemQuantityToInventory",
        "giveItemsToCharacter",
        "takeItemsFromCharacter",
        "tryConsumeItems",
        "tryPayCost",
        "grantReward"
      ]
    },
    "worldcore/factions/FactionTypes.ts": {
      "class": "(exports)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "types",
      "lifecycle": "static",
      "notes": [
        "Basic faction model and temporary in-memory faction registry (including test_empire) for early region control, naming and UI tests."
      ],
      "owns": [],
      "path": "worldcore/factions/FactionTypes.ts",
      "provides": [
        "FactionId",
        "Faction",
        "getFactionById",
        "getAllFactions"
      ]
    },
    "worldcore/gathering/GatherTables.ts": {
      "class": "(exports)",
      "ctorArgs": [],
      "dependsOn": [],
      "kind": "data_table",
      "lifecycle": "static",
      "notes": [
        "Weighted herb drop tables keyed by biome+tier (e.g. plains:1, plains:3, plains:5) used by gathering nodes to roll what items a harvest yields."
      ],
      "owns": [],
      "path": "worldcore/gathering/GatherTables.ts",
      "provides": [
        "ResourceDrop",
        "HERB_TABLES"
      ]
    },
    "worldcore/guilds/GuildService.ts": {
      "class": "GuildService",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/db/Database.ts"
      ],
      "kind": "service",
      "lifecycle": "singleton",
      "notes": [
        "DB-backed guild service for resolving a character's guild and listing guild members with rank and basic character info."
      ],
      "owns": [],
      "path": "worldcore/guilds/GuildService.ts",
      "provides": [
        "GuildService"
      ]
    },
    "worldcore/index.ts": {
      "class": "(exports)",
      "ctorArgs": [],
      "dependsOn": [
        "worldcore/config/config",
        "worldcore/config/logconfig",
        "worldcore/config/worldscale",
        "worldcore/shards/WorldBlueprint.ts",
        "worldcore/shared/region.ts",
        "worldcore/terrain/index.ts",
        "worldcore/terrain/worldgen/ScaledWorldgen.ts"
      ],
      "kind": "barrel",
      "lifecycle": "static",
      "notes": [
        "Root worldcore barrel that re-exports config, shard blueprints, shared region types and terrain/worldgen entrypoints as a stable public API."
      ],
      "owns": [],
      "path": "worldcore/index.ts",
      "provides": [
        "config/config",
        "config/logconfig",
        "config/worldscale",
        "shards/WorldBlueprint",
        "shared/region",
        "terrain",
        "terrain/worldgen/ScaledWorldgen"
      ]
    },
    "worldgen.scaled": {
      "dependsOn": [],
      "function": "buildWorldBlueprint",
      "kind": "worldgen_factory",
      "notes": [
        "Ultra-light v1 worldgen: creates a dome boundary and a default spawn for a shard.",
        "Used directly by ServerWorldManager to build the prime shard blueprint."
      ],
      "path": "worldcore/terrain/worldgen/ScaledWorldgen.ts",
      "provides": [
        "buildWorldBlueprint(input:ShardWorldInput):WorldBlueprint"
      ]
    },
    "worldgen.v2.biomes": {
      "class": "WGEv2BiomesStage",
      "dependsOn": [
        "worldgen.v2.landforms",
        "worldgen.v2.erosion",
        "worldgen.v2.climate"
      ],
      "kind": "worldgen_stage",
      "lifecycle": "stateless",
      "notes": [
        "Stage 2.3.4 \u2013 biome assignment per cell + connected biome clusters.",
        "Outputs biomeMap + cluster IDs + counts per biome."
      ],
      "path": "worldcore/terrain/worldgen/WGEv2Biomes.ts",
      "provides": [
        "run(input:BiomeInput, ctx?:WorldGenContext):BiomeResult"
      ]
    },
    "worldgen.v2.civilization": {
      "class": "WGEv2CivilizationStage",
      "dependsOn": [
        "worldgen.v2.landforms",
        "worldgen.v2.erosion",
        "worldgen.v2.climate",
        "worldgen.v2.biomes"
      ],
      "kind": "worldgen_stage",
      "lifecycle": "stateless",
      "notes": [
        "Stage 2.3.5 \u2013 settlements, roads, and POIs.",
        "Scores candidate cells, picks settlements with spacing, builds a road graph, scatters points of interest."
      ],
      "path": "worldcore/terrain/worldgen/WGEv2Civilization.ts",
      "provides": [
        "run(input:CivilizationInput, ctx?:WorldGenContext):CivilizationResult"
      ]
    },
    "worldgen.v2.climate": {
      "class": "WGEv2ClimateStage",
      "dependsOn": [
        "worldgen.v2.landforms",
        "worldgen.v2.erosion?"
      ],
      "kind": "worldgen_stage",
      "lifecycle": "stateless",
      "notes": [
        "Stage 2.3.3 \u2013 temperature, moisture, and compact climate zones.",
        "Can optionally use erosion outputs to bias humidity near rivers/lakes."
      ],
      "path": "worldcore/terrain/worldgen/WGEv2Climate.ts",
      "provides": [
        "run(input:ClimateInput, ctx?:WorldGenContext):ClimateResult"
      ]
    },
    "worldgen.v2.erosion": {
      "class": "WGEv2ErosionStage",
      "dependsOn": [
        "worldgen.v2.landforms"
      ],
      "kind": "worldgen_stage",
      "lifecycle": "stateless",
      "notes": [
        "Stage 2.3.2 \u2013 hydrology, erosion, rivers, lakes.",
        "Outputs updated elevation, water, sediment, flow dirs, river/lake masks."
      ],
      "path": "worldcore/terrain/worldgen/WGEv2Erosion.ts",
      "provides": [
        "run(input:{ landforms:LandformResult, params?:ErosionParams }, ctx?:WorldGenContext):ErosionResult"
      ]
    },
    "worldgen.v2.landforms": {
      "class": "WGEv2LandformsStage",
      "dependsOn": [],
      "kind": "worldgen_stage",
      "lifecycle": "stateless",
      "notes": [
        "Stage 2.3.1 \u2013 base landforms: tectonics, continents, uplift, macro elevation.",
        "First stage in the WGEv2 pipeline; everything else builds on its LandformResult."
      ],
      "path": "worldcore/terrain/worldgen/WGEv2Landforms.ts",
      "provides": [
        "run(input:ShardSeedInput, ctx?:WorldGenContext):LandformResult"
      ]
    },
    "worldgen.v2.resources": {
      "class": "WGEv2ResourcesStage",
      "dependsOn": [
        "worldgen.v2.landforms",
        "worldgen.v2.erosion",
        "worldgen.v2.climate",
        "worldgen.v2.biomes",
        "worldgen.v2.civilization"
      ],
      "kind": "worldgen_stage",
      "lifecycle": "stateless",
      "notes": [
        "Stage 2.3.6 \u2013 resource node placement (ore/herb/wood/fish/rare) plus per-kind masks.",
        "Respects biome, elevation, climate, hydrology, and avoids city centers while tagging 'near settlement' nodes."
      ],
      "path": "worldcore/terrain/worldgen/WGEv2Resources.ts",
      "provides": [
        "run(input:ResourceInput, ctx?:WorldGenContext):ResourceResult"
      ]
    }
  }
}
