// worldcore/combat/StatusEffects.ts
//
// v1 status-effect spine for combat.
//
// Storage:
//  - Characters: CharacterState.progression.statusEffects (JSON-ish)
//  - Entities (NPCs): (entity as any).combatStatusEffects (JSON-ish)
//
// Snapshot:
//  - computeCombatStatusSnapshot(char) returns a pure aggregated view.
//  - computeEntityCombatStatusSnapshot(entity) does the same for NPCs.
//
// DOT:
//  - DOTs are stored as status effects with an optional `dot` payload.
//  - TickEngine (and tests) can call tickEntityStatusEffectsAndApplyDots(...) to apply periodic damage.
//
// Stacking (extended):
//  - Default behavior is legacy: one instance per id, stacks add, expiry extends.
//  - Optional `stackingPolicy` adds additional behaviors including:
//      - "refresh"              (no stack increase, refresh/extend only)
//      - "stack_add"            (explicit stacks + refresh)
//      - "versioned_by_applier" (distinct versions stack iff from distinct appliers, capped)
//
// NOTE: sourceKind/sourceId are OPTIONAL so tests/tools can apply ad-hoc effects
// without needing to invent provenance every time.

import type { CharacterState, Attributes } from "../characters/CharacterTypes";
import type { Entity } from "../shared/Entity";
import type { DamageSchool } from "./CombatEngine";
import { resolveStatusStackingPolicy, type StatusStackingPolicy } from "./StatusStackingPolicy";

export type StatusEffectId = string;

export type StatusEffectSourceKind =
  | "spell"
  | "song"
  | "item"
  | "ability"
  | "environment";

export type StatusEffectApplierKind = "character" | "npc" | "system" | "unknown";

export interface StatusEffectModifier {
  // Flat attribute bonuses, e.g. { str: +5 }
  attributes?: Partial<Attributes>;

  // Percent attribute bonuses, e.g. { str: 0.10 } = +10% STR
  attributesPct?: Partial<Attributes>;

  // Global multipliers (fractions; 0.10 = +10%)
  damageDealtPct?: number;
  damageTakenPct?: number;

  // Per-school multipliers (fractions; 0.10 = +10%)
  damageDealtPctBySchool?: Partial<Record<DamageSchool, number>>;
  damageTakenPctBySchool?: Partial<Record<DamageSchool, number>>;

  // Armor adjustments
  armorFlat?: number;
  armorPct?: number;

  // Per-school resist adjustments
  resistFlat?: Partial<Record<DamageSchool, number>>;
  resistPct?: Partial<Record<DamageSchool, number>>;

  // ────────────────────────────────────────────────────────────────────────────
  // Threat / aggro modifiers (NPC threat table)
  // ────────────────────────────────────────────────────────────────────────────

  /**
   * If set, a portion of threat generated by this entity is credited to the
   * specified entity instead ("misdirect" / "threat redirect").
   */
  threatTransferToEntityId?: string;

  /**
   * Fraction [0..1]. 1 means transfer all threat; 0 means transfer none.
   * Default when `threatTransferToEntityId` is set: 1.
   */
  threatTransferPct?: number;
}

export interface DotPayloadInput {
  tickIntervalMs: number;
  /** Base damage per tick (before defender damageTaken modifiers). */
  perTickDamage: number;
  /** Damage school for defender taken modifiers / resists (default: "pure"). */
  damageSchool?: DamageSchool;
}

export interface DotPayloadState extends DotPayloadInput {
  /** Internal scheduler: next time we should tick. */
  nextTickAtMs: number;
}

export interface HotPayloadInput {
  tickIntervalMs: number;
  /** Base healing per tick. */
  perTickHeal: number;
}

export interface HotPayloadState extends HotPayloadInput {
  nextTickAtMs: number;
}

export interface AbsorbPayloadInput {
  /** Total amount of damage this shield can absorb. */
  amount: number;
  /** Optional: only absorb these schools. If omitted, absorb any. */
  schools?: DamageSchool[];
}

export interface AbsorbPayloadState extends AbsorbPayloadInput {
  remaining: number;
}

export interface StatusEffectInstance {
  id: StatusEffectId;
  sourceKind: StatusEffectSourceKind;
  sourceId: string;
  name?: string;
  appliedAtMs: number;
  expiresAtMs: number; // < now => expired (note: strict '<' so expiry moment is inclusive)
  stackCount: number;
  maxStacks: number;
  modifiers: StatusEffectModifier;
  tags?: string[];

  // Optional DOT payload (NPCs today; can be used on players later if desired)
  dot?: DotPayloadState;

  // Optional HOT payload (players today; can be used on NPCs later if desired)
  hot?: HotPayloadState;

  // Optional absorb/shield payload
  absorb?: AbsorbPayloadState;

  // ────────────────────────────────────────────────────────────────────────────
  // Optional extended stacking metadata (safe to ignore for legacy effects)
  // ────────────────────────────────────────────────────────────────────────────
  stackingPolicy?: StatusStackingPolicy;
  stackingGroupId?: string;

  /** Who applied this specific instance (used by versioned_by_applier). */
  appliedByKind?: StatusEffectApplierKind;
  appliedById?: string;

  /** Version key (defaults to sourceId). Only relevant for versioned_by_applier. */
  versionKey?: string;

  // ────────────────────────────────────────────────────────────────────────────
  // Optional application metadata
  // ────────────────────────────────────────────────────────────────────────────
  /** When false, the effect was blocked and NOT stored (e.g., CC DR immunity). */
  wasApplied?: boolean;
  /** Machine-readable reason when wasApplied=false. */
  blockedReason?: string;
}

export interface NewStatusEffectInput {
  id: StatusEffectId;
  sourceKind?: StatusEffectSourceKind;
  sourceId?: string;
  name?: string;

  // How long this effect should last; <=0 means "until cleared".
  durationMs: number;

  maxStacks?: number;

  // How many stacks to apply with this application (defaults to 1).
  // If effect already exists, this is how many stacks are added (legacy).
  initialStacks?: number;

  /**
   * Back-compat alias for initialStacks (some call sites used 'stacks').
   * Prefer initialStacks going forward.
   */
  stacks?: number;

  modifiers: StatusEffectModifier;
  tags?: string[];

  // Optional DOT payload (stored on the status instance).
  dot?: DotPayloadInput;


  // Optional HOT payload (stored on the status instance).
  hot?: HotPayloadInput;

  // Optional absorb/shield payload.
  absorb?: AbsorbPayloadInput;

  // ────────────────────────────────────────────────────────────────────────────
  // Optional extended stacking controls
  // ────────────────────────────────────────────────────────────────────────────

  /**
   * Stacking policy (rules of the universe).
   *
   * Default: "legacy_add" (one instance per id; stacks add; expiry extends).
   */
  stackingPolicy?: StatusStackingPolicy;

  /**
   * Optional grouping key used for storage/stacking. Defaults to `id`.
   * Useful if multiple different effect ids should share a stacking bucket.
   */
  stackingGroupId?: string;

  /**
   * Identity of the applier (caster). Used for versioned_by_applier:
   * each applier can contribute at most one active instance in the bucket.
   */
  appliedByKind?: StatusEffectApplierKind;
  appliedById?: string;

  /**
   * Version key for versioned_by_applier. Defaults to sourceId.
   * Typically the spell id (rank1/rank2/etc).
   */
  versionKey?: string;
}

type ActiveBucket = StatusEffectInstance | StatusEffectInstance[];

interface InternalStatusState {
  active: Record<string, ActiveBucket>;
  meta?: {
    /** Last time tickStatusEffectsInternal ran for this state. */
    lastTickAtMs?: number;
    /** Last time we pruned at least one effect. */
    lastPruneAtMs?: number;
    /** Number of effect instances pruned in the last tick. */
    lastPrunedCount?: number;
    /** Total number of effect instances pruned over time. */
    totalPrunedCount?: number;
  };
}

/**
 * Character storage: CharacterState.progression.statusEffects.active
 */
function ensureStatusState(char: CharacterState): InternalStatusState {
  const prog: any = (char as any).progression || {};

  if (!prog.statusEffects || typeof prog.statusEffects !== "object") {
    prog.statusEffects = { active: {} as Record<string, ActiveBucket> };
  } else if (!prog.statusEffects.active) {
    prog.statusEffects.active = {} as Record<string, ActiveBucket>;
  }

  if (!prog.statusEffects.meta || typeof prog.statusEffects.meta !== 'object') {
    prog.statusEffects.meta = {} as any;
  }

  (char as any).progression = prog;
  return prog.statusEffects as InternalStatusState;
}

/**
 * Entity storage (NPCs): (entity as any).combatStatusEffects.active
 */
function ensureEntityStatusState(entity: Entity): InternalStatusState {
  const e: any = entity as any;

  if (!e.combatStatusEffects || typeof e.combatStatusEffects !== "object") {
    e.combatStatusEffects = { active: {} as Record<string, ActiveBucket> };
  } else if (!e.combatStatusEffects.active) {
    e.combatStatusEffects.active = {} as Record<string, ActiveBucket>;
  }

  if (!e.combatStatusEffects.meta || typeof e.combatStatusEffects.meta !== 'object') {
    e.combatStatusEffects.meta = {} as any;
  }

  return e.combatStatusEffects as InternalStatusState;
}

function normalizeBucket(bucket: ActiveBucket | undefined | null): StatusEffectInstance[] {
  if (!bucket) return [];
  if (Array.isArray(bucket)) return bucket.filter(Boolean);
  return bucket ? [bucket] : [];
}

function writeBucket(state: InternalStatusState, key: string, items: StatusEffectInstance[]): void {
  const list = items.filter(Boolean);
  if (list.length <= 0) {
    delete state.active[key];
  } else if (list.length === 1) {
    state.active[key] = list[0]!;
  } else {
    state.active[key] = list;
  }
}

function resolveInitialStacks(input: NewStatusEffectInput): number {
  return typeof input.initialStacks === "number" && input.initialStacks > 0
    ? input.initialStacks
    : typeof (input as any).stacks === "number" && (input as any).stacks > 0
      ? Number((input as any).stacks)
      : 1;
}

function resolveMaxStacks(input: NewStatusEffectInput, fallback: number): number {
  return typeof input.maxStacks === "number" && input.maxStacks > 0
    ? input.maxStacks
    : fallback > 0
      ? fallback
      : 1;
}

function resolveExpiresAt(now: number, durationMs: number): number {
  const dur =
    typeof durationMs === "number" && Number.isFinite(durationMs) && durationMs > 0
      ? durationMs
      : 0;

  return dur > 0 ? now + dur : Number.MAX_SAFE_INTEGER;
}

function resolveDot(
  input: NewStatusEffectInput,
  now: number,
  existingDot?: DotPayloadState,
): DotPayloadState | undefined {
  if (!input.dot) return existingDot;

  const tickIntervalMs = Math.max(1, Math.floor(Number(input.dot.tickIntervalMs ?? 0)));
  const perTickDamage = Math.max(1, Math.floor(Number(input.dot.perTickDamage ?? 0)));
  const damageSchool: DamageSchool =
    (input.dot.damageSchool as DamageSchool) ?? (existingDot?.damageSchool as any) ?? "pure";

  return {
    tickIntervalMs,
    perTickDamage,
    damageSchool,
    nextTickAtMs: now + tickIntervalMs,
  };
}

function resolveHot(
  input: NewStatusEffectInput,
  now: number,
  existingHot?: HotPayloadState,
): HotPayloadState | undefined {
  if (!input.hot) return existingHot;

  const tickIntervalMs = Math.max(1, Math.floor(Number(input.hot.tickIntervalMs ?? 0)));
  const perTickHeal = Math.max(1, Math.floor(Number(input.hot.perTickHeal ?? 0)));

  return {
    tickIntervalMs,
    perTickHeal,
    nextTickAtMs: now + tickIntervalMs,
  };
}

function resolveAbsorb(
  input: NewStatusEffectInput,
  existingAbsorb?: AbsorbPayloadState,
): AbsorbPayloadState | undefined {
  if (!input.absorb) return existingAbsorb;

  const amount = Math.max(0, Math.floor(Number(input.absorb.amount ?? 0)));
  const schools = Array.isArray(input.absorb.schools) ? input.absorb.schools.slice() : undefined;

  return {
    amount,
    remaining: amount,
    schools,
  };
}

function resolvePolicy(input: NewStatusEffectInput): StatusStackingPolicy {
  // DOTs should be safe for multi-caster stacking by default.
  // If a caller explicitly chooses a policy, honor it.
  if (input.dot && input.stackingPolicy == null) {
    return "versioned_by_applier";
  }

  // Default is the historical behavior.
  return resolveStatusStackingPolicy(input.stackingPolicy, "legacy_add");
}

/**
 * Drop expired effects and clamp stack counts.
 */
export function tickStatusEffects(
  char: CharacterState,
  now: number = Date.now(),
): void {
  tickStatusEffectsInternal(ensureStatusState(char), now);
}

export function tickEntityStatusEffects(
  entity: Entity,
  now: number = Date.now(),
): void {
  tickStatusEffectsInternal(ensureEntityStatusState(entity), now);
}

function tickStatusEffectsInternal(state: InternalStatusState, now: number): void {
  const meta = (state.meta = state.meta ?? {});
  meta.lastTickAtMs = now;

  let prunedCount = 0;

  for (const [key, bucket] of Object.entries(state.active)) {
    const items = normalizeBucket(bucket);
    const before = items.length;
    const kept: StatusEffectInstance[] = [];

    for (const inst of items) {
      if (!inst) continue;

      const maxStacks = inst.maxStacks > 0 ? inst.maxStacks : 1;

      if (inst.stackCount <= 0) {
        continue;
      }

      if (inst.stackCount > maxStacks) {
        inst.stackCount = maxStacks;
      }

      // NOTE: strict '<' so an effect expiring at now is still present for this moment.
      if (inst.expiresAtMs > 0 && inst.expiresAtMs < now) {
        continue;
      }

      kept.push(inst);
    }

    prunedCount += Math.max(0, before - kept.length);
    writeBucket(state, key, kept);
  }

  meta.lastPrunedCount = prunedCount;
  if (prunedCount > 0) {
    meta.lastPruneAtMs = now;
    meta.totalPrunedCount = (meta.totalPrunedCount ?? 0) + prunedCount;
  }
}

/**
 * Apply or refresh a status effect on a character.
 */
export function applyStatusEffect(
  char: CharacterState,
  input: NewStatusEffectInput,
  now: number = Date.now(),
): StatusEffectInstance {
  return applyStatusEffectInternal(ensureStatusState(char), input, now);
}

/**
 * Apply or refresh a status effect on an entity (NPC).
 */
export function applyStatusEffectToEntity(
  entity: Entity,
  input: NewStatusEffectInput,
  now: number = Date.now(),
): StatusEffectInstance {
  return applyStatusEffectInternal(ensureEntityStatusState(entity), input, now);
}

/**
 * CC diminishing returns precheck for denial paths.
 *
 * Purpose: allow callers (MudSpells/MudAbilities) to short-circuit BEFORE spending
 * resources or starting cooldowns when the DR stage has reached an immunity (mult=0).
 *
 * IMPORTANT: this ONLY records/extends the DR window when the target is already immune.
 * For non-immune applications, the DR window/stage is recorded by applyStatusEffect*().
 */
export function wouldCcDiminishingReturnsBlockForEntity(
  entity: Entity,
  tags: string[] | undefined | null,
  now: number = Date.now(),
): boolean {
  return wouldCcDiminishingReturnsBlockInternal(ensureEntityStatusState(entity), tags, now);
}

export function wouldCcDiminishingReturnsBlock(
  char: CharacterState,
  tags: string[] | undefined | null,
  now: number = Date.now(),
): boolean {
  return wouldCcDiminishingReturnsBlockInternal(ensureStatusState(char), tags, now);
}

function getCcDrBucketMap(): Record<string, string> {
  const map: Record<string, string> = {};

  const parseInto = (raw: string) => {
    for (const part of String(raw).split(";")) {
      const p = part.trim();
      if (!p) continue;
      const [bucket, tagsRaw] = p.split("=").map((x) => (x ?? "").trim());
      if (!bucket || !tagsRaw) continue;
      for (const t of tagsRaw
        .split(",")
        .map((x) => x.trim().toLowerCase())
        .filter(Boolean)) {
        map[t] = bucket.toLowerCase();
      }
    }
  };

  // 1) Explicit mapping always wins.
  try {
    const raw = process.env.PW_CC_DR_BUCKETS;
    if (raw) {
      parseInto(raw);
      return map;
    }
  } catch {
    // ignore
  }

  // 2) Optional preset mapping (only used when PW_CC_DR_BUCKETS is not set).
  const presetRaw = process.env.PW_CC_DR_BUCKET_PRESET;
  const preset = presetRaw ? String(presetRaw).trim().toLowerCase() : "";
  if (preset === "classic") {
    // Classic-ish grouping: mez and sleep share, stuns share, roots share.
    parseInto("cc=mez,sleep;stunline=stun,knockdown;rootline=root,snare");
  } else if (preset === "pvp") {
    // PvP-ish grouping: most hard CC shares a single bucket (prevents CC chain lock).
    // Roots/snares share a separate bucket.
    parseInto("hardcc=mez,sleep,stun,knockdown,fear,incapacitate;rootline=root,snare");
  }

  return map;
}

function wouldCcDiminishingReturnsBlockInternal(
  state: InternalStatusState,
  tags: string[] | undefined | null,
  now: number,
): boolean {
  const inputTags = Array.isArray(tags) ? tags.map((t) => String(t).toLowerCase()) : [];
  if (inputTags.length === 0) return false;

  try {
    const enabledRaw = process.env.PW_CC_DR_ENABLED;
    const enabled = enabledRaw == null ? true : String(enabledRaw).toLowerCase() !== "false";
    if (!enabled) return false;

    const windowMs = Math.max(0, Math.floor(Number(process.env.PW_CC_DR_WINDOW_MS ?? 18000)));
    const tagList = String(process.env.PW_CC_DR_TAGS ?? "stun,mez,sleep,fear,root,knockdown,incapacitate")
      .split(",")
      .map((s) => s.trim().toLowerCase())
      .filter(Boolean);

    const bucketMap = getCcDrBucketMap();

    const matchTag = tagList.find((t) => inputTags.includes(t));
    if (!matchTag) return false;

    const bucketKey = bucketMap[matchTag] ?? matchTag;

    const mults = String(process.env.PW_CC_DR_MULTS ?? "1,0.5,0.25")
      .split(",")
      .map((s) => Number(s.trim()))
      .filter((n) => Number.isFinite(n) && n >= 0);
    const stages = mults.length > 0 ? mults : [1, 0.5, 0.25];

    const meta: any = (state as any).meta ?? ((state as any).meta = {});
    const key = "_pwCcDr";
    const dr: Record<string, { stage: number; untilMs: number }> = meta[key] ?? (meta[key] = {});

    const prev = dr[bucketKey];
    const expired = !prev || !(typeof prev.untilMs === "number") || prev.untilMs <= now;
    const stagePrev = expired ? 0 : Math.max(0, Math.floor(Number(prev.stage ?? 0)));

    const mult = stages[Math.min(stagePrev, stages.length - 1)] ?? stages[0];
    if (mult > 0) return false;

    // Immune stage: record/extend the window so repeated immune attempts keep the
    // DR window "hot" (prevents spam from instantly resetting).
    const stageNext = Math.min(stages.length - 1, stagePrev + 1);
    dr[bucketKey] = { stage: stageNext, untilMs: now + windowMs };
    return true;
  } catch {
    return false;
  }
}

/**
 * Internal apply logic (supports legacy + policy-based stacking).
 */
function applyStatusEffectInternal(
  state: InternalStatusState,
  input: NewStatusEffectInput,
  now: number,
): StatusEffectInstance {
  // ────────────────────────────────────────────────────────────────────────────
  // CC diminishing returns (v0): repeated CC applications within a window shorten
  // duration deterministically.
  //
  // Design goals:
  // - Purely server-side (no schema churn); stored in state.meta.
  // - Deterministic in tests: caller controls `now`.
  // - Safe default: only affects finite-duration effects (>0 durationMs).
  //
  // Env knobs:
  // - PW_CC_DR_ENABLED (default true)
  // - PW_CC_DR_WINDOW_MS (default 18000)
  // - PW_CC_DR_TAGS (default "stun,mez,sleep,fear,root,knockdown,incapacitate")
  // - PW_CC_DR_MULTS (default "1,0.5,0.25")
  //
  // NOTE: v0 does NOT implement full immunity stage; it floors at the last mult.
  const inputTags = Array.isArray(input.tags) ? input.tags.map((t) => String(t).toLowerCase()) : [];
  let durationMs = Number(input.durationMs ?? 0);
  let drBlocked = false;
  let drBlockedReason: string | null = null;
  try {
    const enabledRaw = process.env.PW_CC_DR_ENABLED;
    const enabled = enabledRaw == null ? true : String(enabledRaw).toLowerCase() !== "false";

    if (enabled && durationMs > 0 && inputTags.length > 0) {
      const windowMs = Math.max(0, Math.floor(Number(process.env.PW_CC_DR_WINDOW_MS ?? 18000)));
      const tagList = String(process.env.PW_CC_DR_TAGS ?? "stun,mez,sleep,fear,root,knockdown,incapacitate")
  .split(",")
  .map((s) => s.trim().toLowerCase())
  .filter(Boolean);

      const bucketMap = getCcDrBucketMap();

      const matchTag = tagList.find((t) => inputTags.includes(t));
if (matchTag) {
  const bucketKey = bucketMap[matchTag] ?? matchTag;

  const mults = String(process.env.PW_CC_DR_MULTS ?? "1,0.5,0.25")
    .split(",")
    .map((s) => Number(s.trim()))
    .filter((n) => Number.isFinite(n) && n >= 0);
  const stages = mults.length > 0 ? mults : [1, 0.5, 0.25];

  const meta: any = (state as any).meta ?? ((state as any).meta = {});
  const key = "_pwCcDr";
  const dr: Record<string, { stage: number; untilMs: number }> = meta[key] ?? (meta[key] = {});

  const prev = dr[bucketKey];
  const expired = !prev || !(typeof prev.untilMs === "number") || prev.untilMs <= now;
  const stagePrev = expired ? 0 : Math.max(0, Math.floor(Number(prev.stage ?? 0)));
  const mult = stages[Math.min(stagePrev, stages.length - 1)] ?? stages[0];
  const stageNext = Math.min(stages.length - 1, stagePrev + 1);

  // When mult is 0, we treat it as an immunity stage: block application entirely.
  if (mult <= 0) {
    dr[bucketKey] = { stage: stageNext, untilMs: now + windowMs };
    drBlocked = true;
    drBlockedReason = "cc_dr_immune";
  } else {
    // Apply multiplier and clamp to a small minimum to avoid 0/negative durations.
    durationMs = Math.max(250, Math.floor(durationMs * mult));
    dr[bucketKey] = { stage: stageNext, untilMs: now + windowMs };
  }
}
    }
  } catch {
    // fail open
  }

  const sourceKind: StatusEffectSourceKind = input.sourceKind ?? "environment";
  const sourceId = input.sourceId ?? "unknown";

  if (drBlocked) {
    return {
      id: input.id,
      sourceKind,
      sourceId,
      name: input.name,
      appliedAtMs: now,
      expiresAtMs: now,
      stackCount: 0,
      maxStacks: 0,
      modifiers: input.modifiers ?? {},
      tags: input.tags,
      stackingPolicy: input.stackingPolicy,
      stackingGroupId: input.stackingGroupId,
      appliedByKind: input.appliedByKind,
      appliedById: input.appliedById,
      versionKey: input.versionKey,
      wasApplied: false,
      blockedReason: drBlockedReason ?? undefined,
    };
  }

  const bucketKey = (typeof input.stackingGroupId === "string" && input.stackingGroupId.trim())
    ? input.stackingGroupId.trim()
    : input.id;

  const policy = resolvePolicy(input);

  const expiresAtMs = resolveExpiresAt(now, durationMs);
  const existingBucket = state.active[bucketKey];
  const existingList = normalizeBucket(existingBucket);

  const initialStacks = resolveInitialStacks(input);

  // For non-versioned policies, maxStacks is per-effect as before.
  // For versioned_by_applier, maxStacks acts as a CONTRIBUTOR/VERSION CAP (bucket size cap).
  const resolvedMaxStacks = resolveMaxStacks(
    input,
    existingList[0]?.maxStacks ?? initialStacks,
  );

  // ────────────────────────────────────────────────────────────────────────────
  // versioned_by_applier: multiple instances per bucket (distinct versions),
  // but only if applied by different appliers.
  // ────────────────────────────────────────────────────────────────────────────
  if (policy === "versioned_by_applier") {
    const appliedById =
      typeof input.appliedById === "string" && input.appliedById.trim()
        ? input.appliedById.trim()
        : "unknown";

    const appliedByKind: StatusEffectApplierKind = input.appliedByKind ?? "unknown";

    // Version semantics:
    // - If caller provides versionKey, it is GLOBAL (same key replaces across appliers).
    // - If versionKey is omitted AND this is a DOT, derive a per-caster versionKey so
    //   multiple casters can contribute without overwriting each other.
    let versionKey =
      typeof input.versionKey === "string" && input.versionKey.trim()
        ? input.versionKey.trim()
        : sourceId;

    if (!(typeof input.versionKey === "string" && input.versionKey.trim())) {
      if (input.dot && appliedById !== "unknown") {
        versionKey = `${sourceId}:${appliedByKind}:${appliedById}`;
      }
    }

    // Under versioned_by_applier, maxStacks is a CONTRIBUTOR/VERSION CAP.
    // For DOTs, default to a small multi-caster cap when not explicitly specified.
    const contributorCap =
      typeof input.maxStacks === "number" && input.maxStacks > 0
        ? input.maxStacks
        : (existingList[0]?.maxStacks && existingList[0]!.maxStacks > 0
            ? existingList[0]!.maxStacks
            : (input.dot ? 8 : resolvedMaxStacks));


    const idxByApplier = existingList.findIndex((e) => (e.appliedById ?? "unknown") === appliedById);
    const idxByVersion = existingList.findIndex((e) => (e.versionKey ?? e.sourceId ?? "unknown") === versionKey);

    const pickIdx = idxByApplier >= 0 ? idxByApplier : idxByVersion;

    const existing =
      pickIdx >= 0 ? existingList[pickIdx] : undefined;

    const dot = resolveDot(input, now, existing?.dot);
    const hot = resolveHot(input, now, existing?.hot);
    const absorb = resolveAbsorb(input, existing?.absorb);

    const inst: StatusEffectInstance = {
      id: input.id,
      sourceKind,
      sourceId,
      name: input.name ?? existing?.name,
      appliedAtMs: now,
      // Keep the later expiry if one already existed in this slot.
      expiresAtMs:
        existing?.expiresAtMs != null && existing.expiresAtMs > 0
          ? Math.max(existing.expiresAtMs, expiresAtMs)
          : expiresAtMs,
      // Under versioned_by_applier, stacks are intentionally NOT the main axis;
      // the bucket size is the cap. Keep per-instance stacks minimal and deterministic.
      stackCount: 1,
      maxStacks: contributorCap,
      modifiers: input.modifiers ?? existing?.modifiers ?? {},
      tags: input.tags ?? existing?.tags,
      dot,
      hot,
      absorb,

      stackingPolicy: policy,
      stackingGroupId: bucketKey,
      appliedByKind,
      appliedById,
      versionKey,
    };

    // Update/replace an existing slot
    if (pickIdx >= 0) {
      existingList[pickIdx] = inst;
      writeBucket(state, bucketKey, existingList);
      return inst;
    }

    // Add a new contributor slot if below cap.
    if (existingList.length < contributorCap) {
      existingList.push(inst);
      writeBucket(state, bucketKey, existingList);
      return inst;
    }

    // Cap reached: reject new contribution, but still allow refresh if we had a match
    // (handled above). Return the "oldest" as a stable return value.
    const fallback = existingList[0];
    return fallback ?? inst;
  }

  // ────────────────────────────────────────────────────────────────────────────
  // Non-versioned policies: single instance per bucketKey
  // ────────────────────────────────────────────────────────────────────────────
  const existing = existingList[0];
  const dot = resolveDot(input, now, existing?.dot);
  const hot = resolveHot(input, now, existing?.hot);
  const absorb = resolveAbsorb(input, existing?.absorb);

  if (existing) {
    const maxStacks = resolvedMaxStacks;

    let stackCount = existing.stackCount;
    if (policy !== "refresh") {
      // legacy_add / stack_add: add stacks
      stackCount = Math.min(maxStacks, existing.stackCount + initialStacks);
    } else {
      // refresh: keep current stackCount, but clamp to maxStacks
      stackCount = Math.min(maxStacks, existing.stackCount);
    }

    const updated: StatusEffectInstance = {
      ...existing,
      sourceKind,
      sourceId,
      name: input.name ?? existing.name,
      modifiers: input.modifiers ?? existing.modifiers,
      tags: input.tags ?? existing.tags,
      stackCount,
      maxStacks,
      appliedAtMs: now,
      // Keep the later expiry if one already existed
      expiresAtMs:
        existing.expiresAtMs > 0 ? Math.max(existing.expiresAtMs, expiresAtMs) : expiresAtMs,
      dot,
      hot,
      absorb,

      stackingPolicy: policy,
      stackingGroupId: bucketKey,
      appliedByKind: input.appliedByKind ?? existing.appliedByKind,
      appliedById: input.appliedById ?? existing.appliedById,
    };

    writeBucket(state, bucketKey, [updated]);
    return updated;
  }

  const inst: StatusEffectInstance = {
    id: input.id,
    sourceKind,
    sourceId,
    name: input.name,
    appliedAtMs: now,
    expiresAtMs,
    stackCount: initialStacks,
    maxStacks: resolvedMaxStacks,
    modifiers: input.modifiers ?? {},
    tags: input.tags,
    dot,
    hot,
    absorb,

    stackingPolicy: policy,
    stackingGroupId: bucketKey,
    appliedByKind: input.appliedByKind,
    appliedById: input.appliedById,
  };

  writeBucket(state, bucketKey, [inst]);
  return inst;
}

export function clearStatusEffect(char: CharacterState, id: StatusEffectId): void {
  const state = ensureStatusState(char);
  delete state.active[id];
}

export function clearAllStatusEffects(char: CharacterState): void {
  const state = ensureStatusState(char);
  state.active = {};
}

export function clearStatusEffectFromEntity(entity: Entity, id: StatusEffectId): void {
  const state = ensureEntityStatusState(entity);
  delete state.active[id];
}

export function clearAllStatusEffectsFromEntity(entity: Entity): void {
  const state = ensureEntityStatusState(entity);
  state.active = {};
}

export interface CombatStatusSnapshot {
  // Flat attribute bonuses (additive)
  attributesFlat: Partial<Attributes>;

  // Percent attribute bonuses (0.10 = +10%)
  attributesPct: Partial<Attributes>;

  // Generic outgoing / incoming damage modifiers
  damageDealtPct: number;
  damageTakenPct: number;

  // Per-school outgoing / incoming damage modifiers
  damageDealtPctBySchool: Partial<Record<DamageSchool, number>>;
  damageTakenPctBySchool: Partial<Record<DamageSchool, number>>;

  // Armor/resists
  armorFlat: number;
  armorPct: number;
  resistFlat: Partial<Record<DamageSchool, number>>;
  resistPct: Partial<Record<DamageSchool, number>>;
}

/**
 * Convenience helper for UI: get a cleaned list of active effects.
 */
export function getActiveStatusEffects(
  char: CharacterState,
  now: number = Date.now(),
): StatusEffectInstance[] {
  tickStatusEffects(char, now);
  const state = ensureStatusState(char);

  const out: StatusEffectInstance[] = [];
  for (const bucket of Object.values(state.active)) {
    for (const inst of normalizeBucket(bucket)) {
      if (inst) out.push(inst);
    }
  }
  return out;
}

export function getActiveStatusEffectsForEntity(
  entity: Entity,
  now: number = Date.now(),
): StatusEffectInstance[] {
  tickEntityStatusEffects(entity, now);
  const state = ensureEntityStatusState(entity);

  const out: StatusEffectInstance[] = [];
  for (const bucket of Object.values(state.active)) {
    for (const inst of normalizeBucket(bucket)) {
      if (inst) out.push(inst);
    }
  }
  return out;
}

function addSchoolMap(
  dst: Partial<Record<DamageSchool, number>>,
  src: Partial<Record<DamageSchool, number>> | undefined,
  stacks: number,
): void {
  if (!src) return;
  for (const [k, v] of Object.entries(src)) {
    const key = k as DamageSchool;
    const val = Number(v);
    if (!Number.isFinite(val) || val === 0) continue;
    const cur = (dst as any)[key] ?? 0;
    (dst as any)[key] = cur + val * stacks;
  }
}

function computeSnapshotFromState(
  state: InternalStatusState,
  now: number,
): CombatStatusSnapshot {
  // First pass: prune expired
  tickStatusEffectsInternal(state, now);

  const attributesFlat: Partial<Attributes> = {};
  const attributesPct: Partial<Attributes> = {};
  const resistFlat: Partial<Record<DamageSchool, number>> = {};
  const resistPct: Partial<Record<DamageSchool, number>> = {};

  const damageDealtPctBySchool: Partial<Record<DamageSchool, number>> = {};
  const damageTakenPctBySchool: Partial<Record<DamageSchool, number>> = {};

  let damageDealtPct = 0;
  let damageTakenPct = 0;
  let armorFlat = 0;
  let armorPct = 0;

  for (const bucket of Object.values(state.active)) {
    for (const inst of normalizeBucket(bucket)) {
      if (!inst) continue;

      const stacks = inst.stackCount > 0 ? inst.stackCount : 1;
      const mods = inst.modifiers || {};

      if (mods.attributes) {
        for (const [k, v] of Object.entries(mods.attributes)) {
          const key = k as keyof Attributes;
          const val = Number(v);
          if (!Number.isFinite(val) || val === 0) continue;
          const cur = (attributesFlat as any)[key] ?? 0;
          (attributesFlat as any)[key] = cur + val * stacks;
        }
      }

      if (mods.attributesPct) {
        for (const [k, v] of Object.entries(mods.attributesPct)) {
          const key = k as keyof Attributes;
          const val = Number(v);
          if (!Number.isFinite(val) || val === 0) continue;
          const cur = (attributesPct as any)[key] ?? 0;
          (attributesPct as any)[key] = cur + val * stacks;
        }
      }

      if (typeof mods.damageDealtPct === "number" && Number.isFinite(mods.damageDealtPct)) {
        damageDealtPct += mods.damageDealtPct * stacks;
      }

      if (typeof mods.damageTakenPct === "number" && Number.isFinite(mods.damageTakenPct)) {
        damageTakenPct += mods.damageTakenPct * stacks;
      }

      addSchoolMap(damageDealtPctBySchool, mods.damageDealtPctBySchool, stacks);
      addSchoolMap(damageTakenPctBySchool, mods.damageTakenPctBySchool, stacks);

      if (typeof mods.armorFlat === "number" && Number.isFinite(mods.armorFlat)) {
        armorFlat += mods.armorFlat * stacks;
      }

      if (typeof mods.armorPct === "number" && Number.isFinite(mods.armorPct)) {
        armorPct += mods.armorPct * stacks;
      }

      if (mods.resistFlat) {
        addSchoolMap(resistFlat, mods.resistFlat, stacks);
      }

      if (mods.resistPct) {
        addSchoolMap(resistPct, mods.resistPct, stacks);
      }
    }
  }

  return {
    attributesFlat,
    attributesPct,
    damageDealtPct,
    damageTakenPct,
    damageDealtPctBySchool,
    damageTakenPctBySchool,
    armorFlat,
    armorPct,
    resistFlat,
    resistPct,
  };
}

/**
 * Aggregate active status effects for combat / stats.
 *
 * - Cleans up expired effects.
 * - Sums contributions (taking stacks into account).
 * - Returns a pure snapshot; does not modify attributes directly.
 */
export function computeCombatStatusSnapshot(
  char: CharacterState,
  now: number = Date.now(),
): CombatStatusSnapshot {
  const state = ensureStatusState(char);
  return computeSnapshotFromState(state, now);
}

export function computeEntityCombatStatusSnapshot(
  entity: Entity,
  now: number = Date.now(),
): CombatStatusSnapshot {
  const state = ensureEntityStatusState(entity);
  return computeSnapshotFromState(state, now);
}

// Back-compat aliases for newer call sites (if any)
export const computeCombatStatusSnapshotForEntity = computeEntityCombatStatusSnapshot;

export type DotTickEvent = {
  effectId: StatusEffectId;
  damage: number;
  school: DamageSchool;
  /** Optional attribution forwarded from the status instance (set by spell/ability cast). */
  appliedByKind?: StatusEffectApplierKind;
  appliedById?: string;
  /** Optional source forwarding (spell/ability/item provenance). */
  sourceKind?: StatusEffectSourceKind;
  sourceId?: string;
  /** Optional display name of the effect/spell for messaging. */
  name?: string;
};

export type HotTickEvent = {
  effectId: StatusEffectId;
  heal: number;
};

/**
 * Tick HOT payloads on a character and emit healing ticks via callback.
 *
 * Caller owns applying the heal to an entity / persistence; this keeps StatusEffects pure.
 */
export function tickStatusEffectsAndApplyHots(
  char: CharacterState,
  now: number,
  applyHeal: (amount: number, meta: HotTickEvent) => void,
): void {
  const state = ensureStatusState(char);

  // Prune first so we don't tick dead/expired effects.
  tickStatusEffectsInternal(state, now);

  for (const bucket of Object.values(state.active)) {
    for (const inst of normalizeBucket(bucket)) {
      if (!inst?.hot) continue;

      const hot = inst.hot;
      const tickIntervalMs = Math.max(1, Math.floor(Number(hot.tickIntervalMs ?? 0)));
      const perTickHealBase = Math.max(1, Math.floor(Number(hot.perTickHeal ?? 0)));

      if (!Number.isFinite(tickIntervalMs) || tickIntervalMs <= 0) continue;
      if (!Number.isFinite(perTickHealBase) || perTickHealBase <= 0) continue;

      if (!Number.isFinite(hot.nextTickAtMs) || hot.nextTickAtMs <= 0) {
        hot.nextTickAtMs = (inst.appliedAtMs ?? now) + tickIntervalMs;
      }

      const expiresAt = inst.expiresAtMs ?? Number.MAX_SAFE_INTEGER;

      while (hot.nextTickAtMs <= now && hot.nextTickAtMs <= expiresAt) {
        const heal = perTickHealBase;

        try {
          applyHeal(heal, { effectId: inst.id, heal });
        } catch {
          // Healing application must never crash the tick loop.
        }

        hot.nextTickAtMs += tickIntervalMs;
      }
    }
  }
}

/**
 * Tick HOT payloads on an entity (NPC) and emit healing ticks.
 * (Useful for later; safe no-op today.)
 */
export function tickEntityStatusEffectsAndApplyHots(
  entity: Entity,
  now: number,
  applyHeal: (amount: number, meta: HotTickEvent) => void,
): void {
  const state = ensureEntityStatusState(entity);

  tickStatusEffectsInternal(state, now);

  for (const bucket of Object.values(state.active)) {
    for (const inst of normalizeBucket(bucket)) {
      if (!inst?.hot) continue;

      const hot = inst.hot;
      const tickIntervalMs = Math.max(1, Math.floor(Number(hot.tickIntervalMs ?? 0)));
      const perTickHealBase = Math.max(1, Math.floor(Number(hot.perTickHeal ?? 0)));

      if (!Number.isFinite(tickIntervalMs) || tickIntervalMs <= 0) continue;
      if (!Number.isFinite(perTickHealBase) || perTickHealBase <= 0) continue;

      if (!Number.isFinite(hot.nextTickAtMs) || hot.nextTickAtMs <= 0) {
        hot.nextTickAtMs = (inst.appliedAtMs ?? now) + tickIntervalMs;
      }

      const expiresAt = inst.expiresAtMs ?? Number.MAX_SAFE_INTEGER;

      while (hot.nextTickAtMs <= now && hot.nextTickAtMs <= expiresAt) {
        const heal = perTickHealBase;

        try {
          applyHeal(heal, { effectId: inst.id, heal });
        } catch {
          // Best-effort only.
        }

        hot.nextTickAtMs += tickIntervalMs;
      }
    }
  }
}

function tagsIntersect(a?: string[], b?: string[]): boolean {
  if (!a || a.length <= 0) return false;
  if (!b || b.length <= 0) return false;
  const set = new Set(b.map((x) => String(x).toLowerCase()));
  for (const t of a) {
    if (set.has(String(t).toLowerCase())) return true;
  }
  return false;
}

export interface ClearStatusEffectsOptions {
  /** Tags that make an effect immune to removal. */
  protectedTags?: string[];
  /** Tags that should be removed first (in listed order). */
  priorityTags?: string[];
  /** If set, an effect must include ALL of these tags to be eligible for removal. */
  requireTags?: string[];
  /** If set, effects with ANY of these tags are skipped (even if tags intersect). */
  excludeTags?: string[];
}


export interface ClearStatusEffectsResult {
  removed: number;
  /** Number of effects whose tags intersected the requested tags (before filters). */
  matched: number;
  blockedByProtected: number;
  blockedByRequire: number;
  blockedByExclude: number;
}

/**
 * Remove active status effects whose tags match any of the provided tags.
 * Returns number removed.
 *
 * Determinism:
 * - Removes newest-applied first (highest appliedAtMs), then stable by id.
 */
export function clearStatusEffectsByTags(
  char: CharacterState,
  tags: string[],
  maxToRemove?: number,
  now: number = Date.now(),
): number {
  const state = ensureStatusState(char);
  return clearStatusEffectsByTagsInternal(state, tags, maxToRemove, now);
}

export function clearEntityStatusEffectsByTags(
  entity: Entity,
  tags: string[],
  maxToRemove?: number,
  now: number = Date.now(),
): number {
  const state = ensureEntityStatusState(entity);
  return clearStatusEffectsByTagsInternal(state, tags, maxToRemove, now);
}

export function clearStatusEffectsByTagsEx(
  char: CharacterState,
  tags: string[],
  options?: ClearStatusEffectsOptions,
  maxToRemove?: number,
  now: number = Date.now(),
): number {
  const state = ensureStatusState(char);
  return clearStatusEffectsByTagsInternal(state, tags, maxToRemove, now, options);
}

export function clearEntityStatusEffectsByTagsEx(
  entity: Entity,
  tags: string[],
  options?: ClearStatusEffectsOptions,
  maxToRemove?: number,
  now: number = Date.now(),
): number {
  const state = ensureEntityStatusState(entity);
  return clearStatusEffectsByTagsInternal(state, tags, maxToRemove, now, options);
}


export function clearStatusEffectsByTagsExDetailed(
  char: CharacterState,
  tags: string[],
  options?: ClearStatusEffectsOptions,
  maxToRemove?: number,
  now: number = Date.now(),
): ClearStatusEffectsResult {
  const state = ensureStatusState(char);
  return clearStatusEffectsByTagsDetailedInternal(state, tags, maxToRemove, now, options);
}

export function clearEntityStatusEffectsByTagsExDetailed(
  entity: Entity,
  tags: string[],
  options?: ClearStatusEffectsOptions,
  maxToRemove?: number,
  now: number = Date.now(),
): ClearStatusEffectsResult {
  const state = ensureEntityStatusState(entity);
  return clearStatusEffectsByTagsDetailedInternal(state, tags, maxToRemove, now, options);
}

function clearStatusEffectsByTagsInternal(
  state: InternalStatusState,
  tags: string[],
  maxToRemove?: number,
  now: number = Date.now(),
  options?: ClearStatusEffectsOptions,
): number {
  tickStatusEffectsInternal(state, now);

  const lim = typeof maxToRemove === "number" && maxToRemove > 0 ? Math.floor(maxToRemove) : Number.MAX_SAFE_INTEGER;

  const protectedSet = new Set((options?.protectedTags ?? []).map((t) => String(t).toLowerCase()));

  type Ref = { bucketKey: string; inst: StatusEffectInstance; priority: number };
  const matches: Ref[] = [];

  for (const [bucketKey, bucket] of Object.entries(state.active)) {
    for (const inst of normalizeBucket(bucket)) {
      if (!inst) continue;
      if (tagsIntersect(inst.tags, tags)) {
        const instTags = (inst.tags ?? []).map((t) => String(t).toLowerCase());
        // Skip protected/unstrippable effects
        if (instTags.some((t) => protectedSet.has(t))) continue;

        const requireAll = (options?.requireTags ?? []).map((t) => String(t).toLowerCase());
        if (requireAll.length > 0 && !requireAll.every((t) => instTags.includes(t))) continue;

        const excludeAny = new Set((options?.excludeTags ?? []).map((t) => String(t).toLowerCase()));
        if (excludeAny.size > 0 && instTags.some((t) => excludeAny.has(t))) continue;

        let priority = 9999;
        const prio = options?.priorityTags ?? [];
        if (prio.length > 0) {
          for (let i = 0; i < prio.length; i++) {
            const pt = String(prio[i]).toLowerCase();
            if (instTags.includes(pt)) {
              priority = i;
              break;
            }
          }
        }

        matches.push({ bucketKey, inst, priority });
      }
    }
  }

  matches.sort((a, b) => {
    if (a.priority != b.priority) return a.priority - b.priority;
    const ta = a.inst.appliedAtMs ?? 0;
    const tb = b.inst.appliedAtMs ?? 0;
    if (ta !== tb) return tb - ta; // newest first
    const ida = a.inst.id ?? "";
    const idb = b.inst.id ?? "";
    return ida.localeCompare(idb);
  });

  const toRemove = new Set<StatusEffectInstance>();
  for (const m of matches) {
    if (toRemove.size >= lim) break;
    toRemove.add(m.inst);
  }

  let removed = 0;

  for (const [bucketKey, bucket] of Object.entries(state.active)) {
    const items = normalizeBucket(bucket);
    const kept = items.filter((inst) => {
      if (toRemove.has(inst)) {
        removed++;
        return false;
      }
      return true;
    });

    writeBucket(state, bucketKey, kept);
  }

  return removed;
}

function clearStatusEffectsByTagsDetailedInternal(
  state: InternalStatusState,
  tags: string[],
  maxToRemove?: number,
  now: number = Date.now(),
  options?: ClearStatusEffectsOptions,
): ClearStatusEffectsResult {
  tickStatusEffectsInternal(state, now);

  const lim = typeof maxToRemove === "number" && maxToRemove > 0 ? Math.floor(maxToRemove) : Number.MAX_SAFE_INTEGER;

  const protectedSet = new Set((options?.protectedTags ?? []).map((t) => String(t).toLowerCase()));
  const requireAll = (options?.requireTags ?? []).map((t) => String(t).toLowerCase());
  const excludeAny = new Set((options?.excludeTags ?? []).map((t) => String(t).toLowerCase()));

  type Ref = { bucketKey: string; inst: StatusEffectInstance; priority: number };
  const matches: Ref[] = [];

  let matched = 0;
  let blockedByProtected = 0;
  let blockedByRequire = 0;
  let blockedByExclude = 0;

  for (const [bucketKey, bucket] of Object.entries(state.active)) {
    for (const inst of normalizeBucket(bucket)) {
      if (!inst) continue;
      if (!tagsIntersect(inst.tags, tags)) continue;

      matched++;

      const instTags = (inst.tags ?? []).map((t) => String(t).toLowerCase());

      if (instTags.some((t) => protectedSet.has(t))) {
        blockedByProtected++;
        continue;
      }

      if (requireAll.length > 0 && !requireAll.every((t) => instTags.includes(t))) {
        blockedByRequire++;
        continue;
      }

      if (excludeAny.size > 0 && instTags.some((t) => excludeAny.has(t))) {
        blockedByExclude++;
        continue;
      }

      let priority = 9999;
      const prio = options?.priorityTags ?? [];
      if (prio.length > 0) {
        for (let i = 0; i < prio.length; i++) {
          const pt = String(prio[i]).toLowerCase();
          if (instTags.includes(pt)) {
            priority = i;
            break;
          }
        }
      }

      matches.push({ bucketKey, inst, priority });
    }
  }

  matches.sort((a, b) => {
    if (a.priority != b.priority) return a.priority - b.priority;
    const ta = a.inst.appliedAtMs ?? 0;
    const tb = b.inst.appliedAtMs ?? 0;
    if (ta !== tb) return tb - ta;
    const ida = a.inst.id ?? "";
    const idb = b.inst.id ?? "";
    return ida.localeCompare(idb);
  });

  const toRemove = new Set<StatusEffectInstance>();
  for (const m of matches) {
    if (toRemove.size >= lim) break;
    toRemove.add(m.inst);
  }

  let removed = 0;
  for (const [bucketKey, bucket] of Object.entries(state.active)) {
    const items = normalizeBucket(bucket);
    const kept = items.filter((inst) => {
      if (toRemove.has(inst)) {
        removed++;
        return false;
      }
      return true;
    });

    writeBucket(state, bucketKey, kept);
  }

  return { removed, matched, blockedByProtected, blockedByRequire, blockedByExclude };
}


/**
 * Consume absorb shields on the character and return remaining damage.
 *
 * Determinism:
 * - Shields are consumed oldest-first (lowest appliedAtMs).
 */
export function absorbIncomingDamageFromStatusEffects(
  char: CharacterState,
  amount: number,
  school: DamageSchool,
  now: number = Date.now(),
): { remainingDamage: number; absorbed: number } {
  const state = ensureStatusState(char);
  return absorbIncomingDamageFromState(state, amount, school, now);
}

export function absorbIncomingDamageFromEntityStatusEffects(
  entity: Entity,
  amount: number,
  school: DamageSchool,
  now: number = Date.now(),
): { remainingDamage: number; absorbed: number } {
  const state = ensureEntityStatusState(entity);
  return absorbIncomingDamageFromState(state, amount, school, now);
}

function absorbIncomingDamageFromState(
  state: InternalStatusState,
  amount: number,
  school: DamageSchool,
  now: number,
): { remainingDamage: number; absorbed: number } {
  tickStatusEffectsInternal(state, now);

  let remaining = Math.max(0, Math.floor(Number(amount ?? 0)));
  if (!Number.isFinite(remaining) || remaining <= 0) return { remainingDamage: 0, absorbed: 0 };

  type Ref = { bucketKey: string; inst: StatusEffectInstance };
  const shields: Ref[] = [];

  for (const [bucketKey, bucket] of Object.entries(state.active)) {
    for (const inst of normalizeBucket(bucket)) {
      const abs = (inst as any)?.absorb as AbsorbPayloadState | undefined;
      if (!abs) continue;
      if (!Number.isFinite(abs.remaining) || abs.remaining <= 0) continue;

      const schools = abs.schools;
      if (Array.isArray(schools) && schools.length > 0) {
        if (!schools.includes(school)) continue;
      }

      shields.push({ bucketKey, inst });
    }
  }

  shields.sort((a, b) => {
    const ta = a.inst.appliedAtMs ?? 0;
    const tb = b.inst.appliedAtMs ?? 0;
    if (ta !== tb) return ta - tb; // oldest first
    const ida = a.inst.id ?? "";
    const idb = b.inst.id ?? "";
    return ida.localeCompare(idb);
  });

  let absorbed = 0;
  const depleted = new Set<StatusEffectInstance>();

  for (const ref of shields) {
    if (remaining <= 0) break;
    const abs = (ref.inst as any).absorb as AbsorbPayloadState | undefined;
    if (!abs) continue;

    const take = Math.min(remaining, Math.max(0, Math.floor(Number(abs.remaining ?? 0))));
    if (take <= 0) continue;

    abs.remaining -= take;
    remaining -= take;
    absorbed += take;

    if (!Number.isFinite(abs.remaining) || abs.remaining <= 0) {
      abs.remaining = 0;
      depleted.add(ref.inst);
    }
  }

  if (depleted.size > 0) {
    for (const [bucketKey, bucket] of Object.entries(state.active)) {
      const items = normalizeBucket(bucket);
      const kept = items.filter((inst) => !depleted.has(inst));
      writeBucket(state, bucketKey, kept);
    }
  }

  return { remainingDamage: remaining, absorbed };
}

/**
 * Tick DOT payloads on an entity (NPC) and apply damage via callback.
 *
 * This function:
 *  - prunes expired effects
 *  - computes defender taken modifiers ONCE per call
 *  - emits one or more dot ticks if time advanced beyond the next tick time
 *
 * Note: damage application is intentionally handled externally so callers can route it
 * through NpcManager (crime/aggro hooks) or just subtract hp in tests.
 */
export function tickEntityStatusEffectsAndApplyDots(
  entity: Entity,
  now: number,
  applyDamage: (amount: number, meta: DotTickEvent) => void,
): void {
  const state = ensureEntityStatusState(entity);

  const isDeadEntity = (): boolean => {
    const hp = (entity as any)?.hp;
    const alive = (entity as any)?.alive;
    return (typeof hp === "number" && hp <= 0) || alive === false;
  };

  // If the entity is already dead (corpse), its combat status should be empty.
  // (Corpse state is handled by other systems; status effects should not persist.)
  if (isDeadEntity()) {
    state.active = {};
    return;
  }

  // Prune first so we don't tick dead effects.
  tickStatusEffectsInternal(state, now);

  let defenderStatus: CombatStatusSnapshot | null = null;
  try {
    defenderStatus = computeSnapshotFromState(state, now);
  } catch {
    defenderStatus = null;
  }

  for (const bucket of Object.values(state.active)) {
    for (const inst of normalizeBucket(bucket)) {
      if (!inst?.dot) continue;

      const dot = inst.dot;
      const tickIntervalMs = Math.max(1, Math.floor(Number(dot.tickIntervalMs ?? 0)));
      const perTickDamageBase = Math.max(1, Math.floor(Number(dot.perTickDamage ?? 0)));
      const school: DamageSchool = (dot.damageSchool as DamageSchool) ?? "pure";

      if (!Number.isFinite(tickIntervalMs) || tickIntervalMs <= 0) continue;
      if (!Number.isFinite(perTickDamageBase) || perTickDamageBase <= 0) continue;

      if (!Number.isFinite(dot.nextTickAtMs) || dot.nextTickAtMs <= 0) {
        dot.nextTickAtMs = (inst.appliedAtMs ?? now) + tickIntervalMs;
      }

      // Inclusive end: allow a tick exactly at expiresAtMs.
      const expiresAt = inst.expiresAtMs ?? Number.MAX_SAFE_INTEGER;

      while (dot.nextTickAtMs <= now && dot.nextTickAtMs <= expiresAt) {
        if (isDeadEntity()) {
          state.active = {};
          return;
        }

        let dmg = perTickDamageBase;

        // Apply defender taken modifiers at tick time (debuffs amplify DOTs too).
        if (defenderStatus) {
          const globalTaken =
            typeof defenderStatus.damageTakenPct === "number" ? defenderStatus.damageTakenPct : 0;
          const bySchoolTaken = (defenderStatus.damageTakenPctBySchool as any)?.[school];
          const bySchoolN = typeof bySchoolTaken === "number" ? bySchoolTaken : 0;

          const takenPct =
            (Number.isFinite(globalTaken) ? globalTaken : 0) +
            (Number.isFinite(bySchoolN) ? bySchoolN : 0);

          if (takenPct) {
            const after = dmg * (1 + takenPct);
            dmg = Number.isFinite(after) && after > 0 ? Math.floor(after) : dmg;
          }
        }

        if (!Number.isFinite(dmg) || dmg < 1) dmg = 1;

        try {
          applyDamage(dmg, {
            effectId: inst.id,
            damage: dmg,
            school,
            appliedByKind: inst.appliedByKind,
            appliedById: inst.appliedById,
            sourceKind: inst.sourceKind,
            sourceId: inst.sourceId,
            name: inst.name,
          });
        } catch {
          // DOT application must never crash the tick loop.
        }

        // If the tick killed the entity, stop immediately and clear effects.
        if (isDeadEntity()) {
          state.active = {};
          return;
        }

        dot.nextTickAtMs += tickIntervalMs;
      }
    }
  }

  // If the entity died during this tick (e.g., via DOT damage), clear any remaining effects.
  if (isDeadEntity()) {
    state.active = {};
    return;
  }

  // Prune again (expiry moment inclusive, so this will clean up on the next tick).
  tickStatusEffectsInternal(state, now);
}
